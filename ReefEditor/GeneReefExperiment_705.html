<html><head>
<script>

//The NFT maker functions are being redesigned.
//dataUrlForNFTNumber1To8888 jsonForNFTNumber1To8888 dataUrlForNFTNumber1To8888 and saveNFT only ever worked for 1 reef at a time.
//I'm moving these to a script near the bottom of this file, after the 2 jszip scripts. Use makeSpecies func instead.
//Search for "The NFT maker functions are being redesigned - here they are".

console.log('This will be opensourced (MIT license?) after the 8888 NFTs are on cardano blockchain or maybe wait until theyre sold. This includes existing opensource (MIT license) from various software at https://github.com/benrayfield/');

"use strict";

//options is a {}, what you find in those 1k to 5k json files.
var loadReef = options=>{
	if(!bootedBuilder) throw 'Not booted yet. TODO this might need to wait longer, such as after document body loads?';
	options = copyMap(options);
	putInDefaults(options);
	if(options.timeSaved === undefined) options = {timeSaved: Now(), options: options};
	onDragJson(betterJsonStringify(options), options.options.name);
};

//for makeSpecies.
var bootShapes = [

//`//snail or spiral
`a=>.1*a`,

//`//small circle
`a=>.3`, //cuz reducing bootShape when generating them (see makeBootShapeReefFromCode in this file).
//a=>.2`,

/*
`//from growInwardFromCircle.json, the border circle, if bootShapeScale is 1 and bootShapeX and bootShapeY are both near 0. Some logic checks for growInward in this comment.
a=>1`,
*/

//`//modified of: from growInwardFromCircle.json, the border circle, if bootShapeScale is 1 and bootShapeX and bootShapeY are both near 0. Some logic checks for growInward in this comment.
`a=>o.borderRadiusMul //growInward`,

//`//fourBalloons
`a=>Math.sin(a*2)`,

//`//fiveBalloonsOneHigh
`a=>Math.sin(a*2.5)`,

//`//randomRadius
`a=>.1+Math.random()`,

//`//strange boot shape
`a=>(Math.sin(a*2+Math.sin(a*3.5)))`,

//`//spiral
`a=>{
let ang = a*5;
let rad = a*.13;
return [rad*sin(ang),rad*cos(ang)];
}`,

//`//twoTrianglesConnected
`a=>{
let ys = [1,2,3,4,5];
let xs = [1,2,1,2,1];
let mul = .27, addy = -1;
a *= ys.length/(2*Math.PI);
let lo = fl(a), hi = (lo+1)%ys.length;
let m = a-lo;
return [(ys[lo]*(1-m)+m*ys[hi])*mul+addy,(xs[lo]*(1-m)+m*xs[hi])*mul]
}`,

//`//sevenPointedStar
`a=>{
let ys = [];
let xs = [];
let n = 7;
for(let i=0; i<n; i++){
	let ang = i/n*2*Math.PI;
	ys.push(sin(ang*2));
	xs.push(cos(ang*2));
}
let mul = .7;
a *= ys.length/(2*Math.PI);
let lo = fl(a), hi = (lo+1)%ys.length;
let m = a-lo;
return [(ys[lo]*(1-m)+m*ys[hi])*mul,(xs[lo]*(1-m)+m*xs[hi])*mul]
}`,

//fivePointedStar
`a=>{
let ys = [];
let xs = [];
let n = 5;
for(let i=0; i<n; i++){
	let ang = i/n*2*Math.PI;
	ys.push(sin(ang*2));
	xs.push(cos(ang*2));
}
let mul = .7;
a *= ys.length/(2*Math.PI);
let lo = fl(a), hi = (lo+1)%ys.length;
let m = a-lo;
return [(ys[lo]*(1-m)+m*ys[hi])*mul,(xs[lo]*(1-m)+m*xs[hi])*mul]
}`,

//`//pentagon
`a=>{
let ys = [];
let xs = [];
let n = 5;
for(let i=0; i<n; i++){
	let ang = i/n*2*Math.PI;
	ys.push(sin(ang));
	xs.push(cos(ang));
}
let mul = .5;
a *= ys.length/(2*Math.PI);
let lo = fl(a), hi = (lo+1)%ys.length;
let m = a-lo;
return [(ys[lo]*(1-m)+m*ys[hi])*mul,(xs[lo]*(1-m)+m*xs[hi])*mul]
}`,

//`//triangle
`a=>{
let ys = [];
let xs = [];
let n = 3;
for(let i=0; i<n; i++){
	let ang = i/n*2*Math.PI;
	ys.push(sin(ang));
	xs.push(cos(ang));
}
let mul = .5;
a *= ys.length/(2*Math.PI);
let lo = fl(a), hi = (lo+1)%ys.length;
let m = a-lo;
return [(ys[lo]*(1-m)+m*ys[hi])*mul,(xs[lo]*(1-m)+m*xs[hi])*mul]
}`,

//`//square
`a=>{
let ys = [1,1,-1,-1];
let xs = [-1,1,1,-1];
let mul = .5;
a *= ys.length/(2*Math.PI);
let lo = fl(a), hi = (lo+1)%ys.length;
let m = a-lo;
return [(ys[lo]*(1-m)+m*ys[hi])*mul,(xs[lo]*(1-m)+m*xs[hi])*mul]
}`,

`a=>[
(a*cos(Math.pow(1.4,a)+22/(1+a))*sin(a*.23)+sin(3.2+cos(sin(a)*a)))/5+.5,
(sin(a)+sin(3.2+cos(sin(a/3+2)*Math.pow(112/(a+.1),.25))))/2
]`,

`a=>[
(sin(a*.23)+sin(3.2+cos(sin(a)*a)))/3,
(sin(a)+sin(3.2+cos(sin(a/3+2)*Math.pow(112/(a+.1),.25))))/2
]`,

`a=>[
(sin(a*3)+sin(3.2+cos(sin(a)*a)))/3,
(sin(a)+sin(3.2+cos(sin(a/3+2)*Math.pow(112/(a+.1),.25))))/2
]`,

'a=>.3*(sin(a*3)+sin(3.2+a*23))',
//a=>(sin(a*3)+sin(3.2+a*23))

'a=>.4*(sin(a*3)+sin(a/5))',

`a=>[
(sin(a*3)+sin(3.2+cos(sin(a)*a)))/3,
(sin(a)+sin(3.2+cos(sin(a)*a)))/2
]`,

//`//tiltedSineWaveCrossesItselfInCenter
`a=>[
(sin(a*3)+sin(3.2+a*.23))*.5+.3,
(sin(a*3)+sin(a/5))/2-.3
]`,

//`//fatBone
`a=>[
sin(a+cos(a*2))/3,
cos(a)/2
]`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += dt*(.3*sin(y*y*y*5/(.1+x)));
	y -= dt*(x*x*x*45);
}
let mul = .5/Math.hypot(y,x);
return [y*mul,x*mul];
}`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += dt*(.3*sin(y*5));
	y -= dt*(x*x*x*45);
}
let mul = .5/Math.hypot(y,x);
return [y*mul,x*mul];
}`,

//`//polesCrossEachother
`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += .3*sin(y*5);
	y -= .03*cos(2.3+x*11);
}
let mul = .5/Math.hypot(y,x);
return [y*mul,x*mul];
}`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += 13*dt*(.3*sin(y*5/(2.1+x*y)));
	y -= 4*dt*(x*5/(.1+i));
}
let mul = .5/Math.hypot(y,x);
return [y*mul,x*mul];
}`,

//`//coil
`a=>[
.6*(sin(a*3)+sin(3.2+a*.23))*.5+.3,
.6*(sin(a*3)+cos(a*3))/2
]`,
//a=>[
//(sin(a*3)+sin(3.2+a*.23))*.5+.3,
//(sin(a*3)+cos(a*3))/2
//]

//`//curvyNearMiddleSticksOutBottomRight
`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += dt*x*(2+sin(y*5));
	y += dt*44*sigmoid(x+8/(1+3*y)-2);
}
let mul = .05;
return [y*mul,x*mul];
}`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += 1.5*dt*x*y;
	y += 3*dt*sigmoid(8*y*y-2);
}
let mul = .1;
return [y*mul,x*mul];
}`,


//`//pointyHill
`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += 1.5*dt*x*y;
	y += 3*dt*sigmoid(8/(1+3*y)-2);
}
let mul = .15;
return [y*mul,x*mul];
}`,

//`//bentPolesALittleCrossing
`a=>{
let x=cos(a), y=sin(a), dt=.01;
let z = sin(a);
for(let i=0; i<1; i+=dt){
	x += dt*2.8*(y-z);
	y += dt*1.6*(y-x/(3+z));
	z += dt*4.7*(z+x*y);
}
let mul = .04;
y *= mul;
x *= mul;
let len = Math.hypot(y,x);
if(len > 1){ y /= len; x /= len; }
return [y,x];
}`,

//`//curvySShapeALittleCrossing
`a=>{
let x=cos(a), y=sin(a), dt=.01;
let z = sin(a*3);
for(let i=0; i<1; i+=dt){
	x += dt*3*(y-z);
	y += dt*.8*(y-x+z);
	z += dt*.7*(z+x*y);
}
let mul = .14;
return [y*mul,x*mul];
}`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
let z = sin(a*3);
for(let i=0; i<1; i+=dt){
	x += dt*x*1.2*(2+sin(y*5));
	y += dt*44*sigmoid(x+8/(1+3*y)-2+z*1.6);
	z += dt*(x+y)*.3;
}
let mul = .05;
return [y*mul,x*mul];
}`,

//`//flatHeadMushroomConeBase
`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += 1.5*dt*x*sin(y*5);
	y += 3*dt*sigmoid(8/(1+3*y)-2);
}
let mul = .25;
return [y*mul,x*mul];
}`,

//`//partOfACircleLayingOnPoleStickingUp
`a=>{
let x=cos(a), y=sin(a), dt=.01;
for(let i=0; i<1; i+=dt){
	x += dt*(.3*sin(y*5));
	y -= dt*(.03*cos(2.3+x*11)+.99/(1+x));
}
let mul = .5/Math.hypot(y,x);
return [y*mul,x*mul];
}`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
let z = sin(a*3);
for(let i=0; i<1; i+=dt){
	x += dt*x*1.2*(2+sin(y*5)-z*.1);
	y += dt*14*sigmoid(x+8/(1+3*z)-2+z*1.6);
	z += dt*(x+y)*.3;
}
let mul = .05;
return [y*mul,x*mul];
}`,

`a=>{
let x=cos(a), y=sin(a), dt=.01;
let z = sin(a*3);
for(let i=0; i<1; i+=dt){
	x += dt*x*1.2*(2+sin(y*5)-z);
	y -= dt*34*sigmoid(x+(z*y)/(1+3*z)-2+z*3.6);
	z -= dt*(x+y)*(5+z)*.003;
}
let mul = .025;
return [y*mul,x*mul];
}`,

//`//pie with top right quarter removed
`a=>{ a /= 2*Math.PI; return (.25<a && a<.5) ? 0 : 1; }`,

//`//diagonal line through half circle
`a=>{
let m = .5;
a = (a-Math.PI/200)%(2*Math.PI);
if(a<Math.PI){
	return [cos(a)*m,cos(a)*m];
}else{
	return [cos(a)*m,.3+sin(a)*m];
}
}`,

//`//2 part circles and 2 crossing lines
`a=>{
let m = .5;
if(a<Math.PI*2/3){
	return [1.5*cos(a)*m, 1.5*sin(a)*m];
}else{
	return [-cos(a)*m, -.3-sin(a)*m];
}
}`,

//`//fat spiral or snail shell
`a=>Math.cbrt(a/(2*Math.PI))/2`,

//`//old kind of key hole
`a=>{
let m = .5;
let b = (a+Math.PI*1.85)%(2*Math.PI);
if(a<Math.PI*.3){
	return [1.3*cos(b)*m, 1.3*sin(b)*m];
}else{
	return [.6*cos(b)*m, .6*sin(b)*m];
}
}`,

//`//half of circle slides off the other half
`a=>{
let m = .5;
a = (a-Math.PI/200)%(2*Math.PI);
if(a<Math.PI){
	return [sin(a)*m,cos(a)*m];
}else{
	return [sin(a)*m,.3+cos(a)*m];
}
}`,

//`//loop B or corner of pacmans lip has something tied to it
`a=>{
let m = .5;
a = (a-Math.PI/200)%(2*Math.PI);
if(a<Math.PI){
	return [1.5*cos(a*.5)*m-.1, 1.2*sin(a)*m];
}else{
	return [cos(a*1.5)*m-.1, sin(a*1.5)*m];
}
}`,

//`//similar to half moon but could use better angles of the 2 circles, and it has 2 short straight lines between them
`a=>{
let m = .5, dx=-.2;
if(a<Math.PI){
	return [cos(-a)*m, .3-sin(-a)*m+dx];
}else{
	return [cos(-a)*m, sin(-a)*m+dx];
}
}`,

//`//bent oval with 8 shaped loop around its topright to top bottom
`a=>{
let m = .3, dx=.2;
let ay = cos(-a*2)*m;
let ax = .3-sin(-a*2)*m+dx;
let by = cos(-a*2)*m;
let bx = sin(-a*2)*m+dx;
let mix = sin(a);
return [ay*mix+(1-mix)*by, ax*mix+(1-mix)*bx];
}`,

'a=>{let M=Math;a/=(2*M.PI);let b=(1+M.sin(a));let c=(a+a);let d=(a*a);let e=(2+M.sin(c));let f=(d+c);let g=-c;let h=M.exp(f);let i=(M.sin(h));let j=M.cos(f);return [i*.5,j*.5];}',

];

/*

v684
madscientist â€” Today at 8:00 PM
Before I do anything more, I need feedback on these many html files, and the metadata (in the .cardano.json files if you copy its contents to poolpm textarea), on the background color, foreground color, combos of colors (are some too bright while others too dark, is the background ever too close to the foreground color, is it too big (zoom in or out), is the metadata confusing, etc... If you unzip this (with 7zip) it has 3 files per reef, one for poolpm (.cardano.json), one for the reef builder (.options.json), and one you just doubleclick and it opens the reef right away (.html).
Attachment file type: archive
reefs_1_to_600_the_fast_way_and_species137_nearly_the_biggest_species_the_max_compress_way_madeByBraveBrowser_2022-4-11-7p.7z
500.49 KB
also, we only have room for 1 or 2 sentences of description, unless we shrink the few biggest reefs even more. the paragraph of description is currently too big.
should they be modifed to stay in the border circle instead of the farther away square border (theres a slider for that, which wasnt always used).

v681
"test_GeneReef_S69E5_2face _small" in testReefs_total8888_from1_to_555_2022-4-10-620pEST.(zip or 7z) is broken (says "no points" on browser console), but others in same species work. No points, comes from the shape of it shrinking to a point. We need to test this stuff better.
newest 302 reefs are in that 7z, along with 555 generated reefs
Boot shapes and background color and metadata is created. Just slight adjustments and testing to do, and the MAX COMPRESS will take a few days of compute time after that (not manual)
you can see all this if you doubleclick any of those 555 html files
Some of the colors seem boring and dull. we should spend more time choosing a good set of colorSeeds.
Image
GeneReef0001 is the rarest, and GeneReef8888 is the least rare.
GeneReefer â€” Today at 9:31 AM
The  colorseeds are very similar we can try to add some manual color options
madscientist â€” Today at 9:43 AM
Most of them are very similar. Some arent
madscientist â€” Today at 1:25 PM
down to 286 reefs. all are small enough (according to the size checker at top right, which is just an estimate). I will add 14 more from those removed earlier, unless someone wants to choose the next 14 reefs. I will use the jpg pic from twitter if you dont give me a different pic. Theres still a "no points" bug on at least that one reef, more testing is needed. Some of the bootshapes look too big (use bootShapeScale) and the automation of bootShape maybe should leave bootShapeScale as it is instead of setting it to 1, since that might interfere with some reefs that grow inward from the border circle. I dont know if those were removed.
Attachment file type: archive
reefs_2022-4-11-120pEST.7z
235.85 KB

v680
madscientist â€” Today at 7:04 PM
Description metadata: Moving art. Reef-like physics sim of a curvy line as a neuralnet paintbrush. Many parameters tuned by hand per species, including hand painted loops of varying parts of potential-energy equation over time, and other parts generated. Like 3body, small changes in timing or starting shape lead to different outcomes
Should probably include something like this too in description (from twitter): A collection of 8,888 Corals growing, evolving, & fully stored on the #Cardano Blockchain. May 2022ðŸŒŠ #CNFT http://discord.gg/ER2ykvySZS
About "evovling". Some of them were kind of evolved (by harmony-search) from pairs of reefs, but the NFTs dont further evolve
I could make dragging one onto another evolve in the NFTs, but it would be more limited kind of evolving due to the builder tool is alot bigger than 16k. This is a working evolve button 
Image
the reefs whose names start with evo were evolved, and maybe manually adjusted after that
we could do a cryptokitties-like thing, but theres not much space left for such behaviors. it would have to be really simple

v675
For the first time, I made 8888 reefs. Here they are, and the html and 302 input reefs that made them. It took 40 minutes. Can make as few or many at at time as you want. The 300 species are clickable at the bottom of the builder. Theres still work to do on the rarities, metadata, and they're not compressed yet, but you can test some of these. Many of these are deployable now, but dont deploy these. 7zip (7z files) made this 160 times smaller (its 177mB unzipped).
Attachment file type: archive
GeneReef2022-4-9-620pEST_8888Reefs_notMaxCompressed_raritiesNotDone_hasBuilder675_took40MinutesToMake.7z
1.10 MB
...
Have you deployed a test reef yet (just 1, as close to 16383 bytes as possible, without going over)?
test deploy should be a max compressed
madscientist â€” Today at 6:50 PM
these include the options json and cardano json for each of the 8888. these are very different from the final 8888 cuz of the rarities.
Image
"test_GeneReef_S171E6_normal reef ababxyzz - variable attraction to center.cardano.json" is exactly the theoretical max size that can fit in cardano (16383 bytes). Its in that 7z.
Its this one.
Image
madscientist â€” Today at 7:15 PM
We will be putting about 140mB on cardano which is about 1% of the total size of cardano (or is that not counting metadata), but as @GeneReefer said it only happens 1 NFT at a time as they're bought. Cardano seems to be expanding exponentially and may collapse under its own size if not reorganized maybe in 5 or 10 years, or maybe the transaction metadata (limited to 16k each) is or could be stored separately.
In theory, transactions on a blockchain can be verified without verifying its bigger parts (metadata or files on ipfs) that can be thought of like sidechains. If that optimization is used, then you could make up a hash and claim its a metadata, that doesnt even exist, and transact on it, which probably would not cause any problem except confusion of what does it refer to. I dont know if cardano works that way.

v673
This is just to get rid of the separate dirs and move that into the json and the page.
Attachment file type: archive
allReefs_dirMovedIntoJson_includesBuilder673_2022-4-9-1pEST.7z
205.05 KB
... (451 KB left)
Expand
GeneReefExperiment_673.html
501 KB
From now on lets use 7z instead of zip, cuz files will start being bigger soon https://www.7-zip.org/download.html
dir can be anything, doesnt have to be a number, however you want to organize it, but for now its always 1 2 3 or 4
if you drag in older reefs, that i havent upgraded to have a dir, they get dir "1"

v671
You can use multiple browser tabs at once to make cardano json files, since its so slow.
Image
using more browser tabs at once than you have cpus wont help
we should finalize what will be included in the metadata before making alot of cardano jsons
and @GeneReefer is still working on making total 300 reefs
madscientist â€” Today at 12:20 PM
Big reefs (from the 2022-3-12  newest_collection) have been shrinked to fit. @GeneReefer you should merge these into the 300 total reefs you're finding or making, including various zip/rar files people put in this chatroom.
Attachment file type: archive
shrinking 2022-4-1-1220pEST - (smaller replacements for 46 big file reefs in newest_collection_fromGenereefer_2022-3-12-745aEST.rar) .zip
..
Theres some cardano jsons in there, ready to deploy other than metadata. Can you guys test that too
@GeneReefer said since the NFT listing websites display the NFT directly, instead of the thumbnail, that there will be just 1 thumbnail shared by all 8888 reefs, either a high quality pic or a GIF (or can the thumbnail be a video file?). Is someone making that? It should be small enough to load fast, maybe less than 200k.
also, check whats the max size thumbnail, and file types, allowed by the NFT listing websites, cuz they might refuse to display it at all if they dont like the thumbnail for some reason
...
madscientist â€” Today at 12:40 PM
In reef chat "Shake Your Monet Maker â€” 03/29/2022
Thatâ€™s fair. But soooo good with music"
I could for about 200 bytes add microphone code to move a slider by the bass heard in microphone. You'd have to click a button to start it since you dont want a microphone permission popup every time its viewed. You could play your own music and it would hear it and move
..
madscientist â€” Yesterday at 12:54 PM
@GeneReefer How long until you need me again?
GeneReefer â€” Today at 10:27 AM
can we have a meeting on monday? @madscientist
madscientist â€” Today at 10:42 AM
yes. I'm being rushed on another project for the next 2-3 weeks, but I think reefs is mostly done (except for possible future collections), as the builder can generate many cardano jsons at once that look good in poolpm, so it should be just a few small adjustments from me.
I am often available for fast questions or small changes
fastest way to reach me is txtmsg to usa ----- but I will see stuff here too
it is a small change to adjust the statistics or combos of bootShapes, sliders, colors, etc, to change how the 8888 reefs would be generated (which you can tell it a range such as 7000 to 7100) to generate in a zip file.

v670
You can now tell if its probably going to fit on cardano by this sizeOfOptions estimate. When it turns red, its too big. You wont know for sure until clicking that button with max compress checked, and if theres any extra metadata (left enough space for a little more). It changes while you change the reef, but you might have to click things an extra time for it to update.
sizeOfOptions.png

v668
fixed a bug where bootShapeScale bootShapeY and bootShapeX only worked for the a=>.2 aka radius kind of bootShape but not (fixed now) the a=>[y,x] kind of bootShape, and now radius allows more range

v667
The "dragging in json file changes" checkboxes work now, such as you can drag in the grooves of one reef, into the displayed reef, or just the colors (including reef and background colors) or just the hills or just the bootShape etc. There might still be some bugs in it, so let me know.
..
These shapes could be made as bootShapes, but a hexagon will quickly become a circle, unless its rewinding time back to when it started (which is common). They could instead be done, with more work, using endist, which can make something like a heightmap (and more advanced things) of any shape an equation chooses, as long as the equation says what the height/potentialEnergy is at that y and x position. It could, in theory, make reefs fit inside or outside any of those shapes.
They could also be made less accurately using hills.
A hill can attract, repel, or accelerate in a direction.
A hill can be any size and any strength.

v665
theres an "only display selected groove" checkbox, so you can select a groove by clicking its name (right of a slider) and not get lost in so many other grooves.

v660
The html file now makes zip files of many reefs, both kinds of json (1-5kB options and 14-16kB cardano/poolpm). Here's some pics and 2 zip files and a new html. Try testing these, and help me choose the rarities/statistics.
(refers to batches/2022-3-27)
It combines them in a loop. This loop is where to put the rarities. It needs more work. var makeNOptions = (n, slidersAndGroovesReefs, colorsReefs, bootShapesReefs, fractionToChangeBootShapes)=>{
    return repeatable(()=>{
        let ret = [];
        let sIndex = 0;
        while(ret.length < n){
            let s = slidersAndGroovesReefs[(sIndex++)%slidersAndGroovesReefs.length];
            let c = colorsReefs[randInt(colorsReefs.length)];
            let b = bootShapesReefs[randInt(bootShapesReefs.length)];
            let opt = makeOptions(s, c, b);
            opt.name = 'testReef'+(ret.length+1)+'of'+n+'_'+opt.name;
            ret.push(opt);
            if(ret.length && ret.length%100==0) console.log('makeNOptions '+ret.length+'/'+n);
        }
        return ret;
    });
};
That repeatable(...) function sets the pseudorandomness so if you do this multiple times it will always give the same result, in theory.

v657
I just got us another 1.2kB of space, but it will cost us about 12 days of compute time spent on automatic compressing. I might rent 100 computers at amazon to do it faster. This only happens when the MAX COMPRESS checkbox is checked. The lowest SAVE button still saves instantly. Here's an example of the difference in compression. Its the exact same behaviors, just smaller. You need at least version 657 to do it. See this dir with evo_hyperactive_cell 2 with tumor 365.json selected. Probably whats above it wont fit (51 reefs), and whats below it (192 reefs) will, and theres probably some other reefs that havent been merged into the teams one zip file yet. You could try using less points (click 16 or 32 instead of 64), use less hills, use less grooves, etc, to make some of those smaller so a variant of them would fit.
evo_hyperactive_cell_2_with_tumor_365.maxCompress.cardanojson
16.00 KB
Attachment file type: unknown
evo_hyperactive_cell_2_with_tumor_365.normalCompress.cardanojson
17.13 KB
evo_hyperactive_cell_2_with_tumor_365.json
I'm moving on to generating 8888 cardano jsons, which wont be the final 8888 of them, just a set we can look at and make adjustments, add new reefs, colors, etc. I need to get the process automated. Then I'll do it with MAX COMPRESS which I'll need to rent some computers (or 12 days) for. Then we deploy to cardano.
I'll generate the smaller options jsons first, which can be dragged into the builder.
I'll make half the reefs with existing bootshapes and half select randomly from my new bootshapes.

v649
It broke something about endist. it works in the reef builder but not when you save it to cardano or html. v641 didnt have that endist bug.

v646
TODO use these bootshapes copy/pasted into chat, or make better ones:
a=>{let M=Math;a/=(2 * M.PI);let b=M.sqrt(M.abs(a));let c=(1/(1+b));let d=-c;let e=M.cbrt(a * a * a);let f=(a+d);let g=-d;let h=M.cbrt(f * d * g);let i=M.cbrt(g * d * f);let j=M.sqrt(M.abs(h));return j;}
a=>{let M=Math;a/=(2 * M.PI);let b=(a<0 ? a : a);let c=b * b;let d=M.hypot(a,c);let e=M.sign(b);let f=d * d;let g=(a+f);let h=(b<0 ? c : a);let i=(M.sin(d));let j=M.cos(h);return j;}
a=>{let M=Math;a/=(2 * M.PI);let b=M.min(a,a);let c=M.hypot(b,b);let d=(b+a);let e=M.floor(c);let f=M.min(e,a);let g=M.tanh(f);let h=(2+M.sin(e));let i=(e+g);let j=M.abs(e);return j;}
a=>{let M=Math;a/=(2 * M.PI);let b=(a+a);let c=M.cos(b);let d=(1/(1+a));let e=(d * c);let f=(c%b);let g=(e+c);let h=(e*c);let i=M.min(h,g);let j=M.min(i,e);return j;}
a=>{let M=Math;a/=(2 * M.PI);let b=(a+a);let c=M.sqrt(M.abs(b));let d=(c*b);let e=(b+a);let f=M.max(0,M.min(c,1));let g=M.sqrt(M.abs(a));let h=(g * c);let i=(M.sin(f));let j=(M.sin(d));return [i,j];}
a=>{let M=Math;a/=(2 * M.PI);let b=M.round(a);let c=(M.sin(b));let d=(M.sin(a));let e=(b%d);let f=M.sign(a * b) * M.sqrt(M.abs(a*b));let g=(b%f);let h=M.tanh(g);let i=M.max(0,M.min(b,1));let j=(1/(1+i));return j;}



v645
First try at making random bootShapes, found these 3 that work, but it usually gives up after 1000 tries / 1 second. If you uncheck the box beside the random bootShape button, it does radius mode which is easier since it only has to make 1 number (radius) instead of 2 numbers (y x), that pass test cases. I think I can make it work by doing testing during each next adding of variable, instead of waiting until the end. 
..
a=>{let M=Math;a/=(2 * M.PI);let b=M.sqrt(M.abs(a));let c=(1/(1+b));let d=-c;let e=M.cbrt(a * a * a);let f=(a+d);let g=-d;let h=M.cbrt(f * d * g);let i=M.cbrt(g * d * f);let j=M.sqrt(M.abs(h));return j;}
..
a=>{let M=Math;a/=(2 * M.PI);let b=(a<0 ? a : a);let c=b * b;let d=M.hypot(a,c);let e=M.sign(b);let f=d * d;let g=(a+f);let h=(b<0 ? c : a);let i=(M.sin(d));let j=M.cos(h);return j;}
..
a=>{let M=Math;a/=(2 * M.PI);let b=M.min(a,a);let c=M.hypot(b,b);let d=(b+a);let e=M.floor(c);let f=M.min(e,a);let g=M.tanh(f);let h=(2+M.sin(e));let i=(e+g);let j=M.abs(e);return j;}
..
It also tells you whats wrong with the last one it came up with before it gave up, so you might be able to fix it.
it crashes the browser tab sometimes so you have to reload the page. this is cuz it makes a shape that somehow leads to having 0 points in a curve. i blocked it from making shapes that start so small they do that, so i dont know how its doing it
evolving code is in general very hard to not crash things

v641
All those things (background color when borderFraction, undefined sliders) have been fixed, and you can now make your own bootShapes. I've added instructions how to minify the code, in the bottom right of the window, in case other programmers want to change the code, fix bugs, add features, etc.  The borderFraction thing wasnt even a bug. When you make it bigger than 1, its not a fraction, and it turns the display inside out, as you see it getting smaller to a point then bigger, like a lightcone. You were looking at the "back side of a polygon" and the background was only on 1 side.

v630
chungfaame â€” Today at 8:52 AM
Attachment file type: archive
usable_corals_07-03-22.zip
1.04 MB
new mixed reefs we made today works very well to make nice reefs fast
just use the rrefs in the folder for examples and finding good reefs is much easier
GeneReefer â€” Today at 9:47 AM
@madscientist can we have a meeting to integrate more bootshapes? also the colors cannot be saved even with the same seed it looks different everytime we somehow have to make it more determinate and or add some more color options.
GeneReefer â€” Today at 9:56 AM
today 9pm your time @madscientist
madscientist â€” Today at 3:09 PM
It seems that every colorseed creates a specific neuralnet, but one neuralnet can do different things depending on small differences like timing or shape. Some neuralnets tend to do about the same thing every (or near every) time. We should find colorseeds which do that.
not sure about 9pm. check if i'm available then
Theres a button to save the current shape to bootShape (but it costs as many points as there currently are). You can also change the bootShape equation (used if you dont save the shape points) by changing it in a json file here
Image
You can also change bootShape on browser console like by typing this then click restart: o.bootShape = oo.bootShape = 'a=>(Math.sin(a*2))' 
a is angle. the code gives a radius
if you type that then save it will have the new bootshape in json and can be loaded again.


v627: this is a variant of the "find that red reef that was cycling thru the colors (wasnt using neuralnet) and put in color options like that. choose what colors it cycles thru" feature request. paintBrightMult and the wrapPaintBrightMult checkbox let you do this. 
firstWrappedPaintBrightMult.json
fluid_growth_-_paint_bright_mult.json


v624: now has line thickness but it doesnt work very well. is made of rectangles so when its curvy they dont cover everything, and it seems to undo some parts. i might fix it later but have other things to do. it works the same if lineThick is 1.


2022-2-21-6pEST Hopefully I'll get the bugs worked out tomorrow and after that start making 10+ reefs/day, then when we have all the reefs, colors, grooves, etc, I'll work on the picture generating code and make the 8888 jsons for cardano and 8888 approx 10kB pics for IPFS

A hill normally repels, but if you set repel to negative it attracts. it can also push in a direction

You can now edit the "hills" (aka acceleration voxels) with 6 numbers each, as in these number choosers and checkboxes. the leftmost number chooser, or the select checkbox, selects one of the hills which the other 6 edit.

You can draw walls to push it into a shape before clicking "use current shape as bootshape" then get rid of the walls

Its saving bootShape and the painted walls. Use the lowest SAVE button for now, until I fix the bug that bootShape isnt used in poolpm. Theres a brushSize slider to choose the paint brush size. Careful to not make stuff too big. Click wall points in 1 at a time instead of dragging. All wall points cost the same byte size (as much as 6 points on a groove, each) nomatter if they're tiny or huge.


*/

//Returns json that can be used in https://pool.pm/test/metadata if you call this on browser console
var exampleNFT = ()=>jsonForNFTNumber1To8888(1);

//about 4200 is the max that will fit, but that varies with version of the builder html and the exact compression varies per reef when maxCompress.
var sizeOfOptions = opt=>packedOptionsStr(opt).length;

//forkEdits to remove something like this: meta: {geneReefId: '5641', startingShape: '10', colorSeed: '56615224228971', species: '236', backgroundColor: '#203725'}
//or if it doesnt have that, returns param.
//Meta is only used during maxcompress generating zip of reefs for cardano jsons, and some of the cardano metadata goes there.
var removeMeta = opt=>{
	if(opt.meta){
		opt = copyMap(opt);
		delete opt.meta;
	}
	return opt;
};

var packedOptionsStr = opt=>allOneLine(removeIndent(betterJsonStringify(lossyCompressOptionsModifyAndReturn(removeMeta(opt)))));

//given 2 options map/{}, returns -1 0 or 1, to sort them first by dir ascending, then break ties by options size descending, then break ties by string compare.
//
//FIXME??? verify did betterJsonStringify fix this? does  keys in {} may happen in different orders
//than for(key in {...}) does it, which could change order of reefs if computed again.
//
var optionsComparator = (optionsA,optionsB)=>{
	if(!optionsA.dir || !optionsB.dir) throw 'No dir';
	if(optionsA.dir < optionsB.dir) return 1; //first compare by dir descending, so the best (dir 4) reefs are rarest, and worst (dir 1) are most common.
	if(optionsA.dir > optionsB.dir) return -1;
	let strA = packedOptionsStr(optionsA);
	let strB = packedOptionsStr(optionsB);
	if(strA.length < strB.length) return -1; //then break ties by descending options string size
	if(strA.length > strB.length) return 1;
	if(strA < strB) return -1; //then break ties by comparing the options strings
	if(strA > strB) return 1;
	return 0;
};

var exampleDataurl = ()=>dataUrlForNFTNumber1To8888(1);

var saveExampleNFT = ()=>saveNFT(1);

var warnIfTooBig = json=>{
	if(json.length > maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt) if(!confirm('WARNING its '+(json.length-maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt)+' bytes too big to fit in a cardano transaction: '+json.length+' (max is '+maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt+') but you can still try it in poolpm. To make it smaller, try using the "only display selected groove" checkbox to select a groove and reduce its number of points, or have less grooves (click 01 to remove a groove), or remove some of its hills/accelVoxels.')) throw 'User cancelled cuz too big';
	return json;
};

//Returns json that can be used in https://pool.pm/test/metadata if you call this on browser console like jsonForNFTNumber1To8888(8888) or jsonForNFTNumber1To8888(1).
var jsonForNFTNumber1To8888 = number1To8888=>{
	verifyGenereefNumber(number1To8888);
	if(number1To8888 != 1) throw 'TODO';
	let json = jsonForCardano(prefixHtml, optionsForNFTNumber1To8888(number1To8888), nonminifiedJavascript, minifiedJavascriptFromUglifyjs, suffixHtml);
	requestAnimationFrame(()=>warnIfTooBig(json));
	return json;
};

var dataUrlForNFTNumber1To8888 = number1To8888=>{
	verifyGenereefNumber(number1To8888);
	if(number1To8888 != 1) throw 'TODO';
	return dataUrlOfGenereef(prefixHtml, optionsForNFTNumber1To8888(number1To8888), nonminifiedJavascript, minifiedJavascriptFromUglifyjs, suffixHtml);
};

var saveNFT = number1To8888=>{
	//let filename = 'testNftNotFinalYet_genereef'+number1To8888+'.json'; //TODO this if using number1To8888 for all the numbers, instead of whats currently displayed.
	let filename = dom('reefName').value+'.cardano.json'; //FIXME
	let json = jsonForNFTNumber1To8888(number1To8888);
	warnIfTooBig(json);
	//TODO verify json has only ascii and %ff escapes everything else.
	saveJson(filename,json);
	console.log('Saved '+filename);
};

var savingString = null;

var selectedSpecies = -1;

var selectedEInSpecies = -1;

//speciesIndex ranges 0 to 299 (or maybe 300 for the "extra" species), but is displayed as 1 plus that.
var onClickSpecies = speciesIndex=>{
	selectedSpecies = speciesIndex;
	displayRaritiesSpecies(); //update which is bold cuz of selectedSpecies
	let lo = speciesIndexToFirstReefIndex(speciesIndex);
	let hi = speciesIndexToLastReefIndex(speciesIndex);
	dom('makeHowManyReefs_start').value = (lo+1);
	dom('makeHowManyReefs_end').value = (hi+1);
	//make clickable text like 'S25E3' for species 25 reef 3 in that species, for whichever species was clicked.
	let numReefs = rarities[speciesIndex];
	let html = '';
	for(let e=0; e<numReefs; e++){
		if(e == selectedEInSpecies) html += '<b><font color=#00ffff>';
		html += ' <a onclick="onClickSE('+speciesIndex+','+e+');">S'+(speciesIndex+1)+'E'+(e+1)+'</a>';
		if(e == selectedEInSpecies) html += '</font></b>';
	}
	dom('se2').innerHTML = dom('se').innerHTML = html.trim(); //one at top of screen and one with the species rarities at bottom.
	
};

//s and e start at 0.
var seToReefIndex = (s,e)=>(speciesIndexToFirstReefIndex(s)+e);

//s and e start at 0. Like S25E3, except each of those numbers minus 1.
//This only works if you've clicked the make zip button which calls afterDraggingInPrototypesMakeAndDownloadZipFileOfReefsOptions
//and creates the S25E3-like clickable text on screen which calls this onClickSE.
var onClickSE = (s,e)=>{
	selectedEInSpecies = e;
	let reefIndex = seToReefIndex(s,e);
	let options = copyOfLast_makingReefs_list ? copyOfLast_makingReefs_list[reefIndex] : null;
	if(options){
		loadReef(options);
		onClickSpecies(s,e); //display what you just clicked as bold, using selectedEInSpecies.
		console.log('loaded reef S'+(s+1)+'E'+(e+1));
	}else{
		if(confirm('Couldnt load reef S'+(s+1)+'E'+(e+1)+'. Try clicking the make zip button first. Auto click it now? Its fastest if you have "save multi reefs as zip" unchecked, and you can cancel after it makes the file (or save it). Then you can use these S E buttons to view a reef in builder. Auto click that now?')){
			onClickButtonToMakeReefZip();
		}
	}
};

//updates 6 number choosers on screen.
//hillIndex ranges 0 to o.accelVoxels.length/6-1. Each hill/accelVoxel is 6 numbers.
//Does nothing if hillIndex is out of range.
var loadHillNums = hillIndex=>{
	if(0 <= hillIndex && hillIndex < o.accelVoxels.length/6){
		dom('hillIndex').value = hillIndex; //FIXME infloop?
		let i = hillIndex*6;
		dom('hillCenterY').value = o.accelVoxels[i];
		dom('hillCenterX').value = o.accelVoxels[i+1];
		dom('hillRadius').value = o.accelVoxels[i+2];
		dom('hillRepelForce').value = o.accelVoxels[i+3];
		dom('hillAccelY').value = o.accelVoxels[i+4];
		dom('hillAccelX').value = o.accelVoxels[i+5];
	}
};

//updates hill in canvas based on 6 number choosers on screen, and 1 of them chooses which hill.
var hillNumInput = ()=>{
	let hillIndex = parseFloat(dom('hillIndex').value);
	if(0 <= hillIndex && hillIndex < o.accelVoxels.length/6){
		let i = hillIndex*6;
		oo.accelVoxels[i] = o.accelVoxels[i] = parseFloat(dom('hillCenterY').value);
		oo.accelVoxels[i+1] = o.accelVoxels[i+1] = parseFloat(dom('hillCenterX').value);
		oo.accelVoxels[i+2] = o.accelVoxels[i+2] = parseFloat(dom('hillRadius').value);
		oo.accelVoxels[i+3] = o.accelVoxels[i+3] = parseFloat(dom('hillRepelForce').value);
		oo.accelVoxels[i+4] = o.accelVoxels[i+4] = parseFloat(dom('hillAccelY').value);
		oo.accelVoxels[i+5] = o.accelVoxels[i+5] = parseFloat(dom('hillAccelX').value);
	}
	putHills(o.accelVoxels); //slow for just changing 1 hill
};



/*

TODO html postmessage to change computeSpeed, for displaying multiple nfts etc that dont slow eachother down.
is the starting of it at computeSpeed 1 crashing things?
if(!o.computeSpeed) o.computeSpeed = .1;

TODO button to download current reef as a json, instead of all of them, and a place to drag in a file (and maybe also a textarea to paste it) of that saved json, so can save and load 1 reef at a time instead of the more confusing way of a bunch of reefs all together including those that were already there. This is how they will give me the reefs they make.



TODO older groove labels remain after clicking restart. they dont move. They were aLoop.domLabel. aLoop.close() was supposed to get rid of those. Was it called?


todo in isSurface mode, the grooves should not be surface.



DONE, I THINK, TODO VERIFY, BUT IT SEEMS TO BE BROKEN IN THE SLIDERS WONT MOVE, EVEN THOUGH THE REEF LOADS AND MOVES.
MAYBE ITS THE event.preventDefault() andOr moving around divs in the html at the bottom of this file I did recently.
..
TODO uncomment this code in restart func that fills loops map, but when I do something breaks and I cant move the sliders anymore and timeSpeed becomes epsilon (.000001).
	loops = {};
	/*for(let option in oo.loops){ //copy from oo.loops (the lists of numbers, each a loop, for some of the options/oo) to loops map of option to Loop object.
		loops[option] = newLoop(option, oo.loops.length, true);
	}




These things need to be in the generated NFT: var builder = false; var options = {...}; then minified code;

Do the following before shrinking it more, cuz we need to get reefs built. Going for having it looking like reefs by end of 2022-1, and leave fitting it into cardano for after that.


FIXME make sure it cant divideby0 or divide by epsilon might be enuf, that when the "record groove" is at 0, its multiplied by the slider, but that multiply might be too near 0. i saw it throw 2022-1-23-5p, might have been that.

TODO add these texts to the title= popup help or a help button etc.[
You can now create "record grooves" for any slider by clicking 8 16 32 64 128 or 256 number of points left of that slider, or click 1 to remove it and just use the 1 number in the slider. If you dont like the random color it chooses, click it again. You edit the record groove shape by clicking or dragging the mouse with left button, on the groove itself. It edits the selected slider, whichever you clicked last changes color to the same color as the groove. The loopSeconds slider chooses how long it takes to turn once, like a song on repeat. I havent made a way to save them yet but will soon. There will only be enough space for a few hundred points, maybe 1000, and it costs a little space per groove plus the space of the points on it. The sliders wont move since the groove multiplies them, and shows the real option value on the groove such as it says "timeSpeed = 1.2822820432645397" which usually differs from what timeSpeed says on the left, cuz its multiplied. The 5 circles displayed show what its multiplied by, -2 -1 0 1 2 and gradually anywheere between or past, but you cant go past the center of the reef (very negative) cuz thats the opposite side of the groove. Play with it and let me know what you think. I'll continue fixing bugs in this editor until you're able to make reefs with it and save them.

The record grooves are hooked into the sliders, but it hasnt been well tested and the ranges need adjusting. Its currently multiplying them by around .8 to 1.2 depending how far from circle center the record groove is. It should range closer to -2 to 2 times it. It scales the sliders by the record groove instead of moving the sliders. You can see the grooves turning and names of 7 sliders moving along them. I'm going to move the grooves past the edge of the border circle so it doesnt interfere with seeing the reef. And put some checkboxes so can choose which options to see grooves for. And make a way to edit the groove shape.
]

TODO use the "mangle eval" option in uglifyjs to make it a few kB smaller but will have to adjust how eval is used.

TODO move these funcs to builder??
Loop.prototype.updateCurve
var paintLoops

IMPORTANT: Add second slider beside each slider, that chooses how much randomly it will move, and have ability to save a recording of such random movements of the sliders, to record 30-500 of sequences of the sliders moving, and to go back and forth thru that recording like the timespeed moving back and forth, and thats how different kinds of reefs will be made. Dont have it move randomly too fast, have it have velocity of moving the sliders.
..
IMPORTANT: also ability to record sliders if move it randomly.
..
Do this as a second kind of time (independent of timeSpeed slider) moves around the border circle like a clock, and for each slider theres a curve, and the bigger its radius (a little past or before the border radius) the bigger a number that option is (slider is smooth, or integer, or checkbox is 0 or 1). timeSpeed will need to be replaced by a specific time cuz otherwise roundoff and computer speed etc will add up and not sum to the same. Select one slider to see its wave. Then edit that wave. Auto adjust timeSpeed to reach the chosen absolute time. To save these, maybe it should be a sum of sine waves of chosen freq and amp (and maybe phase), or maybe it should be a Curve object. But how to edit it? Move a bellcurve range of it? Sine wave of it?
..
need to come up with a UI to make recordings of the sliders changing. Imagine a record turns, just 1 time around, and the grooves in the record move the sliders. 1 groove per slider. You can turn it to a chosen angle and adjust sliders there, but what does that do to the nearby slider positions? Should it change it in near times gradually like a bellcurve? Do you want to choose the frequency and amplitude of a wave or sum of multiple waves per slider? Do you want to draw it with the mouse? We dont have space to store a mouse drawn record groove for alot of sliders. It needs to be a loop so it repeats. Checkboxes could also be in the grooves, being just high or low. How would you like this to work on screen?
..
Do it like in roundControlsB.png.

IMPORTANT, COLOR... TODO Since the neuralnets are random anyways, I could store it as just 16 bits of seed, and you could look thru 65536 random neuralnets generated from that seed and pick from them. Would that be ok? Cuz I'd like to keep that 1kB for storing the neuralnet for other things, and just generate it 65536 repeatably-random ways.

IMPORTANT: find slider positions that are easier to use, that dont make other sliders do nothing nomatter where you move them.

IMPORTANT: Add ability to save position of curve as starting position.



IMPORTANT: write about myself, job title, programmer mathematician artist etc, github url, description of me, cuz the team is getting a webpage about them.

IMPORTANT: daily meetings at 21 EST.



DONE, its 3 bootShape* sliders: IMPORTANT: Slider to change o.bootShape radius.

DONE: IMPORTANT: textarea to give name to reef when click save. Increment number at end of reef name if duplicate name, and dedup existing names.

DONE, CHECKBOX AT TOP LEFT. IMPORTANT: bounding circle display, move that to the builder so not display it in nft and have more space for other stuff.

DONE: IMPORTANT: option in the builder to black out all the buttons sliders etc, for recording videos.



---few days to do the above----
---------------------------------------------------

TODO the time is jumpy, even in the turning of the "record grooves" so its not related to timeSpeed. Might be related to dt.


UPDATE: .5kB of metadata cuz marcus/mako/genereefer says only need 200 bytes of text about it.
	 instead of: 1kB generated metadata, mostly copied from generated options.
seed random color ok he says.
..

TODO figure out what uglifyjs mangle eval does, cuz it reduced it by a few kB but broke the bell func and maybe endist etc.


GeneReefExperiment_285.minified.html is 14.3kB total.


Trying to fit it all in 16kB for cardano. These things need to fit:
* 1kB generated o/options map.
* 10.5kB (but so far is 15kB) minified code after the "AAAA nft maker/builder above" comment.
* 2.5kB base64 of generated thumbnail pic (generated as png from canvas)
* 1kB generated metadata, mostly copied from generated options.
* 1kB neuralnet
* (also a little html)

Renaming FROM TO...
options o


TODO separate the code that goes in NFTs (put below) vs the code that generates them (put above).

TODO funcs to maybe remove:
removed: removePoints
removed: insertPointsIfDistanceAtLeast
removed: autoMoveSliders and this line: autoMoveSliders(physicalDt);
removed: maxDistanceFromCenter //used by autoMoveSliders
removed: Tensor.weightedSum and breedByAverageNeuralnet
removed: trySetSliderBifraction
??? the code in if(options.builder){ ... but put it somewhere cuz still need it in the builder.
??? this code: for(let i=0; i<10; i++){
	nextState();
}

TODO Theres a problem where it runs really slow for 10 seconds with the bootshape (shape it starts as) really small in the middle and min number of points being big. I'll need to fix that. Seems to be fixed when min points is low.
..
TODO I'll add some sliders to change bootshape
..
TODO
I want others on the team to start making reefs using mostly the amp, freq, and bell sliders, then save them with the buttons on the right, and click to download the json (with a few screenshots so I know I'm seeing the same thing you're seeing) and copy the json file here so I can add those buttons to the main html file. Once we get 50 or so interesting reefs, I'll use weightedSums of their slider positions checkboxes etc to generate all 8888 reefs.
I'll continue making it smaller and other technical upgrades needed to put it on cardano. It wont change much from what you see on screen. We are near deployment, making final adjustments.
options.bootShape still needs adjustment and can be done on browser console by typing things like: options.bootShape = 'x=>.4'
If you change options.bootShape then click save, it saves your bootShape changes.


DONE[
	BjoernDo â€” Today at 11:57 AM
	I can't say anything about the points you mentioned .. The others have to answer that. But could you write a guide/ instruction to the sliders? So that I know what the slider is changing?
	madscientist â€” Today at 12:01 PM
	I'll write something about each slider as a tooltip popup when mouse hovers on that slider.
]

TODO If any of the the random-appearing text in that json (from the chess nft) is for a specific a specific cardano account, then it should probably be changed to the genereefs account. Please give me an updated example json.

TODO Other than choosing how to vary the rate of time, including forward and backward to expand/shrink, we mostly have enough sliders to make 8888 interesting reefs. I'll focus on making it fit in 16k with thumbnail, small neuralnet, description, etc, and generate something you can copy/paste into https://pool.pm/test/metadata that makes a reef appear

TODO Please choose the rarities. I'll have the HTML file loop over them and generate 8888 json files.

TODO if have time (not required)[
	We might be able to do evolution of reefs by drag and drop, since the new sliders tend to make interesting patterns even when moved randomly.
	Evolution is just a weighted-sum and some randomness, of the slider numbers of 2 reefs, to generate another reef, in theory.
	aka harmony search  https://en.wikipedia.org/wiki/List_of_metaphor-based_metaheuristics#Harmony_search_(Geem,_Kim_&_Loganathan,_2001)
	List of metaphor-based metaheuristics
	This is a chronologically ordered list of metaphor-based metaheuristics and swarm intelligence algorithms.
	Evolution would take 2 options maps and make another options map.
]

TODO test on mobile again. Test on many combos of computer, OS, mobile vs desktop, browser, etc.

TODO? Is it a problem that the lines with black between them (vs solid color) happens more on slower computers or when its running too much stuff on screen at once? It happens by accident. Could be called a bug or a feature. If its a feature, would be better for it to occur consistently. Could paint more  curves in each display cycle instead of just 1 more. That might slow it down even more, or maybe not.

TODO? Should parts of the reef be draggable with the mouse? Its already a physics sim so that would just be to add velocity to parts of it near the mouse
Should phone tilt sensor slide the reef around?


madscientist â€” Today at 9:32 AM
The maxDistanceToAffectEachother slider, when its 2, covers the whole area, but .15 is a good number cuz its much faster.
Imagine between each 2 points within that distance (and with gradually less influence as they approach that distance or more) has a pole between them, and on that pole is some curves as a straight https://en.wikipedia.org/wiki/Cam
Cam
A cam is a rotating or sliding piece in a mechanical linkage used especially in transforming rotary motion into linear motion. It is often a part of a rotating wheel (e.g. an eccentric wheel) or shaft (e.g. a cylinder with an irregular shape) that strikes a lever at one or more points on its circular path. The cam can be a simple tooth, as is us...

That cam can be shaped any way we want, such as a sum of sine waves, bellcurves, tanh/sigmoid curves, etc.
If you want to suggest some curves, you can graph them on https://www.wolframalpha.com/ then give me the equation, or just put them into the endist function yourself using browser console. to see the existing curve, type ''+endist on browser console
Wolfram|Alpha: Making the worldâ€™s knowledge computable
Wolfram|Alpha brings expert-level knowledge and capabilities to the broadest possible range of peopleâ€”spanning all professions and education levels.

We could also make there be some areas of the screen it is attracted or repelled from.
wolframalpha is how I made some parts of the curve
There are about  30,000 such cams, all shaped the same.
That describes dist, but theres also pdist (perimeter distance, along the curve).


TODO?[
Do you want a heightmap that attracts the reef to the valleys and repels from the hills? We're already have code to do any energy function we want based on position and distances. For example, I can generate these in just a few lines of code. Its a 1-300 dimensional hypercube, displaying only the corners, and each corner is black or white, the opposite color of all adjacent corners. Holding a keyboard button while moving the mouse moves 1 of those dimensions, like an arrow from screen center in some direction/length. By adding all possible sets of arrows (include some but not others), it arrives at a point on the screen, and draw the white or black corner there. It doesnt matter what order its done since its very symmetric. It takes only as many image copying onto itself negated, as there are dimensions. https://github.com/benrayfield/hypercubewave
 could use that as a heightmap andOr background pic, for just a few lines of code. or a fractal
After painting that, the absolute value (flip if negative) is used, so gray is black, and black and white are both white.
]

DONE borderFraction isnt just display. it varies the sizes of things inside it differently than the size of the circle. fixed.
*/

var loadLastSavedOptions = true;
//var loadLastSavedOptions = false;


/*
var options =
{

	nearPdist: .07,
	//nearMul: .8, //should be range .5 to 1
	//farMul: 1.7, //should be range 1 to 5
	//mdErrSqMul: 520, //should be 0 to 10000

	//TODO remove dpOuterMul and dpInnerMul

	friction: .01,
	
	//circPotEnOuterMul: 10, //circPotEnOuterMul and circPotEnInnerMul are about attracting to center
	//circPotEnOuterMul: .001,
	
	//circPotEnInnerMul: 10, //circPotEnOuterMul and circPotEnInnerMul are about attracting to center
	//circPotEnInnerMul: 2.3511760354999027,
	
	timeSpeed: 0.39140247782373483,
	
	
	//maxNumPointsPerCurveChangeAtOnce: 1,
	maxNumPointsPerCurveChangeAtOnce: 10,
	//maxNumPointsPerCurveChangeAtOnce: 0, //FIXME should be 1
	borderFraction: 0.18804046556768364, //circle that its supposed to stay in is 1-borderFraction of min(width,height) diameter.
	//forceMaxResolution: true,
	//stretchToWindow: true,
	maxSpeed: .5,
	
	//targetDistanceBetweenAdjacentCurvePoints is used with balanceSparsity, not with linearInterpolateSparsity.
	//It chooses how many points to create when the curve changes perimeter/length.
	//It may be what makes it shake a little since the number of points has to be an integer
	//but the perimeter does not.
	targetDistanceBetweenAdjacentCurvePoints: 0.01427363757171138, //coordinates are in circle of radius 1 (may go slightly outside)
	
	//cuz coordinats are circle of radius 1 and
	//sometimes a little outside it see options.borderFraction minX maxX minY maxY.
	//This gets multiplied by timeSpeed, but TODO maybe timeSpeed also does other things,
	//and timeSpeed should normally be 1.
	maxCurvesPerReef: 50,
	scalePotentialEnergyForce: .0005,
	maxDistanceToAffectEachother: 3, //in circle of radius 1 and sometimes goes a little outside it
	addRandomness: .04,
	//stayInsideBorderCircleForce: .1,
	stayInsideBorderCircleForce: 111111111, //FIXME why does this need to be so big? different scale of force than other accel vars?
	//attractToSmallerCircle: 444,
	//smallerCircleRadius: .5,
	//smallerCircleThick: .07, //approx radius smallerCircleRadius plus/minus smallerCircleThick, but smoothly (todo bellcurve? tanh? etc?)
	//attractToSmallerCircleExponent: .5,
	distanceScale: 1200,
	//throwAfterPaintLineLongerThanThis: 40,
	//dontCrossSelf: 4.5,
	pause: false,
	//canvasElseSvg: true,
	isSurface: false,
	displayOuterCircle: true,
	isOnlyMoveRandomlyPerpendicularToSurface: true,
	//adjust_targetDistanceBetweenAdjacentCurvePoints_byFramesPerSecond: false,
	//adjust_numPoints_byFramesPerSecond: false,
	ifCanvasUseUndoGraphics: true,
	negTimeDoesUndo: true, //else just moves backward on gradient of potentialEnergyFunc.
	autoMoveTimeSpeedSlider: false,
	//physicsCyclesPerDisplay: 10,
	//pushTowardRadialAngles: 1000, //reduces potentialEnergy when 1d curve surface is tangent to line from center outward toward that point.
	//pushTowardRadialAnglesFracExpon: 2, //the higher this is, the more it prefers very near radial angles as in pushTowardRadialAngles
	//repelSelf: 300,
	//repelSelfDistance: 20,
	//repelSelfExponent: 2,
	
	
	//only used in balanceSparsity and to create the first curve.
	//linearInterpolateSparsity chooses number of points by their distances etc.
	balanceSparsity: true,
	minPointsPerCurve: 20,
	maxPointsPerCurve: 800,
	
	linearInterpolateSparsity: false,
	minDistanceToInsertPoint: .06, //set this to 1000000 or higher to not use it, which it would have no effect then anyways since coordiantes are mostly in a circle of radius 1 and goes outside that a little
	maxDistanceToRemovePoint: .01,
	
	
	onlyEndist: false,
	setSpeedsToZeroAfterEveryDtMove: false,
	bootShape: 'angle=>.06',
	//bootShape: 'angle=>(.3+.07*sin(angle*7)+.1*sin(angle*5)+.08*sin(angle*11))',
	endist: '(en,dist,pdist)=>en', //js code. dist is 2d distance. pdist is distance along perimeter of 1d curve.
}
;
*/


var o = {}; //options


var optionsRemoved = ['isOnlyMoveRandomlyPerpendicularToSurface','maxDistanceToRemovePoint'];

//TODO bootShape:"a=>[2+Math.sin(a*5),a*a]" and other 



//to compress the options part of this, run this in browser console: lossyCompressOptionsStr(oo)
var savedWrappedOptions = [{"timeSaved":1643652271.3149,"options":{brightAddRed:20, brightAddGreen:20, brightAddBlue:50, brightMult:90, brightMultRed:1.01, brightMultGreen:1.01, paintBrightAdd:3, sameColorness:.01, brightMultBlue:1.01, accelVoxels:[],accelFieldMul:89415464119,loops:{timePosition:[0.184,0.132,0.127,0.363,0.473,0.532,0.639,0.753,0.913,0.877,0.738,0.46,0.317,0.383,0.555,0.802,1.072,1.305,1.083,0.914,1.286,1.543,1.066,0.957,1.389,1.342,1.115,0.882,0.598,0.368,0.349,0.159]},bootShapeY:0.01,bootShapeX:0.01,bootShapeScale:1,bootShape:"a=>.2",nearPdist:0.046,friction:0,loopSeconds:30,useTimePosition:true,timePosition:11.073,timePositionDecay:0.29,timeSpeed:0.831,minPointsPerCurve:137,maxPointsPerCurve:700,maxNumPointsPerCurveChangeAtOnce:398,borderFraction:0.663,borderRadiusMul:1.0001,maxSpeed:0.2,targetDistanceBetweenAdjacentCurvePoints:0.012,maxCurvesPerReef:10000,scalePotentialEnergyForce:2.104,ampStraightIfNear:334008857.205,maxDistanceToAffectEachother:0.108,addRandomness:176957.849,stayInsideBorderCircleForce:5361433391626.719,distanceScale:0.023,pause:false,attractIfFartherThan:0.4,ampAttractIfFartherThan:1144,graphEndist:true,graphEndistBright:"Math.sqrt",isSurface:false,displayOuterCircle:true,ifCanvasUseUndoGraphics:true,negTimeDoesUndo:true,autoMoveTimeSpeedSlider:false,balanceSparsity:true,onlyEndist:false,setSpeedsToZeroAfterEveryDtMove:false,freqA:76.709,ampA:339667.758,freqB:-2.88,ampB:202533.369,freqC:9.911,ampC:-781559.342,midDist:0.057,bellAAveMul:0.416,bellADevMul:0.214,bellAHeight:12202510.249,bellBAveMul:0.904,bellBDevMul:0.474,bellBHeight:1412927.023,bellCAveMul:7.343,bellCDevMul:18.857,bellCHeight:-11199.086,forceMaxResolution:true,stretchToWindow:true,canvasElseSvg:true,isEraseCanvasEachFrame:true,repelSelf:49280.617,repelSelfDistance:40.162,computeSpeed:1.291,colorSeed:8400328863760,endist:"(en,dist,pdist)=>{\n\tlet x = 0;\n\tlet p = o;\n\tlet nd = p.nearPdist;\n\tlet near = sigmoid(-5*(dist-nd));\n\tif(dist > o.attractIfFartherThan) x += o.ampAttractIfFartherThan*sqr(dist-o.attractIfFartherThan);\n\tx += o.ampStraightIfNear*near*sqr(dist-pdist);\n    let midDist = p.midDist;\n    x += bell(midDist*p.bellAAveMul,midDist*p.bellADevMul,p.bellAHeight,dist);\n    x += bell(midDist*p.bellBAveMul,midDist*p.bellBDevMul,p.bellBHeight,dist);\n    x += bell(midDist*p.bellCAveMul,midDist*p.bellCDevMul,p.bellCHeight,dist);\n\t\n\tlet m=dist*twoPi;\n\tx += sin(m*p.freqA)*p.ampA;\n    x += sin(m*p.freqB)*p.ampB;\n    x += sin(m*p.freqC)*p.ampC;\n    //if(dist > midDist) x += Math.pow(dist-midDist,1.3)*100;\n\tx += en; return x;\n}",name:"tryMakeNormalReef106",colorDecayPerSec:3,lineThick:1,paintBrightMult:.999,wrapPaintBrightMult:true}}];




//pop up a tooltip when mouse hovers on a slider etc for that option.
//TODO some of this writing is too long for the popup when hover mouse over an option, so put it somewhere else.
var explainOption = optionName=>{
	//'heloo'.match(/^hel+o+$/)
	let s = '';
	if(optionName.match(/^bell.*AveMul$/)){
		s += 'Scaled by midDist, the distance between 2 points of a bellcurve where they are attracted/repelled.';
	}
	if(optionName.match(/^bell.*DevMul$/)){
		s += 'Scaled by midDist, the distance between 2 points of a bellcurve where they are attracted/repelled.';
	}
	if(optionName.match(/^bootShape/)){
		s += '2 kinds of bootShape funcs: a=>.2 or like a=>[2+Math.sin(a*5),a*a] or a=>{a*=2/Math.PI; if(a<1) return [a%1-.5,-.5]; if(a<2) return [a%1-.5,.5]; if(a<3) return [-.5,a%1-.5]; return [.5,a%1-.5];} Reef starts as a bent circle centered at (o.bootShapeY,o.bootShapeX) and radius is o.bootShapeScale*eval(o.bootShape)(angle) for each possible angle from 0 to 2*Math.PI. Or returns [y,x].';
	}
	if(optionName == 'borderRadiusMul') s += 'This is range 0 to 2, if the radius was 1 before. If its more than 2, then it goes outside of the accelVoxels array and maybe the canvas. The circle border radius, which is normally 1, is multiplied by this so the reef has more or less space to grow without hitting the border. If stayInsideBorderCircleForce is too low, it will go past the border anyways, but if its too high, physics will be jumpy at the border. You also need to consider scalePotentialEnergyForce, which some things are multiplied by and others arent. borderFraction would normally be adjusted at the same time as this borderRadiusMul, even though it doesnt affect physics, it affects display size. TODO some of this writing is too long for the popup when hover mouse over an option, so put it somewhere else.';
	if(optionName == 'sameColorness') s += 'Mixes between neuralnet (when near 0) and solid color (when near 1), of color of curvy paintbrush. Uncheck wrapPaintBrightMult if it looks confusing.';
	if(optionName == 'brightAddRed' || optionName == 'brightAddGreen' || optionName == 'brightAddBlue') s += 'for background color.';
	if(optionName == 'brightMultRed' || optionName == 'brightMultGreen' || optionName == 'brightMultBlue' || optionName == 'paintBrightMult') s += 'While sameColorness is bigger (such as 1 instead of .001) these affect color of curvy paintbrush like contrast on a tv screen. While sameColorness is near 0 they filter what color the neuralnet makes. Further multiplied by paintBrightMult. Uncheck wrapPaintBrightMult if it looks confusing.';
	if(optionName == 'paintBrightAdd') s += 'Like brightMultRed *Green and *Blue are like contrast on a tv, this is like brightness.';
		
	if(optionName == 'midDist') s += 'The bellcurves (such as the bellCAveMul and bellCDevMul and bellCHeight sliders) that control the shape of the https://en.wikipedia.org/wiki/Cam like poles between pairs of points on the curves, see the *Mul sliders scaled by this, so changes how far apart the points can be to be affected by these bellcurves. The purpose of those bellcurves is to stop the curve from crossing itself, to repel itself if its not very near, or you could also use them similar to gravity for far away and weaker influence but theres another part of endist function for that: x += 1144*sqr(dist-attractIfFartherThan)';
	if(optionName.match(/^amp/)){
		s += 'Sine wave height/amplitude in the pole cams, not in time but in distance between every near 2 points on the curve. Similar to the bellcurves in the cams.';
	}
	if(optionName.match(/^freq/)){
		s += 'Sine wave frequency, not in time but in distance between every near 2 points on the curve. Similar to the bellcurves in the cams.';
	}
	if(optionName == 'paintBrightMult') s += 'The brightness chosen by neuralnet is multiplied by this. Use it with grooves and the wrapPaintBrightMult checkbox.';
	if(optionName == 'wrapPaintBrightMult') s += 'If true then when paintBrightMult makes it too bright it becomes dark and keeps getting brighter, wrapping around, or similarly wrapping negative. If false, too dark stays min bright, and too bright stays max bright.';
	if(optionName.match(/^(bell|amp|freq|maxDistanceToAffectEachother)/)){
		s += ' Theres multiple bellcurves A B C and sine waves summed into the straight https://en.wikipedia.org/wiki/Cam like pole that causes attract/repel between each 2 points based on their 2d distance (dist) and distance along the curve (pdist). You see the dist and pdist params in the endist function which you can see by typing endist in browser console. There are about 30,000 such cams when .15 (more when 2), all shaped the same. The maxDistanceToAffectEachother slider, when its 2, covers the whole area, but .15 is a good number cuz its much faster. maxDistanceToAffectEachother gradually flattens the pole cam when approaching that distance.';
	}
	if(optionName == 'graphEndist') s += 'If you move the freq, ave, bell, and maxDistanceToAffectEachother sliders, you will see endist change. Try typing things like this on browser console: endist = (en,dist,pdist)=>Math.sin(dist*191)-Math.sin(pdist*131)+dist*pdist*500; //and adjust the maxDistanceToAffectEachother slider';
	if(optionName == 'friction'){
		s += 'Speed of each point on the curve is reduced this fast, but not slower than 0 speed. Friction is positive to slow down, negative to speed up. Negative friction tends to lead to sharp edges and unstable shapes that expand without limit, so be careful.';
	}
	if(optionName == 'nearPdist'){
		s += 'The small distance where dist (2d distance) and pdist (distance on the perimeter/curve) are held to be near equal to keep the curve smooth instead of jagged. Increasing this makes it curve less. It should be between .001 and .2 .';
	}
	if(optionName == 'onlyEndist'){
		s += 'If checked, ignores some of the sliders and checkboxes that were made earlier, and only uses the endist function. When checked, this helps to isolate newer experiments using the endist function (type endist on browser console and can change it) from earlier experiments. For example, stayInsideBorderCircleForce has no effect if onlyEndist. Some of that earlier code is still being removed (TODO).';
	}
	if(optionName == 'balanceSparsity' || optionName == 'targetDistanceBetweenAdjacentCurvePoints'){
		s += 'Keep adjacent points about targetDistanceBetweenAdjacentCurvePoints distance from eachother by measuring the distance around the curve and spreading them evenly.';
	}
	if(optionName == 'linearInterpolateSparsity'){
		s += '(this is being removed 2022-1-17) Let the distance between points vary between approx maxDistanceToRemovePoint (smallest) and minDistanceToInsertPoint (biggest). Add a point between any 2 points too far apart, and remove a point thats too close to either of the adjacent (or some similar math of both distances? TODO whats the exact math of that?) 2 points on the curve.';
	}
	if(optionName.match(/^(balanceSparsity|linearInterpolateSparsity)$/)){
		s += ' The curve can change perimeter/length. You should not use balanceSparsity and linearInterpolateSparsity at the same time. If you use neither, the number of points on the curve is constant.';
	}
	if(optionName == 'addRandomness'){
		s += 'StandardDeviation of a bellcurve of random velocity to add to each point on the curve per squareRoot(time) as in the central limit theorem of statistics.';
	}
	//if(optionName.match(/^(min|max)DistanceTo(Remove|Insert)Point$/)){
	//	s += 'Only does something if linearInterpolateSparsity. When to add points between 2 points that are far enuf apart, or remove when too close.';
	//}
	if(optionName == 'loopSeconds'){
		s += 'A second kind of time, where a circular cam like record grooves, which move the sliders and checkboxes, turns once per this many seconds. If negative, it turns backward.';
	}
	if(optionName.match(/timeSpeed|negTimeDoesUndo/)) s += 'How fast time moves forward or backward. If negTimeDoesUndo (checkbox) then negative timeSpeed rewinds recorded video back to when it started but not before. If thats unchecked, then negative timeSpeed runs the physics sim backward (time symmetry) but will soon differ from what was recorded cuz the simulation is not perfect and cuz of the chosen amoutn of friction and the amount of addRandomness. The video is made of voxels, stored in a number each, as part of the ByteRect code. They xor the 24 bits of red green and blue at an x and y position in canvas. Since its xor, they undo or redo by painting them again, so to run the video backward, you just paint them in reverse order. Each Curve object has these in Curve.undoableVoxels list of numbers, which is a cache of the curve shape.';
	//if(optionName == 'autoMoveTimeSpeedSlider') s += 'An experiment where the timeSpeed slider moves on its own, to look like the expanding and shrinking of the earlier p5js version of the reefs. You should probably raise maxSpeed so it moves more, if you use this.';
	if(optionName == 'isSurface') s += 'Use the 1d loop as a curvy paintbrush (looks 3d but is not), or just display the loop.';
	if(optionName == 'maxSpeed') s += 'Limit max speed of each point on the curve so it doesnt get too jumpy, have sharp corners, cross itself and get tangled, or you might want it to grow slower for artistic reasons.';
	if(optionName == 'borderFraction') s += 'Should be between 0 and 1, usually close to 0. (TODO verify that range, cuz other ranges are allowed and it will just display strange). It changes the size of the circle which the reef tends to stay inside (is pushed by stayInsideBorderCircleForce but can still escape the circle if theres enough force from other things). This circle is displayed or not depending on displayOuterCircle';
	if(optionName == 'displayOuterCircle') s += 'Can only do this in reef builder, else is ignored. Display the circle described in borderFraction, or not. It exists either way.';
	if(optionName == 'pause') s += 'Same as timeSpeed of 0 (which you cant move any slider to 0 it breaks), but is faster since it just skips physics and color calculations.';
	if(optionName.startsWith('brightAdd')) s += 'background color. can only see it change while NOT isSurface or after RESTART.';
	if(optionName == 'brightMult') s += 'hills/accelVoxels brightness. You can only see it change while NOT isSurface or after RESTART.';
	if(optionName == 'isOnlyMoveRandomlyPerpendicularToSurface' || optionName == 'addRandomness') s += ' If isOnlyMoveRandomlyPerpendicularToSurface checkbox, then addRandomness only moves perpendicular to the curved surface, instead of any 2d direction, so it tends to stay nearly the same length before and after the randomness. I think https://github.com/inconvergent/differential-line also does that or something similar, see the fairing of brownian motion in Organic Labyrinths and Mazes paper.';
	if(optionName == 'ifCanvasUseUndoGraphics') s += 'Leave this always checked. TODO should probably remove this cuz negTimeDoesUndo replaced it.';
	if(optionName == 'maxCurvesPerReef') s += 'The video described in timeSpeed, this is the max number of video frames (pictures) long it can be b3efore it starts dropping the older ones. The number of video frames shrinks when timeSpeed is negative but only down to the oldest few. This should not be higher than 10000 since the browser could run out of memory. If its too small, you wont be able to rewind time past that. The video only stores the changed pixels and is lossless-compression. No video player other than ByteRect plays these videos, which are a list of float64/double numbers, and theres no automatic changing it to other kinds of video file. Its just for use temporarily in ByteRect canvas graphics, and it could with small upgrade stream video to people across the internet as long as very few pixels change at a time which is true of reefs.'
	if(optionName == 'distanceScale') s += 'When onlyEndist is off/unchecked, some of the older sliders (that are being removed, it might not even be working anymore?) were affected by this by scaling distance by this before they do other things. Just leave this around 1 and forget about it (TODO its not near 1 in alot of reefs).';
	if(optionName == 'scalePotentialEnergyForce') s += 'When onlyEndist is off/unchecked, this is similar to timeSpeed except it doesnt affect the speed of colors changing. TODO This is likely to be removed soon.';
	if(optionName == 'setSpeedsToZeroAfterEveryDtMove') s += 'This makes reefs move based only on position, instead of position and velocity. It was an experiment to make them more stable, cuz at the time they kept getting tangled, but thats solved now, so should probably leave this off/unchecked. If you use this, turn timeSpeed and maxSpeed up really high cuz it cant accumulate velocity so would otherwise move very slow.';
	if(optionName.match(/^(min|max)PointsPerCurve$/)) s += 'Only does something if balanceSparsity checkbox. Regardless of targetDistanceBetweenAdjacentCurvePoints, keeps the number of points on the curve in this range, so parts of the curve far away from eachother pull on eachother to remove curvy branches when its already as long as it can get, or if its too small it will push outward getting curvier. You can adjust the curvyness this way in some cases, but mostly its to make it run fast by not having too many points, and to make it have enough points that it doesnt look like a chain of straight lines and compute physics not as well on such a chain. If min is bigger than max, the number of points is the min.';
	if(optionName == 'clearCanvas') s += 'Erase whatever the curve painted. If isSurface is off/unchecked, this happens every video frame (many times per second). Sometimes when playing with the sliders and checkboxes or resizing the browser, things from earlier combos of that remain, so you can clear that if you want. WARNING: If you clear it, that does not erase the earlier parts of video, so if you rewind past the clear time, it will paint in xor-graphics.';
	if(optionName == 'restart') s += 'Run the reef, with the sliders and checkboxes as they are, as a new reef from the start, except as of 2022-1-11 you get a new random neuralnet that makes the colors each time (TODO save that neuralnet with a precision of 1 byte per weight instead of 1 float, to save space and fit it into the allowed 16kB total).';
	if(optionName == 'setAllSpeedsTo0') s += 'Set the speed of each point on the curve to 0, in case it starts moving too fast, gets tangled, goes outside the bounding circle its supposed to stay mostly inside, etc.';
	if(typeof(o[optionName])=='number' || optionName == '>>') s += ' No option is allowed to be 0 (careful not to move the slider to exact center, TODO auto prevent that) since that breaks the sliders. You can use the >> button to make a slider value very small or very big, past its current range. You might need to use >> a few times to make something thousands of times bigger or smaller.';
	s = optionName+': '+s+' (You can change this text in the explainOption function)';
	return s.trim();
};


//can be empty. copy options maps here, inside another map so can put other metadata such as maybe a screenshot from canvas,
//to save and load reefs when click buttons. todo save in webstorage/cookie and less often copy/paste this into the main html file
//since webstorage/cookie is temporary storage.
//
//if [...] is not empty, it was copied from json from "Download reefs (cuz cookies are temporary)" button,
//that saves in browsers downloads dir.
//



//var savedWrappedOptions = [{"timeSaved":1641309242.6312,"options":{"nearPdist":0.03793815004917514,"friction":0.00014589646991245935,"loopSeconds":30,"timeSpeed":0.5557759567054562,"minPointsPerCurve":20,"maxPointsPerCurve":700,"maxNumPointsPerCurveChangeAtOnce":20,"borderFraction":0.18804046556768364,"maxSpeed":0.12551248389036038,"targetDistanceBetweenAdjacentCurvePoints":0.06049736213617159,"maxCurvesPerReef":10000,"scalePotentialEnergyForce":314.259276326499,"maxDistanceToAffectEachother":0.17028043364398376,"addRandomness":17692.226773769515,"stayInsideBorderCircleForce":34187599.622608334,"distanceScale":0.023617218953926614,"pause":false,"isSurface":false,"displayOuterCircle":true,"isOnlyMoveRandomlyPerpendicularToSurface":true,"ifCanvasUseUndoGraphics":true,"negTimeDoesUndo":true,"autoMoveTimeSpeedSlider":false,"balanceSparsity":true,"minDistanceToInsertPoint":0.010664523535001256,"maxDistanceToRemovePoint":0.003289959052145843,"onlyEndist":true,"setSpeedsToZeroAfterEveryDtMove":false,"bootShape":"angle=>.06","endist":"(en,dist,pdist)=>{\n\tlet x = 0;\n\tlet p = o;\n	let nd = p.nearPdist;\n\tlet near = sigmoid(-5*(dist-nd));\n\tlet attractIfFartherThan = .4;\n\tif(dist > attractIfFartherThan) x += 1144*sqr(dist-attractIfFartherThan);\n\tx += 1421*near*sqr(dist-pdist);\n    let midDist = p.midDist;\n    x += bell(midDist*p.bellAAveMul,midDist*p.bellADevMul,p.bellAHeight,dist);\n    x += bell(midDist*p.bellBAveMul,midDist*p.bellBDevMul,p.bellBHeight,dist);\n    x += bell(midDist*p.bellCAveMul,midDist*p.bellCDevMul,p.bellCHeight,dist);\n	\n	let m=dist*twoPi;\n	x += sin(m*p.freqA)*p.ampA;\n    x += sin(m*p.freqB)*p.ampB;\n    x += sin(m*p.freqC)*p.ampC;\n    //if(dist > midDist) x += Math.pow(dist-midDist,1.3)*100;\n\tx += en; return x;\n}", "freqA":7.95, "ampA":10, "freqB":5.88, "ampB":10, "freqC":4.61, "ampC":10,"midDist":.05,"bellAAveMul":1,"bellADevMul":.4,"bellAHeight":-6,"bellBAveMul":2,"bellBDevMul":1,"bellBHeight":-16,"bellCAveMul":3,"bellCDevMul":1.8,"bellCHeight":-6,}}];

if(loadLastSavedOptions && savedWrappedOptions.length > 0){
	o = JSON.parse(JSON.stringify(savedWrappedOptions[savedWrappedOptions.length-1])).options;
};

/*
var primes = [2];
while(primes.length < 64){
	for(let i=0; i<primes.length; i++){
		if(isDivisibl
	}
}*/

/*
//seed and index are both ints. returns a double 0 (inclusive) to 1 (exclusive), with 32 bits of precision.
var repeatableRandom = (seed,index)=>{
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174
	let a = 
};*/



//make sure to have at least 1 reef left in savedWrappedOptions or it breaks.
var deleteReefsInCookie = ()=>{
	window.localStorage.setItem('savedWrappedOptions', '');
	displayAllWrappedOptions();
};

var saveOptsCookie = function(){
	window.localStorage.setItem('savedWrappedOptions', JSON.stringify(savedWrappedOptions)); //save savedWrappedOptions in cookie
};

//xyz99 -> xyz100. xyz -> xyz2.
var incrementName = name=>{
	if(name == '') return '1';
	let lastChar = name[name.length-1];
	if(!'0123456789'.includes(lastChar)) return name+'1';
	if(lastChar == '9') return incrementName(name.substring(0,name.length-1))+'0';
	return name.substring(0,name.length-1)+(parseInt(lastChar)+1);
};

var displayedReefToJson = ()=>{
	//TODO merge code between displayedReefToJson and saveWrappedOptions
	let reefNameDom = dom('reefName');
	let now = Now();
	oo.endist = ''+endist; //endist is a function
	let name = 'R'+now;
	if(reefNameDom && reefNameDom.value.trim()) name = reefNameDom.value.trim(); //FIXME what if theres duplicates?
	oo.name = name;
	//return JSON.stringify({
	return packedOptionsStr({ //so its same order of keys in {} every time
		timeSaved: now,
		options: lossyCompressOptions(copyMap(oo)),
	});
};

var mapKeys = m=>{
	let keys = [];
	for(let k in m) keys.push(k);
	keys.sort();
	return keys;
};

var saveWrappedOptions = function(){
	let reefNameDom = dom('reefName');
	let now = Now();
	let name = 'R'+now;
	if(reefNameDom && reefNameDom.value.trim()) name = reefNameDom.value.trim(); //FIXME what if theres duplicates?
	let foundDup = false;
	do{
		foundDup = false;
		for(let i=0; i<savedWrappedOptions.length; i++){
			if(savedWrappedOptions[i].options.name == name) foundDup = true;
		}
		if(foundDup) name = incrementName(name); //TODO increase a number on it, instead of appending which will get long much faster
		reefNameDom.value = name;
	}while(foundDup);
	oo.endist = ''+endist; //endist is a function
	oo.name = name;
	let wrappedOptions = {
		timeSaved: now,
		options: copyMap(oo),
	};
	savedWrappedOptions.push(wrappedOptions);
	displayAllWrappedOptions();
	saveOptsCookie();
};

/*
var takeScreenshotDataUrl = ()=>{
	if(!canv || !canv.dom) throw 'no canvas yet';
	canv.beforePaint();
	return canv.dom.toDataURL('image/jpeg',1);
};*/

//WARNING: 0 or null in any option that has a default value, is viewed as not having a value at all so is replaced by default.
var putInDefaults = map=>{
	if(!map.maxSpeed) throw 'Is not a reef options map: '+JSON.stringify(map);
	if(!map.name) map.name = 'R'+map.timeSaved;
	if(!map.accelFieldMul) map.accelFieldMul = 1;
	if(!map.accelVoxels) map.accelVoxels = [];
	if(!map.brightAddRed) map.brightAddRed = 20;
	if(!map.brightAddGreen) map.brightAddGreen = 20;
	if(!map.brightAddBlue) map.brightAddBlue = 20;
	if(!map.paintBrightAdd) map.paintBrightAdd = 3;
	if(!map.brightMult) map.brightMult = 90;
	if(!map.lineThick) map.lineThick = 1;
	if(!map.paintBrightMult) map.paintBrightMult = .999; //its mostly for varying it in a grmapve
	if(!map.brightMultRed) map.brightMultRed = 1.01;
	if(!map.brightMultGreen) map.brightMultGreen = 1.01;
	if(!map.brightMultBlue) map.brightMultBlue = 1.01;
	if(!map.sameColorness) map.sameColorness = .01;
	if(!map.graphEndistBright) map.graphEndistBright = 'Math.sqrt';
	if(!map.dir) map.dir = '1'; //1 is worst/mostCommon. 4 is best/rarest.
	if(map.paintBrightMult === undefined) map.wrapPaintBrightMult = true;
	if(!map.bootShape) map.bootShape = 'a=>.2';
	if(!map.borderRadiusMul) map.borderRadiusMul = 1.0001;
};

var loadWrappedOptions = function(wrappedOptions){
	//FIXME set o.pause and do this on a delay first?
	let prevOptions = oo;
	oo = copyMap(wrappedOptions.options);
	putInDefaults(oo);
	for(key in prevOptions) if(oo[key] === undefined) oo[key] = prevOptions[key]; //for when new keys are added but you have saved reefs
	if(!oo.endist) oo.endist = '(en,dist,pdist)=>en';
	endist = eval(oo.endist);
	updateSliders();
	restart();
	dom('reefName').value = oo.name || '';
	dom('reefDir').value = oo.dir;
};

var deleteWrappedOptionsI = function(i){
	savedWrappedOptions.splice(i,1);
	displayAllWrappedOptions();
	saveOptsCookie();
};

/*var displayWrappedOptions = function(wrappedOptions){
	throw 'TODO';
};*/

var saveFile = (filename,uint8arrayOrString,contentType)=>{
	//FIXME does saveTextFile work for binary files?
	saveTextFile(filename,uint8arrayOrString,contentType);
	//var blob = new Blob([uint8arrayOrString], {type: contentType});
};

var saveTextFile = (filename,textContent,contentType)=>{
	var blob = new Blob([textContent], {type: contentType});
	if(window.navigator.msSaveOrOpenBlob){
		window.navigator.msSaveBlob(blob, filename);
	}else{
		var elem = window.document.createElement('a');
		elem.href = window.URL.createObjectURL(blob);
		elem.download = filename;
		document.body.appendChild(elem);
		elem.click();
		document.body.removeChild(elem);
	}
};

var saveHtml = (filename,html)=>{
	saveTextFile(filename, html, 'text/html');
};

var saveJson = (filename,json)=>{
	saveTextFile(filename, json, 'application/json');
};

var cookieControls = false;

var displayAllWrappedOptions = function(){
	putInDefaults(oo); //in case it doesnt have oo.dir etc.

	//console.log('displayAllWrappedo..');
	let html = '';
	let reefNameDom = dom('reefName');
	let prevReefName = (reefNameDom && reefNameDom.value.trim()) ? reefNameDom.value.trim() : ('R'+Now());
	html += 'Reef name: <input type=text id=reefName value="'+escape(prevReefName)+'"></input>'; //FIXME is that the right kind of escape to not break html if you type escapes?
	html += '<input type=button id=reefNameClear value="X" onclick="dom(\'reefName\').value=\'\';" placeholder="Reef name"></input></nobr><br>';
	
	html += '<nobr>Dir, such as 1 (worst) 2 3 or 4 (best): <input type=text id=reefDir value="'+escape(oo.dir)+'" oninput="oo.dir = this.value;"></input></nobr><br>'; //FIXME is that the right kind of escape to not break html if you type escapes?
	
	html += '<input type=button onclick="saveJson(dom(\'reefName\').value+\'.json\',displayedReefToJson());" value="SAVE displayed reef to file. Later drag that file to screen to OPEN."></input><br>';
	//html += 'FIXME you need to drag the file in twice to load it (fix in onDragJson?)';
	
	if(cookieControls){
		html += 'Or use these...<br><br>';
		if(savedWrappedOptions.length) html += savedWrappedOptions.length+' reefs (click to load)... <br>';
		html += '<nobr><input type=button onclick="saveWrappedOptions();" value="Save Reef to cookie"></input><br>';
		//html += '<input type=button onclick="saveJson(\'reefsOptions\'+Now()+\'.json\',JSON.stringify(savedWrappedOptions));" value="Download reefs (cuz cookies are temporary)"></input><br>';
		html += '<input type=button onclick="saveJson(\'reefsOptions\'+Now()+\'.json\',packedOptionsStr(savedWrappedOptions));" value="Download reefs (cuz cookies are temporary)"></input><br>';
		//html += 'Click DL to save reef as json, X to delete it.<br>';
		for(let i=0; i<savedWrappedOptions.length; i++){
			let screenshotDataUrl = savedWrappedOptions[i].screenshotDataUrl;
			//html += '<nobr><img src="'+screenshotDataUrl+'" width=100 height=100><input type=button onclick="loadWrappedOptions(savedWrappedOptions["'+i+'"]);"></input></nobr> ';
			let name = savedWrappedOptions[i].options.name || ('Reef_'+savedWrappedOptions[i].timeSaved);
			html += '<nobr><input type=button onclick="loadWrappedOptions(savedWrappedOptions['+i+']);" value="'+name+'" title="display/edit '+name+'"></input>';
			//html += '<input type=button onclick="saveJson(\''+name+'.json\',JSON.stringify(savedWrappedOptions['+i+']));" value="DL" title="download '+name+'"></input>';
			html += '<input type=button onclick="if(confirm(\'Delete '+name+'?\')) deleteWrappedOptionsI('+i+');" value="X" title="delete '+name+'"></input></nobr> ';
		}
		html += '<br><br>';
		html += '<input type=button onclick="if(confirm(\'Delete reefs?\')) deleteReefsInCookie();" value="(asks first) Delete all reefs in cookie (keep those in the html file)"></input>';
	}
	dom('multiOptionsDiv').innerHTML = html;
};





//FIXME do maxNumPointsPerCurveChangeAtOnce as a percent, cuz maxPointsPerCurve may be hard to reach if this is 1

var domIdOfOption = {};

//this slider/button/etc code is
//opensource MIT from https://github.com/benrayfield/jsutils/blob/master/src/arvox/arvox.html
//TODO this code doesnt allow o.anything to be 0,
//and if its near 0 it will scale it by that and not be able to change it much.
//Changing the var 'sim' to 'options'.
//var createControlsForSimInDiv = function(sim, checkboxesDiv, slidersDiv, buttonsDiv){
var createControlsForSimInDiv = function(checkboxesDiv, slidersDiv, buttonsDiv){
	checkboxesDiv.innerHTML = slidersDiv.innerHTML = buttonsDiv.innerHTML = '';
	domIdOfOption = {};

	//FIXME some of this code ignores the param options and uses the global var options instead
	
	let bitFields = [ //checkboxes
		'onlyEndist',
		'setSpeedsToZeroAfterEveryDtMove',
		'pause',
		'wrapPaintBrightMult',
		'graphEndist',
		'useTimePosition',
		'balanceSparsity',
		//'linearInterpolateSparsity',
		//'canvasElseSvg',
		'isSurface',
		//'stretchToWindow',
		'displayOuterCircle',
		'isOnlyMoveRandomlyPerpendicularToSurface',
		'ifCanvasUseUndoGraphics',
		'negTimeDoesUndo',
		//'autoMoveTimeSpeedSlider',
		//'adjust_targetDistanceBetweenAdjacentCurvePoints_byFramesPerSecond',
		//'adjust_numPoints_byFramesPerSecond',
		//TODO code to vary resolution 'forceMaxResolution',
	];
	
	let floatFieldsNegOrPos = [ //sliders
		'friction',
		'accelFieldMul',
		'loopSeconds',
		'timeSpeed',
		'freqA', //endist
		'ampA', //endist
		'freqB', //endist
		'ampB', //endist
		'freqC', //endist
		'ampC', //endist
		//'attractToSmallerCircle',
		//'attractToSmallerCircleExponent', //removed attractToSmallerCircleExponent cuz replaced by bellcurve Math.exp(-stdDev*stdDev)
		//'pushTowardRadialAngles',
		//'pushTowardRadialAnglesFracExpon',
	];
	//FIXME they're all floatFieldsNegOrPos, no floatFieldsPositive. its the slider code below etc.
	//FIXME make the slider ignore the left half which would be negative
	let floatFieldsPositive = [ //sliders
		'borderFraction',
		'borderRadiusMul',
		'paintBrightMult',
		'brightAddRed',
		'brightAddGreen',
		'brightAddBlue',
		'brightMult',
		'brightMultRed',
		'brightMultGreen',
		'brightMultBlue',
		'paintBrightAdd',
		'sameColorness',
		'colorDecayPerSec',
		'attractIfFartherThan',
		'ampAttractIfFartherThan',
		'ampStraightIfNear',
		'maxDistanceToAffectEachother',
		'computeSpeed',
		'timePosition',
		'timePositionDecay',
		'maxSpeed',
		'bootShapeScale',
		'bootShapeY',
		'bootShapeX',
		'midDist',
		'bellAAveMul',
		'bellADevMul',
		'bellAHeight',
		'bellBAveMul',
		'bellBDevMul',
		'bellBHeight',
		'bellCAveMul',
		'bellCDevMul',
		'bellCHeight',
		'nearPdist',
		//'nearMul',
		//'farMul',
		//'mdErrSqMul',
		//'minDistanceToInsertPoint',
		//'maxDistanceToRemovePoint',
		//'circPotEnOuterMul',
		//'circPotEnInnerMul',
		'targetDistanceBetweenAdjacentCurvePoints',
		'addRandomness',
		'distanceScale',
		'scalePotentialEnergyForce',
		//'smallerCircleRadius',
		//'smallerCircleThick',
		//'throwAfterPaintLineLongerThanThis'
		//'repelSelf',
		//'repelSelfDistance',
		//'repelSelfExponent',
		'stayInsideBorderCircleForce',
	];
	let intFields = [ //sliders
		//'minX',
		//'maxX',
		//'minY',
		//'maxY'
		'lineThick',
		'minPointsPerCurve',
		'maxPointsPerCurve',
		'maxNumPointsPerCurveChangeAtOnce',
		'maxCurvesPerReef',
	];
	let funcsOf0Params = [ //buttons
		'clearCanvas',
		'setAllSpeedsTo0',
		'restart',
		'remove_accelFieldPainter_likeInNFTs',
		'adjustBordersOfThisOptions',
		'randomizeColorsAndRestart_reef',
		'randomizeColorsAndRestart_background',
		'loadFirstReefThatsEstimatedTooBig',
		//'removeLast100Curves',
		//'updateSliders',
	];
	
	let fields = [];
	for(let i in bitFields){
		let FIELD = bitFields[i];
		const explain = explainOption(FIELD);
		let id = newId('chk');
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		//let startChecked = (o[FIELD] ? true : false);
		let startChecked = (oo[FIELD] ? true : false);
		checkboxesDiv.innerHTML += '<nobr><input type=checkbox title="'+explain+'" id="'+id+'" onchange="oo.'+FIELD+' = !oo.'+FIELD+';" '+(startChecked ? 'checked' : '')+'><label for="'+id+'" title="'+explain+'"> '+FIELD+'</label></nobr><br> ';
		fields.push(FIELD);
	}
	
	let numFields = [];
	numFields.push(...floatFieldsNegOrPos); //FIXME
	numFields.push(...floatFieldsPositive); //FIXME
	numFields.push(...intFields);
	for(let i in numFields){
		const FIELD = numFields[i];
		
		const explain = explainOption(FIELD);
		let isPosOrNegFloat = floatFieldsNegOrPos.includes(FIELD);
		let isPosFloat = floatFieldsPositive.includes(FIELD); //FIXME make the slider ignore the left half which would be negative
		let isInt = intFields.includes(FIELD);
		let id = newId('slider_'+FIELD+'_');
		domIdOfOption[FIELD] = id;
		//let firstVal =  o[FIELD];
		let firstVal =  oo[FIELD];
		//if((firstVal <= 0) || (firstVal !== firstVal)) throw 'field='+FIELD+', firstVal must be positive but is '+firstVal;
		let MIN = firstVal/10;
		let MAX = firstVal*20; //viewed on log scale, so slider moving to right linearly increases field val exponentially
		let MULRANGE = MAX/MIN;
		
		/*
		slider ranges 0 to 1000000.
		fieldval ranges MIN to MAX.
		fieldVal = mul*base^sliderFraction.
		TODO solve. Theres infinity possible solutions since can trade (nonlinearly) between mul and base.
		firstVal should be middle slider position. MIN and MAX are 100 times less and 100 times more than that,
		as of 2021-7-20 but I might change those later.
		TODO
		*/
		
		const MUL = MIN; //MIN*BASE^0
		const BASE = MULRANGE; //MAX == MUL*MULRANGE^1
		
		/*const fieldValToFraction = function(fieldVal){
			//OLD: fieldVal = mul*base^sliderFraction.
			//OLD: log<base>(fieldVal/mul) = sliderFraction.
			//return logBase(BASE,fieldVal/MUL);
			
			//fieldVal = mul*(base^sliderFraction-1).
			//fieldVal = mul*base^sliderFraction-mul.
			//fieldVal+mul = mul*base^sliderFraction.
			//fieldVal+mul = mul*base^sliderFraction
			//(fieldVal+mul)/mul = base^sliderFraction
			//log<base>((fieldVal+mul)/mul) = sliderFraction
			return logBase(BASE,(fieldVal+MUL)/MUL);
			
		};*/
		
		
		//bifraction means range -1 to 1.
		const fieldValToBifraction = function(fieldVal){
			return Math.sign(fieldVal)*logBase(BASE,(Math.abs(fieldVal)+MUL)/MUL);
		};
		
		/*const fractionToFieldVal = function(sliderFraction){
			//return MUL*Math.pow(BASE, sliderFraction);
			return MUL*(Math.pow(BASE, sliderFraction)-1);
		};*/
		
		const bifractionToFieldVal = function(sliderFraction){
			let sliderBifraction = 2*sliderFraction-1;
			return Math.sign(sliderBifraction)*MUL*(Math.pow(BASE, Math.abs(sliderBifraction))-1);
		};
		
		let id2 = newId(id+'_label');
		
		//OLD, from arvox.html: FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		
		let color = loops[FIELD] ? loops[FIELD].color() : '#8888ff';
		let html = '<nobr>';
		//display its selected by the whole thing being its (or the default color if it has no Loop)
		//instead of just the loop size text (such as 64) being that color
		if(selectedOption == FIELD) html += '<font color="'+color+'">';
		html += '<input title="'+explainOption('>>')+'" type=button onclick="updateSliders();" value=">>"></input>';
		let pointsPerLoop = [1, 8, 16, 32, 64, 128, 256];
		let loopSize = 1;
		if(loops[FIELD]) loopSize = loops[FIELD].radius.length;
		//let pd = ' event.preventDefault();';
		pointsPerLoop.forEach(p=>{
			let title = p==1 ? ('Remove loop for '+FIELD+' and just use slider/checkbox') : ('Set loop size of '+FIELD+' to '+p);
			html += ' <a onclick="selectOption(\''+FIELD+'\'); setLoopSize(\''+FIELD+'\','+p+');" title="'+title+'">';
			if(loopSize==p) html += '<b><font color='+color+'>';
			//html += p==1 ? 'X' : ''+p;
			if(p < 10) html += '0'; //to make it bigger, easier to click
			html += p;
			if(loopSize==p) html += '</font></b>';
			html += '</a>';
		});
		//html += 'loopSize='+loopSize;
		html += ' <input type=range id="'+id+'" title="'+explain+'" min="0" max="1000000" value="'+(500000+500000*fieldValToBifraction(firstVal))+'"'+
			' onclick="selectOption(\''+FIELD+'\');" oninput="let bifraction = between(-1,this.valueAsNumber/500000-1,1); let num = Math.sign(bifraction)*'+MUL+'*(Math.pow('+BASE+',Math.abs(bifraction))-1); '+(isInt?'num = ro(num);':'')+' oo.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = \''+FIELD+' = \'+num;"></input><label id="'+id2+'" onclick="selectOption(\''+FIELD+'\');" title="'+explain+'">'+FIELD+'='+oo[FIELD]+'</label>';
		if(selectedOption == FIELD) html += '</font>';
		html += '</nobr><br> ';
		slidersDiv.innerHTML += html;
		/*const SIM = sim;
		dom(id).oninput = function(e){
			console.log('Slider event');
			/*let sliderPositionFraction = between(0,this.valueAsNumber/1000000,1);
			let nextFieldVal = bifractionToFieldVal(sliderPositionFraction);
			console.log('Slider set sim.'+FIELD+' = '+nextFieldVal);
			SIM[FIELD] = nextFieldVal;
			*
		};*/
		//TODO save these changes somewhere, maybe put javascript code into a div so can copy/paste it from there to the js file sometimes,
		//andOr sessionStorage andOr localStorage js vars, but dont forget its there when copying the file to other ppl,
		//and put a button to clear those.
		fields.push(FIELD);
	}
	for(let i in funcsOf0Params){
		let funcName = funcsOf0Params[i];
		const explain = explainOption(funcName);
		let id = newId('btn');
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		buttonsDiv.innerHTML += '<input type=button title="'+explain+'" id="'+id+'" value="'+funcName+'" onclick="'+funcName+'();"></input><br>';
		//dom(id).onclick = function(){ o[funcName](); };
		//dont, cuz its not set like a float or true/false: fields.push(funcName);
	}
	//buttonsDiv.innerHTML += "<input type=button value=\"get slider positions as js code\" onclick=\"let div = dom('controlsDiv_output'); let fields = "+arrayOfFieldNamesToJsCodeUsingSingleQuotes(fields)+"; div.innerHTML = ''; for(let i in fields) div.innerHTML += '	o.'+fields[i]+' = '+o[fields[i]]+';<br>\\n';\"></input> ";
};

var updateSliders = ()=>createControlsForSimInDiv(dom('checkboxesDiv'),dom('slidersDiv'),dom('buttonsDiv'));


//log<base>(val), such as log<e>(e^3)==3
const logBase = function(base, val){
	return Math.log(val)/Math.log(base);
};

//TODO no escapes cuz its field names, but wouldnt hurt to have them anyways
let arrayOfFieldNamesToJsCodeUsingSingleQuotes = function(array){
	let s = '[';
	for(let i in array){
		if(i > 0) s += ', ';
		s += "'"+array[i]+"'";
	}
	return s+']';
};

var nextIdNum = 0;
//prefix is optional
var newId = function(prefix){
	if(!prefix) prefix = 'id';
	return (prefix+(nextIdNum++));
};


var newestCurve = ()=>{
	let curves = reefs[0].curves;
	return curves[curves.length-1];
};

var secondNewestCurve = ()=>{
	let curves = reefs[0].curves;
	return curves[curves.length-2];
};

var setAllSpeedsTo0 = ()=>{
	let c = newestCurve();
	for(let i=0; i<c.numPoints; i++){
		c.xv[i] = c.yv[i] = 0;
	}
};

/*var autoMoveSliders = physicalDt=>{
	if(o.autoMoveTimeSpeedSlider){
		let t = Now();
		let maxRadius = newestCurve().maxDistanceFromCenter(); //range approx 0 to 1.03
		
		timeSliderVelocity += Math.tanh(1.1+sin(t*2)*.3+.5*sin(t*3.3)-1.9*maxRadius)*.3;
		timeSliderVelocity = Math.tanh(timeSliderVelocity);
		timeSliderPosition += physicalDt*timeSliderVelocity; //spring
		timeSliderPosition = Math.tanh(timeSliderPosition);
		timeSliderVelocity -= physicalDt*timeSliderPosition; //spring
		trySetSliderBifraction('timeSpeed', timeSliderPosition);
	}

	//let autoMoveTimeSpeedSlider = dom(domIdOfOption.timeSpeed);
	//FIXME
};*/

var countNames = name=>{
	let sum = 0;
	for(let j=0; j<savedWrappedOptions.length; j++){
		if(savedWrappedOptions[j].options.name == name) sum++;
	}
	return sum;
};

//use maxDuplicates of 0 if its a new name, 1 if its an existing name you're looking for duplicates of. Returns same name if no reason to change it.
var chooseName = (maxDuplicates,name)=>{
	if(!name) return chooseName(0,'R'+Now());
	while(countNames(name) > maxDuplicates) name = incrementName(name);
	return name;
};

var bootedBuilder = false;

//oo[option] = (loopRadius-loopRadiusOfZeroOption)*loopRadiusMul;
var loopRadiusOfZeroOption = 1.6;
var loopRadiusMul = .3;
//var loopRadiusOfZeroOption = 1.2;
//var loopRadiusMul = .1;
//so display range 1 to 1.4 multiplies oo[option] by -2 to 2, if loopRadiusOfZeroOption = 1.2; and loopRadiusMul = .1;

let moveLabelUpPixels = 10;
let moveLabelRightPixels = 0;
//let moveLabelRightPixels = 10;
//let moveLabelUpPixels = 100;
//let moveLabelRightPixels = 100; //FIXME closer to 0

var grooveRange = 3; //cant bend the groove farther than this. the displayed circles are -2 (borderCircle) -1 (first circle outside borderCircle) 0 1 2 (far outside borderCircle).

var bootBuilder = ()=>{
	if(bootedBuilder) return;
	
	//Is "display reef builder (uncheck for emptier screen)" checked? (or if it doesnt exist, its unchecked.
	//The "builder" var is different, meaning is the builder code loaded (its too big to fit in cardano's 16k).
	//chkBuilder can be unchecked to not display the builder even while its code is loaded, to see what the reef will look like.
	window.chkBuilder = ()=>{
		let c = dom('chkBuilder');
		return c && c.checked;
	};

	//mouse edits the Loop "record grooves" of the selected option. Last option you click "01 08 16 32 64 128 256" in, becomes selected.
	//(TODO also if you click a slider or checkbox or the label beside that)
	window.selectedOption = 'timePosition';
	//param is null to unselect
	window.selectOption = option=>{
		selectedOption = option;
		updateSliders(); //replace contents of 3 divs containing sliders checkboxes and buttons, and rescale the sliders. TODO dont rescale the sliders.
	};
	
	/*moving this into builder. making new func bldDisp.
	if(builder){
		let isOnlyDisplaySelectedLoop = dom('chkOnlyPaintSelectedLoop').checked;
		if(chkBuilder() && o.displayOuterCircle){
			paintLoops(centerY, centerX, scaleY, scaleX, isOnlyDisplaySelectedLoop); //paint grooves
		}
		//This removes the loop labels such as "maxSpeed = 0.13819509427765803", which otherwise would remain while the loop isnt displayed.
		for(let option in loops){
			let displayLoopLabel = o.displayOuterCircle && (!isOnlyDisplaySelectedLoop || option == selectedOption);
			if(!displayLoopLabel && loops[option].domLabel){
				loops[option].domLabel.remove();
				delete loops[option].domLabel;
			}
		};
	
		if(chkBuilder() && o.graphEndist) graphEndist();
	}
	if(builder) bldDisp();
	*/
	window.bldDisp = function(centerY, centerX, scaleY, scaleX){
		let isOnlyDisplaySelectedLoop = dom('chkOnlyPaintSelectedLoop').checked;
		if(chkBuilder() && o.displayOuterCircle){
			paintLoops(centerY, centerX, scaleY, scaleX, isOnlyDisplaySelectedLoop); //paint grooves
		}
		//This removes the loop labels such as "maxSpeed = 0.13819509427765803", which otherwise would remain while the loop isnt displayed.
		for(let option in loops){
			let displayLoopLabel = o.displayOuterCircle && (!isOnlyDisplaySelectedLoop || option == selectedOption);
			if(!displayLoopLabel && loops[option].domLabel){
				loops[option].domLabel.remove();
				delete loops[option].domLabel;
			}
		};
	
		if(chkBuilder() && o.graphEndist) graphEndist();
	};
	
	
	/*
	window.useAsBoot = ()=>{
		let c = newestCurve();
		//let c = secondNewestCurve();
		//o.bootShape (such as 'angle=>(.2+.03*Math.sin(11.3*angle))') is used only if bootShapeYp and bootShapeXp dont exist.
		//If they exist, the reef starts there. You should reduce the number of points first, if you dont have much space left.
		//oo.bootShapeYp = copyMap(c.yp); //JSON.stringify does Float64Array as {0: ..., 1: ...} instead of []
		//oo.bootShapeXp = copyMap(c.xp);
		o.bootShapeYp = oo.bootShapeYp = [];
		o.bootShapeYp.push(...c.yp);
		o.bootShapeXp = oo.bootShapeXp = [];
		o.bootShapeXp.push(...c.xp);
	};*/
	
	updateSliders();
	let fromCookie = window.localStorage.getItem('savedWrappedOptions');
	let add = fromCookie ? JSON.parse(fromCookie) : []; //load savedWrappedOptions from cookie else []
	//this check for duplicates allows copy/pasting a saved json file as the savedWrappedOptions list
	//near the top of this html file, and to still save and load from cookie and make an even bigger json file
	//with more saved wrapped options later if you want
	for(let i=0; i<add.length; i++){
		let dups = 0;
		for(let j=0; j<savedWrappedOptions.length; j++){
			//if(JSON.stringify(savedWrappedOptions[j]) == JSON.stringify(add[i])) dups++; //dont add duplicate
			if(packedOptionsStr(savedWrappedOptions[j]) == packedOptionsStr(add[i])) dups++; //dont add duplicate
		}
		if(!dups) savedWrappedOptions.push(add[i]);
	}
	for(let j=0; j<savedWrappedOptions.length; j++){
		let opt = savedWrappedOptions[j].options;
		opt.name = chooseName(1,opt.name); //same name if no reason to change it
	}
	
	window.doClickForBackground = function(normY, normX){
		doPaintAccelFieldOnce = true;
		let selectHillWhenClick = dom('selectHillWhenClick').checked;
		let deleteHillWhenClick = dom('deleteHillWhenClick').checked;
		if(selectHillWhenClick || deleteHillWhenClick){
			if(oo.accelVoxels.length > 0){
				let nearestI = 0;
				for(let i=6; i<oo.accelVoxels.length; i+=6){
					let bestDist = Math.hypot(normY-oo.accelVoxels[nearestI], normX-oo.accelVoxels[nearestI+1]);
					let distI = Math.hypot(normY-oo.accelVoxels[i], normX-oo.accelVoxels[i+1]);
					if(distI < bestDist) nearestI = i;
				}
				if(deleteHillWhenClick){
					oo.accelVoxels.splice(nearestI,6); //delete a hill/accelVoxel
					o.accelVoxels = oo.accelVoxels;
				}else{ //selectHillWhenClick
					let selectedHillIndex = nearestI/6;
					loadHillNums(selectedHillIndex);
					dom('hillIndex').value = selectedHillIndex;
				}
				putHills(o.accelVoxels);
			}
		}else{
			let radius = Math.max(.005,parseFloat(dom('hillRadius').value));
			let repelForce = parseFloat(dom('hillRepelForce').value);
			let accelY = parseFloat(dom('hillAccelY').value);
			let accelX = parseFloat(dom('hillAccelX').value);
			
			/*
			//let radius = .2;
			//let radius = .1;
			let radius = o.brushSize || .03;
			let repelForce = 1;
			let accelY = 0;
			let accelX = 0;
			//let accelVoxel = BR.voxelHill(normY, normX, radius, repelForce, accelY, accelX);
			//oo.accelVoxels.push(accelVoxel);
			//paintAccelVoxel(accelVoxel);
			*/
			
			let v = [normY, normX, radius, repelForce, accelY, accelX];
			if(!oo.accelVoxels) o.accelVoxels = oo.accelVoxels = [];
			oo.accelVoxels.push(...v); //use these later by putHills(oo.accelVoxels)
			putHill(...v);
			putHills(o.accelVoxels);
			dom('hillIndex').value = o.accelVoxels.length/6-1; //select (in the 7 number choosers) the hill just created
		}
	};
	
	Loop.prototype.color = function(){
		return colorStr(this.red,this.green,this.blue);
	};
	
	//its not using these Loop funcs anymore (they were just to generate test data to see some loop at all, but now its in o.loops.
	//FIXME which loop funcs is it not using anymore? cuz theres some click events happening to edit grooves.
	
	Loop.prototype.doClick = function(y,x,centerY,centerX,scaleY,scaleX){
		//let y = Math.floor(centerY+scaleY*(loopRadiusOfZeroOption+loopRadiusMul*this.radiusAtAngle(loopAngle)));
		//let x =  Math.floor(centerX);
		//The above 2 lines are from paintOrUnpaint that computes y from radius. Instead, need to compute which index in radius array (by angle) and radius from y and x.
		let normY = (y-centerY)/scaleY;
		let normX = (x-centerX)/scaleX; //in coordinates of the innermost circle (border circle) is radius 1, and its center is (0,0).
		
		if(dom('paintBackground').checked){ //edit background walls/accels
			if(Math.hypot(normY,normX)<1){ //only inside smallest/border circle
				doClickForBackground(normY, normX);
			}
		}else{ //edit groove
			let normRadius = Math.hypot(normY,normX);
			if(normRadius == 0) return; //clicked in center of reef. do nothing.
			let unitY = normY/normRadius;
			let unitX = normX/normRadius; //(unitY,unitX) is on circle of radius 1
			let angle = Math.acos(unitX);
			if(unitY > 0) angle = twoPi-angle;
			angle += loopAngle; //loopAngle changes with time depending on loopSeconds slider.
			angle += Math.PI/2; //FIXME why is it 1/4 turn different than I expected? This line shouldnt be needed.
			angle %= twoPi;
			if(angle < 0) angle += twoPi;
			let multiplySliderBy = (normRadius-loopRadiusOfZeroOption)/loopRadiusMul;
			if(-grooveRange < multiplySliderBy && multiplySliderBy < grooveRange){
				//multiplySliderBy = between(-grooveRange, multiplySliderBy, grooveRange);
				let radiusIndex = betweenInt(0, angle/twoPi*this.radius.length, this.radius.length-1); //between, cuz roundoff
				//TODO rename Loop.radius to multiplySliderBy or something like that cuz its confusing now that its using loopRadiusOfZeroOption and loopRadiusMul to move and scale radius.
				this.radius[radiusIndex] = multiplySliderBy;
				console.log('Loop '+this.name+' angle='+angle+' normRadius = '+normRadius+' radiusIndex='+radiusIndex+' multiplySliderBy='+multiplySliderBy);
			}
		}
	};

	//undoableVoxels paint and unpaint the same way cuz its by xor. If curve is null, does nothing.
	//Also does Loop.clicks which were put by mouse events to edit loop shape then empties that.
	Loop.prototype.paintOrUnpaint = function(centerY, centerX, scaleY, scaleX){
		let changed = false;
		while(this.clicks.length){
			let click = this.clicks.pop();
			this.doClick(click[0],click[1],centerY,centerX,scaleY,scaleX); //y x
			changed = true;
		}
		if(changed) this.saveToOptions();
		if(this.curve){
			paintCurveOntoByterect(true, this.curve, canv.byteRect, centerY, centerX, scaleY, scaleX, 1); //Loop uses lineThick of 1 instead of o.lineThick
		}
		if(bo){ //the main dom node
			if(!dom('chkOnlyPaintSelectedLoop').checked || this.name == selectedOption){
				if(!this.domLabel){
					this.domLabel = document.createElement('label');
					this.domLabel.innerHTML = this.name;
					//this.domLabel.innerHTML = 'O'; //FIXME
					let s = this.domLabel.style;
					s.color = colorStr(this.red,this.green,this.blue);
					s.zIndex = 10000; //FIXME is this in front of canvas? want it to be.
					s.position = 'absolute';
					//dom('reefBuilder').appendChild(this.domLabel);
					dom('grooveLabelsDiv').appendChild(this.domLabel);
				}
				//let moveLabelUpPixels = 10;
				//let moveLabelUpPixels = 0;
				//this.domLabel.style.top = Math.floor(centerY+scaleY*this.radiusAtAngle(Math.PI/2+loopAngle));
				//this.domLabel.style.top = Math.floor(centerY+scaleY*(this.radiusAtAngle(loopAngle)))-moveLabelUpPixels;
				//this.domLabel.style.top = Math.floor(centerY+scaleY*(loopRadiusOfZeroOption+loopRadiusMul*this.radiusAtAngle(loopAngle)))-moveLabelUpPixels;
				let y = Math.floor(centerY+scaleY*(loopRadiusOfZeroOption+loopRadiusMul*this.radiusAtAngle(loopAngle)));
				let x =  Math.floor(centerX);
				this.domLabel.style.top = y-moveLabelUpPixels;
				this.domLabel.style.left = x+moveLabelRightPixels; //FIXME use radius, scaled and moved
				this.domLabel.innerHTML = this.name+' = '+o[this.name];
				
				/*
				//paint dot same color as loop where domLabel should be. If lines are too long (too few points in loop),
				//(FIXME) then it displays as line but should be a curve. linear interpolation causes that, instead of radius interpolation.
				let squareExtraSize = 2;
				for(let dy=-squareExtraSize; dy<=squareExtraSize; dy++){
					for(let dx=-squareExtraSize; dx<=squareExtraSize; dx++){
						canv.byteRect.writeSafeRGBA(y+dy, x+dx, this.red, this.green, this.blue);
					}
				}
				*/
				//canv.byteRect.writeSafeRGBA(y, x, 255, 255, 255); //paint white dot where domLabel should be. having problems aligning domLabel.
			}
		}
	};
	
	/*moving this into builder, since 2022-5-9 GeneReefer said to not display hills in the NFTs, even if they affect the reef movements,
	and which the sliders can do, but that means we have this space for metadata and to allow more combos of bootshape+otherOptions,
	since some bootShapes are bigger than others.

	//copies accelField onto part of byteRect. accelField must be size 1<<21, but byteRect can be any size, and window may resize causing byteRect (from canvas) resizing.
	//Params include rectangle in accelField and rectangle in byteRect
	*/
	window.paintAccelField = (brightAddRed, brightAddGreen, brightAddBlue, brightMult, accelField, aYFrom, aYTo, aXFrom, aXTo, byteRect, bYFrom, bYTo, bXFrom, bXTo)=>{
		let arr = byteRect.b;
		let aHeight = aYTo-aYFrom;
		let aWidth = aXTo-aXFrom;
		let bHeight = bYTo-bYFrom;
		let bWidth = bXTo-bXFrom;
		for(let bY = bYFrom; bY<bYTo; bY++){
			let byteIndex = (bY*byteRect.w+bXFrom)*4;
			let bYFraction = (bY-bYFrom)/bHeight;
			let accelIndexY = aYFrom+fl(aHeight*bYFraction);
			for(let bX = bXFrom; bX<bXTo; bX++){
				let bXFraction = (bX-bXFrom)/bWidth;
				let accelIndexX = aXFrom+fl(aWidth*bXFraction);
				let accelIndex = (accelIndexY<<11) | (accelIndexX<<1); //1024x1024x2
				let accelY = accelField[accelIndex];
				let accelX = accelField[accelIndex+1];
				//arr[byteIndex+RED] = asByte(Math.random()*256); //FIXME should be 0
				arr[byteIndex+RED] = asByte(brightAddRed);
				arr[byteIndex+GREEN] = asByte(brightAddGreen+brightMult*accelX);
				arr[byteIndex+BLUE] = asByte(brightAddBlue+brightMult*accelY);
				arr[byteIndex+ALPHA] = 255; //visible
				byteIndex += 4;
			}
		}
	};
	
	window.setLoopSize = (option,size)=>{
		if(size == 1){
			loops[option].close();
			delete loops[option];
			delete o.loops[option];
		}else if(!loops[option]){ //create loop thats all 1 (todo plus a little randomness so its visible (theres a circle displayed at -2 -1 0 1 and 2)?
			loops[option] = newLoop(option, size, o.loops[option]&&(size==o.loops[option])); //o.loops[option] means check if it exists in options
		}else{
			//if(!isPowOf2(size)) throw 'size='+size;
			let loopB = newLoop(option, size, false);
			for(let i=0; i<size; i++){
				let angle = i/size*2*Math.PI;
				loopB.radius[i] = loops[option].radiusAtAngle(angle);
			}
			loops[option] = loopB;
		}
		//TODO avoid calling this cuz it scales the sliders again to all be same position (except negatives)
		//but to have same number as before. Just update the "8 16 32 64 128 256" controls.
		updateSliders();
	};
	
	window.clearLoops = ()=>{
		//FIXME loops should be added to all or chosen few (different per reef) o/options keys.
		for(let option in loops){
			loops[option].close();
		}
		let grooveLabelsDiv = dom('grooveLabelsDiv');
		if(grooveLabelsDiv) grooveLabelsDiv.innerHTML = ''; //in case loops[option].close(); didnt work. why doesnt it work sometimes?
		loops = {};
	};
	
	//TODO move this to builder?
	Loop.prototype.close = function(angle){
		if(this.domLabel){
			this.domLabel.remove();
			this.domLabel = null;
		}
	};

	//oo is options. o is generated from oo (map of option to various things) and loops (map of option to list of numbers). Example: oo.loops.timeSpeed[14] is theTimeSpeedLoop.radius[14]
	Loop.prototype.saveToOptions = function(){
		oo.loops[this.name] = copyList(this.radius);
		//using copyMap, instead of copyList, here, leads to oo.loops.timePosition.length being undefined
		//since {} doesnt automatically have length. And that leads to the "no points" error. So going back to copyList.
		//oo.loops[this.name] = copyMap(this.radius);
	};
	
	let d = document.body;
	//if(!canv.dom) throw 'No canvas';
	//let d = canv.dom;
	d.addEventListener('mousemove', function(event){
		mouseY = event.clientY;
		mouseX = event.clientX;
		doMouse(event);
	});
	d.addEventListener('mouseup', function(event){
		delete mouseButtonDown[event.button];
		doMouse(event);
	});
	d.addEventListener('mousedown', function(event){
		mouseButtonDown[event.button] = true;
		doMouse(event);
	});
	
	Curve.prototype.toSvgImageHtmlString = function(centerY, centerX, scaleY, scaleX, isAllOneColor){
		//let svg = 'data:image/svg,';
		let svg = '';
		
		//svg += '<svg width="791" height="600" viewBox="-70.5 -70.5 391 391" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
		//
		//dont have any urls (comments dont count), just in case the svg html tag depends on whats at them. Still works.
		svg += '<svg width="'+(maxX-minX)+'" height="'+(maxY-minY)+'" viewBox="'+minX+' '+minY+' '+(maxX-minX)+' '+(maxY-minY)+'">';
		
		//let colors = '#ff0000 #00cc00 #0000ff #888888 #22abab'.split(' ');
		let numPoints = this.numPoints;
		if(isAllOneColor) svg += '<polyline points="';
		for(let lo=0; lo<numPoints; lo++){
			let ro = Math.round;
			let hi = (lo+1)%numPoints;
			let x1 = ro(centerX+scaleX*this.xp[lo]);
			let y1 = ro(centerY+scaleY*this.yp[lo]);
			let x2 = ro(centerX+scaleX*this.xp[hi]);
			let y2 = ro(centerY+scaleY*this.yp[hi]);
			if(isAllOneColor){
				if(lo>0) svg += ' ';
				svg += x1+','+y1;
				//FIXME numPoints+1 points. missing 1.
			}else{
				//let color = (i&1) ? '#00cc00' : '#0000ff'; //alternate color per line segment
				//let color = colors[lo%colors.length];
				let color = this.colorStrAtPointIndex(lo);
				svg += '<line x1="'+x1+'" y1="'+y1+'" x2="'+x2+'" y2="'+y2+'" stroke="'+color+'" />';
			}
		}
		if(isAllOneColor){
			let color = this.colorStrAtPointIndex(0);
			svg += '" stroke="'+color+'" fill="none" />';
		}
		
		let circ = circleToDisplayIn;
		if(o.displayOuterCircle){
			let radiusMul = Math.sqrt(scaleX*scaleY); //FIXME oval instead of this, if scaleX!=scaleY
			svg += '<circle cx="'+(centerX+scaleX*circ.centerX)+'" cy="'+(centerY+scaleY*circ.centerY)+'" r="'+(radiusMul*circ.radius)+'" stroke="blue" fill="none"/>';
		}
		
		svg += '</svg>';
		//svg = svg.replaceAll(' ','%20').replaceAll('"','%22');
		return svg;
	};
	
	//like '#aab87f'
	Curve.prototype.colorStrAtPointIndex = function(i){
		let r = asByte(this.red[i]);
		let g = asByte(this.green[i]);
		let b = asByte(this.blue[i]);
		let s = '000000'+(r*65536+g*256+b).toString(16);
		return '#'+s.substring(s.length-6);
	};
	
	displayAllWrappedOptions(); //display buttons to load each of savedWrappedOptions (that are from cookie), and button to save a new one
	
	displayRaritiesSpecies();
	
	bootedBuilder = true;
};

var displayRaritiesSpecies = ()=>{
	let html = '';
	for(let s=0; s<rarities.length; s++){
		if(s == selectedSpecies) html += '<b><font color=#00ffff>';
		html += ' <a onclick="onClickSpecies('+s+');">'+rarities[s]+'</a>';
		if(s == selectedSpecies) html += '</font></b>';
	}
	dom('raritiesDiv').innerHTML = html.trim();
};

//or is it 16383?
let maxCardanoTransactionSizeRaw = 16384;

//let thereMightBeSizeOfSenderAndReceiverAddressEtc = 200; //bytes. TODO is this 0 (would leave more space for reef)?
let thereMightBeSizeOfSenderAndReceiverAddressEtc = 137;
//thereMightBeSizeOfSenderAndReceiverAddressEtc += 30; //cuz might vary some.

/* ~2022-4-28 Damien (blockchain guy) modified json file to be 16224 bytes,
and said "16427 bytes but the maximun Tx size allowed is 16384".
16427-16384+16224=16267.
Subtract 20 bytes for small variations (dont know what), just in case, and that leaves 16247.

---------------

This is from damien the blockchain developer:
Hey! 
I corrected a couple of things in the file:
- It is better to put everything inside quotes (for example the number 16.977 gives an error if is not inside quotes)
- The "licence" sentence was too long. I divided it in two.

Using this json file, the Tx size is 16427 bytes but the maximun Tx size allowed is 16384 bytes. It is necessary to reduce the file size at least 43 bytes (if you reduce it more would be better).
this is the new file with the modifications 
{"721":{"c66b3693fe52beeb2d45a2e2a1ab5c20d9e74bcde3c3b41880ac1a40":{"genereef":{"descripti...
new.json
17 KB
I can mint it today, but as I tried to explain above, first you need to decide how to reduce the json file size (at least 43 bytes, maybe a bit more is better, it is very risky to be so on the limit). If the code can't be reduced, you have to eliminate some metadata information.
Using this json, it is not possible to mint it, it exceeds the Tx size.
You will have to take care on not to exceed the Tx size in the other assets, in the whole collection. I don't know if the code is the same for the whole collection an only change the parameters or if there are more than one code. I don't know if this example is the largest in file size.
*/
let maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt = maxCardanoTransactionSizeRaw-thereMightBeSizeOfSenderAndReceiverAddressEtc;
//let maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt = 16247;

//let maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt = Math.pow(2,14)-thereMightBeSizeOfSenderAndReceiverAddressEtc; //TODO limit might be a little less than that?
//let maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt = Math.pow(2,14)-1; //TODO limit might be a little less than that?


//var estimated_sizeOfOptions_limit = 4300;
//var estimated_sizeOfOptions_limit = maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt-11984;
var estimated_sizeOfOptions_limit = maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt-12100;
//estimated_sizeOfOptions_limit -= 50; //in case of small differences in amounts of compression
//estimated_sizeOfOptions_limit -= 100; //in case of small differences in amounts of compression
//var estimated_sizeOfOptions_limit = maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt-12270;



//FIXME remove this? but since removed a little more bytes from cardanojson generator, can be a little bigger here.
//estimated_sizeOfOptions_limit = 4330;
//estimated_sizeOfOptions_limit = 4200;
//cuz moved paintAccelField into builder. might have even more space than this available,
//but its more than enough for the 301 prototype reefs as of 2022-5-9 and to have some extra metadata.
//estimated_sizeOfOptions_limit = 4600;
//it didnt make as much extra space as i thought. im tightening it back to 4330. might need to tighten more to make them all fit, but wont know until generate the 8888 jsons for the last time.
//estimated_sizeOfOptions_limit = 4330;
//
//cuz bootShapes add some size, and "neon lights _small" keeps not fitting in 4330 with ANY bootShape but has a few smaller than 4400.
//TODO 2022-5-17+ will have to remove this extra size somewhere else.
//estimated_sizeOfOptions_limit = 4400;
estimated_sizeOfOptions_limit = 4330;
//could use more than this, but give it at least this much so at least a few of the bootShapes can work.
//estimated_sizeOfOptions_limit_afterChangeBootShape = estimated_sizeOfOptions_limit+100;
estimated_sizeOfOptions_limit_afterChangeBootShape = estimated_sizeOfOptions_limit+200; //cuz found some extra space, so let them use more of the bootShapes when reef is already big.

var numHills = opt=>(opt.accelVoxels ? opt.accelVoxels.length/6 : 0);

var displayText = curve=>{
	let perimeterDiv = dom('perimeter');
	if(perimeterDiv && reefs && reefs[0]){
		perimeterDiv.innerHTML = 'perimeter='+curve.perimeter()
			+'<br>numHills='+numHills(oo)
			+'<br>numCurves='+reefs[0].curves.length
			+'<br>numPoints = '+curve.numPoints
			+'<br>colorSeed = '+oo.colorSeed
			//+'<br>boundingCircle='+JSON.stringify(curve.boundingCircle());
			//+'<br>boundingCircleRadius='+curve.boundingCircle().radius
			//+'<br>friction='+o.friction //TODO make it a field Reef.friction or Curve.friction
			//+'<br>maxLineLenPaintedSoFar='+maxLineLenPaintedSoFar
			//+'<br>defaultAddRandomness='+defaultAddRandomness
			//+'<br>maxSpeed='+o.maxSpeed;
			+'<br>framesPerSecond='+framesPerSecond
			//+'<br>targetDistanceBetweenAdjacentCurvePoints='+o.targetDistanceBetweenAdjacentCurvePoints
			+'<br>averageAdjacentPointsDistance='+(curve.perimeter()/curve.numPoints);
		let observed = sizeOfOptions(oo);
		let s = '<font color='+(observed <= estimated_sizeOfOptions_limit ? 'white' : 'red')+'>sizeOfOptions (probably '+estimated_sizeOfOptions_limit+' or less fits)='+observed+'<br>(but if you leave more space (up to 1000 less) then<br> can generate reefs with bigger bootShapes from it)</font>';
		dom('sizeOfOptionsDiv').innerHTML = s;
	}
};


//This was moved from the display func.
//Can only display outer/bounding circle if in reef builder, cuz we dont have enough space in NFTs
var tryDispOutCirc = function(centerY, centerX, scaleY, scaleX){
	if(o.displayOuterCircle){
		
		if(!brp.paintCircleRadiusYXRGBSafe) brp.paintCircleRadiusYXRGBSafe = function(radius, cy, cx, redByte, greenByte, blueByte){
			//let circle = 2*Math.PI;
			let numPoints = Math.ceil(radius*twoPi*1.5);
			let anglePerPoint = 2*Math.PI/numPoints;
			for(let i=0; i<numPoints; i++){
				let angle = anglePerPoint*i;
				let x = cx+radius*Math.cos(angle);
				let y = cy+radius*sin(angle);
				this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
			}
		};
	
	
		let circ = circleToDisplayIn;
			
		let radiusMul = Math.sqrt(scaleX*scaleY); //FIXME oval instead of this, if scaleX!=scaleY
		
		//paint a circle for -2 -1 0 1 and 2 of what sliders are multiplied by. whats in oo is multiplied by this number (in loop, but move and scale it first) to generate what goes in o/options.
		//oo is what the sliders and checkboxes change. this other number is the "record groove"/"circular cam"/Loop radius (moved and scaled) at the current loopAngle
		//(loopAngle is a var that changes with time based on o.loopSeconds).
		let scaleMuls = [1, loopRadiusOfZeroOption-loopRadiusMul, loopRadiusOfZeroOption, loopRadiusOfZeroOption+loopRadiusMul, loopRadiusOfZeroOption+loopRadiusMul*2];
		let brights = [90, 90, 220, 90, 90];
		for(let i=0; i<scaleMuls.length; i++){
			canv.byteRect.paintCircleRadiusYXRGBSafe(
				scaleMuls[i]*radiusMul*circ.radius,
				centerY+scaleY*circ.centerY,
				centerX+scaleX*circ.centerX,
				brights[i], brights[i], brights[i]); //paint the circle that the reef should stay inside
		}
			
		//canv.byteRect.paintCircleRadiusYXRGBSafe(circ.radius, circ.centerY, circ.centerX, 0, 40, 220); //paint the circle that the reef should stay inside
	}
};




//var dragEvent = null;
//var dragFile = null;

/*
var FileDragHover = function(e){
	e.stopPropagation();
	e.preventDefault();
	//e.target.className = (e.type == "dragover" ? "hover" : "");
};*/

/*
var onDragJsonIn = function(json){
	console.log('dragged in from file: '+json);
};

async function getBytesFromDragEvent(event){
	return await abcabc_getAsByteArray(event.dataTransfer.files[0]);
};

async abcabc_getAsByteArray(file){
	return new Uint8Array(await abcabc_readFile(file));
};

var abcabc_readFile = function(file){
	return new Promise((resolve, reject) => {
		let reader = new FileReader()
		reader.addEventListener("loadend", e => resolve(e.target.result))
		reader.addEventListener("error", reject)
		reader.readAsArrayBuffer(file)
	})
};*/



//var theFile = null;

var clearHills = ()=>{
	o.accelVoxels = oo.accelVoxels = [];
	putHills(o.accelVoxels);
};

var onDragJson = function(jsonlike, optionalName){
	console.log('dragged in jsonlike: '+jsonlike);
	
	//do this before clearHills, so we dont lose the hills, just the display of them, even though clearHills does delete the hills in options.
	let nextOptions = copyMap(oo); //a copy of the options displayed, to modify.
	putInDefaults(nextOptions); //in case the options are from an earlier version of the reef builder
	
	let optionsJsonlike = getOptionsJsonlikeOrNullFromCardanoJson(jsonlike);
	//REVERSED: console.log('That json is '+(optionsJsonlike?'just the options.':'a cardano json for poolpm.'));
	console.log('That json is '+(optionsJsonlike?'a cardano json for poolpm.':'just the options.'));
	if(optionsJsonlike){
		jsonlike = "{timeSaved:0, options:"+optionsJsonlike+"};";
		console.log('got this jsonlike out of it: '+jsonlike);
	}
	clearCanvas();
	clearHills();
	let dragChangesColorSeed = dom('dragChangesColorSeed').checked; //colorSeed
	let dragChangesCurves = dom('dragChangesCurves').checked; //most other things
	let dragChangesIsSurface = dom('dragChangesIsSurface').checked; //isSurface
	let dragChangesBootShape = dom('dragChangesBootShape').checked; //bootShape*
	let dragChangesGrooves = dom('dragChangesGrooves').checked; //loops
	let dragChangesHills = dom('dragChangesHills').checked; //accelVoxels
	let dragChangesDir = dom('dragChangesDir').checked; //dir
	let dragChangesFuncs = dom('dragChangesFuncs').checked; //endist etc
	//let dragChangesColorSeed_andRestart = dom('dragChangesColorSeed_andRestart').checked;
	//const doRestart = !dragChangesColorSeed || dragChangesColorSeed_andRestart;
	const doRestart = true;
	setTimeout(()=>{
	//requestAnimationFrame(()=>{
		let incomingOptions = javascriptJsonlikeParse(jsonlike).options; //FIXME also grab the timeModified
		
		putInDefaults(incomingOptions);
		
		//based on the "dragging in json file changes" checkboxes, change only those parts of displayed options (in oo)
		if(dragChangesColorSeed){
			nextOptions = makeOptionsColor(nextOptions, incomingOptions);
		}
		if(dragChangesCurves){
			nextOptions = makeOptionsSlidersAndCheckboxes(nextOptions, incomingOptions);
		}
		if(dragChangesIsSurface){
			nextOptions = makeOptionsSurface(nextOptions, incomingOptions);
		}
		if(dragChangesBootShape){
			nextOptions = makeOptionsBootShape(nextOptions, incomingOptions);
		}
		if(dragChangesGrooves){
			nextOptions = makeOptionsGrooves(nextOptions, incomingOptions);
		}
		if(dragChangesHills){
			nextOptions = makeOptionsHills(nextOptions, incomingOptions);
		}
		if(dragChangesDir){
			nextOptions = makeOptionsDir(nextOptions, incomingOptions);
			dom('reefDir').value = nextOptions.dir;
		}
		if(dragChangesFuncs){
			nextOptions = makeOptionsFuncs(nextOptions, incomingOptions);
		}
		if(dragChangesReefName && optionalName){
			dom('reefName').value = nextOptions.name = optionalName;
		}
		oo = nextOptions;
		o = copyMap(oo);
		
		
		/*
		let opt = incomingOptions;
		//oo = copyMap(oo);
		oo = copyMap(opt);
		putInDefaults(oo); //only those it doesnt have
		o = copyMap(oo);
		if(dragChangesColorSeed){
			console.log('Change  colorSeed: '+opt.colorSeed);
			oo.colorSeed = opt.colorSeed;
		}else{
			console.log('Keeping colorSeed: '+opt.colorSeed);
		}
		if(dragChangesCurves){
			console.log('Changing shape');
			for(let option in opt){
				if(option != 'colorSeed' && option != 'isSurface' && option != 'bootShape' && option != 'loops'){ //
					oo[option] = opt[option];
					console.log('Change '+option+': '+oo[option]);
				}
			}
			let name = oo.name || optionalName || 'R'+Now();
			dom('reefName').value = name;
		}else{
			for(let option in opt){
				if(option != 'colorSeed' && option != 'isSurface' && option != 'bootShape' && option != 'loops' && option != 'accelVoxels'){ //TODO merge duplicate code
					console.log('Keeping '+option+': '+oo[option]);
				}
			}
		}
		let option = 'isSurface';
		if(dragChangesIsSurface){
			oo[option] = opt[option];
			console.log('Change '+option+': '+oo[option]);
		}else{
			console.log('Keeping '+option+': '+oo[option]);
		}
		for(let option in opt){
			if(option.startsWith('boot')){
				if(dragChangesBootShape){
					oo[option] = opt[option];
					console.log('Change '+option+': '+oo[option]);
				}else{
					console.log('Keeping '+option+': '+oo[option]);
				}
			}
		}
		//if(dragChangesBootShape) oo.bootShape = opt.bootShape; //in case opt doesnt have a bootShape the prev loop wouldnt remove the last bootShape
		if(dragChangesGrooves) o.loops = oo.loops = copyMap(opt.loops);
		for(let option in opt.loops){
			if(dragChangesGrooves){
				console.log('Change  groove '+option);
			}else{
				console.log('Keeping groove '+option);
			}
		}
		if(dragChangesHills){
			o.accelVoxels = oo.accelVoxels = copyMap(opt.accelVoxels || []);
			console.log('Change hills/accelVoxels, theres '+(oo.accelVoxels.length/6)+' of them');
		}else{
			if(!oo.accelVoxels) o.accelVoxels = oo.accelVoxels = [];
			console.log('Keeping hills/accelVoxels, theres '+(oo.accelVoxels.length/6)+' of them');
		}

		//if(dragChangesColorSeed){ //replace colorSeed only
		//	oo = copyMap(oo);
		//	console.log('Dragged in file, changing colorSeed from '+oo.colorSeed+' to '+opt.colorSeed+' and restarting.');
		//	oo.colorSeed = opt.colorSeed;
		//}else{ //replace all options
		//	oo = opt;
		//	//oo = JSON.parse(json).options; //FIXME also grab the timeModified
		//	let name = oo.name || optionalName || 'R'+Now();
		//	dom('reefName').value = name;
		//}
		*/
		
		if(doRestart){
			console.log('Restart');
			restart();
			updateSliders();
		}
		
	}, 100); //FIXME
	if(doRestart){
		console.log('Scheduling restart');
		setTimeout(updateSliders, 200); //FIXME
		setTimeout(updateSliders, 300); //FIXME
		setTimeout(restart, 400); //FIXME
	}
};

var getDataurlFromAnyPartofCardanoMap = ob=>{
	if(typeof(ob) == 'object'){
		for(let key in ob){
			if(key == 'src') return ob[key].join(''); //concat all strings in src list of strings.
			let dataurlOrNull = getDataurlFromAnyPartofCardanoMap(ob[key]);
			if(dataurlOrNull) return dataurlOrNull;
		}
	}
	return null;
};

//null if its not a cardano json with at least 1 file (other than thumbnail)
var getOptionsJsonlikeOrNullFromCardanoJson = cardanoJson=>{
	let dataurl = getDataurlFromAnyPartofCardanoMap(javascriptJsonlikeParse(cardanoJson));
	if(!dataurl) return null;
	return getOptionsJsonlikeOrNullFromDataUrlOfHtml(dataurl);
};

var javascriptJsonlikeParse_temp = null;

//similar to json except you dont have to quote the keys
var javascriptJsonlikeParse = jsonlike=>{
	eval('javascriptJsonlikeParse_temp = '+jsonlike+';');
	let map = javascriptJsonlikeParse_temp;
	javascriptJsonlikeParse_temp = null;
	return map;
};

var getOptionsJsonlikeOrNullFromDataUrlOfHtml = dataurl=>{
	let prefix = "<scr"+"ipt>let%20o=";
	let startIndex = dataurl.indexOf(prefix);
	if(startIndex == -1) return null;
	startIndex += prefix.length;
	let endIndex = dataurl.indexOf(";var%20builder=");
	if(endIndex == -1 || endIndex < startIndex) return null;
	let urlEncodedJsonlike = dataurl.substring(startIndex,endIndex);
	return decodeURI(urlEncodedJsonlike); //change '%20' to ' ', for example, since the o/options map contains a few code strings (endist, bootShape, etc).
};

var onDragFiles = function(files){
	if(files.length == 1){
		onDragFile(files[0],true);
	}else if(files.length == 0){
		alert('dragged in no files');
	}else{ //breed multiple reefs
		manyEvolvableOptions = [];
		for(let i=0; i<files.length; i++){
			onDragFile(files[i],false);
		}
		//TODO verify: first ascending by options.dir, then break ties by descending by size of options as string, then break ties by comparing those strings.
		manyEvolvableOptions.sort(optionsComparator);
		console.log('The '+files.length+' files you dragged in will be in manyEvolvableOptions probably in less than a second. TODO sort them by optionsComparator.');
	}
};

//drag in multiple files to put them here, replacing the last set dragged in.
let manyEvolvableOptions = [];

//take some from manyEvolvableOptions and evolve them
var evolveNextReef = ()=>{
	if(manyEvolvableOptions.length < 2){
		alert('Drag in multiple json files at once first');
		return;
	}
	let a = randInt(manyEvolvableOptions.length);
	let b = (a+1+randInt(manyEvolvableOptions.length-1))%manyEvolvableOptions.length; //different than a
	let optionsA = manyEvolvableOptions[a];
	let optionsB = manyEvolvableOptions[b];
	let evolvedOptions = breed(optionsA,optionsB);
	let wrappedEvolvedOptions = {timeSaved:Now(), options:evolvedOptions};
	onDragJson(JSON.stringify(wrappedEvolvedOptions), wrappedEvolvedOptions.options.name); //display the evolved reef
	return wrappedEvolvedOptions.options;
};

var breed = (optionsA, optionsB)=>{
	optionsA = copyMap(optionsA);
	optionsB = copyMap(optionsB);
	putInDefaults(optionsA);
	putInDefaults(optionsB);
	let ret = {};
	let keys = {};
	for(let option in optionsA) keys[option] = true;
	for(let option in optionsB) keys[option] = true;
	for(let option in keys){
		if(option == 'loops' || option == 'name' || option == 'accelVoxels') continue;
		let valA = optionsA[option];
		let valB = optionsB[option];
		if(valA === undefined){
			ret[option] = valB;
		}else{
			if(valB === undefined){
				ret[option] = valA;
			}else{ //both exist
				if(typeof(valA) == 'number'){
					if(Math.random() < .4){
						ret[option] = (Math.random() < .5) ? valA : valB;
					}
					let wasIntegers = (valA==Math.floor(valA) && valB==Math.floor(valB));
					if(valA*valB < 0) ret[option] = Math.sqrt(-valA*valB)*((Math.random() < .5) ? 1 : -1);
					else ret[option] = Math.sqrt(valA*valB)*Math.sign(valA);
					if(wasIntegers) ret[option] = Math.sign(ret[option])*Math.ceil(Math.abs(ret[option]));
				}else if(typeof(valA) == 'string'){
					ret[option] = (Math.random() < .5) ? valA : valB;
				}else if(typeof(valA) == 'boolean'){
					ret[option] = (Math.random() < .5) ? valA : valB;
				}else{
					alert('Unknown type of option '+option);
				}
			}
		}
	}
	ret.accelVoxels = (Math.random() < .5) ? (optionsA.accelVoxels || []) : (optionsB.accelVoxels || []);
	let loopKeys = {};
	for(let option in optionsA.loops) loopKeys[option] = true;
	for(let option in optionsB.loops) loopKeys[option] = true;
	ret.loops = {};
	for(let option in loopKeys){
		if(optionsA.loops[option]){
			if(optionsB.loops[option]){
				ret.loops[option] = (Math.random() < .5) ? optionsA.loops[option] : optionsB.loops[option];
			}else{
				ret.loops[option] = optionsA.loops[option];
			}
		}else{
			if(optionsB.loops[option]) ret.loops[option] = optionsB.loops[option];
		}
	}
	ret.name = 'evo_'+optionsA.name+'_'+optionsB.name+' '+randInt(1000);
	return ret;
};



var estimateIsTooBig = opt=>(sizeOfOptions(opt) > estimated_sizeOfOptions_limit);

var loadFirstReefThatsEstimatedTooBig = ()=>{
	let countTooBig = 0;
	let firstTooBig = null;
	if(manyEvolvableOptions.length){
		for(let opt of manyEvolvableOptions){
			if(estimateIsTooBig(opt)){
				if(!countTooBig) firstTooBig = opt;
				countTooBig++;
			}
		}
		if(!countTooBig){
			alert('All '+manyEvolvableOptions.length+' reefs are estimated to fit, but wont know for sure until max compress the cardano jsons which takes a minute or so per reef.');
			
		}else{
			alert('Loading ['+firstTooBig.name+'] of the '+countTooBig+'/'+manyEvolvableOptions.length+' reefs that are estimated to be too big.\r\nIt has '+numHills(firstTooBig)+' hills and '+mapKeys(firstTooBig.loops).length+' loops.\r\nYou should shrink it, save, and drag in everything again, until they all fit.');
			loadReef(firstTooBig);
		}
	}else{
		alert('You havent dragged in (all at once, like 50 or 300 json files) options json files yet');
	}
};

var onDragFile = function(file, displayIt){
    let reader = new FileReader();
	let n = file.name;
	if(n && n.endsWith('.json')) n = n.substring(0,n.length-5);
	const name = n;
    reader.onload = function(){
		if(displayIt){
			onDragJson(reader.result, name);
		}else{
			let wrappedOptions = javascriptJsonlikeParse(reader.result);
			let options = wrappedOptions.options || wrappedOptions;
			options.name = name; //take filename over whats in the json
			manyEvolvableOptions.push(options);
			//for(let opt of manyEvolvableOptions){ if(sizeOfOptions(opt) > estimated_sizeOfOptions_limit) console.log('MAYBE TOO BIG: '+opt.name); }
			if(estimateIsTooBig(options)) console.log('MAYBE TOO BIG: '+n);
		}
    };
    reader.readAsText(file);
};


var graphEndistFloats = null;

//display endist function as a heightmap where dist and pdist are the 2 dimensions and height is some view of potentialEnergy (TODO maybe scaled by log, or something like that).
var graphEndist = ()=>{
	let displayWidthAndHeight = Math.ceil(Math.min(canv.byteRect.w, canv.byteRect.h)/4);
	if(!displayWidthAndHeight) throw 'size 0 canvas';
	let offsetY = Math.ceil(displayWidthAndHeight*.1), offsetX = Math.ceil(3*displayWidthAndHeight); //0 0 would be top left corner of screen
	let triangleArraySize = displayWidthAndHeight*(displayWidthAndHeight)/2;
	let squareSize = displayWidthAndHeight*displayWidthAndHeight;
	if(!graphEndistFloats || graphEndistFloats.length != displayWidthAndHeight*displayWidthAndHeight) graphEndistFloats = new Float32Array(triangleArraySize+squareSize);
	//this is the max 2d distance for 2 points to affect eachother (dist).
	//pdist is distance along the curve/perimeter and can be more since a curvy path can be longer than a straight path to the same place.
	//In both cases, the influence of the 2 points on eachother is multiplied by 1 when dist is 0, and multiplied by 0 when dist is maxDistanceToAffectEachother,
	//and gradually between. So thats the part that graphEndist displays in a square.
	let display2dDist = o.maxDistanceToAffectEachother;
	let mul = display2dDist/displayWidthAndHeight;
	let offset = 0;
	let minEn = Infinity, maxEn = -Infinity;
	for(let y=0; y<displayWidthAndHeight; y++){ //dist2d index
		for(let x=y; x<displayWidthAndHeight*2; x++){ //pdist/distanceOnCurve index
		//for(let x=0; x<displayWidthAndHeight; x++){ //pdist/distanceOnCurve index
			let dist2d = y*mul;
			let pdist = x*mul;
			let potentialEnergy = endist(0, dist2d, pdist);
			graphEndistFloats[offset++] = potentialEnergy;
			minEn = Math.min(minEn, potentialEnergy);
			maxEn = Math.max(maxEn, potentialEnergy);
		}
	}
	if(minEn >= maxEn) throw (minEn+' == minEn >= maxEn == '+maxEn);
	offset = 0;
	//Example: oo.graphEndistBright is "Math.sqrt" so dark spots are brighter and its not so distracting for a bright spot to be in one place
	let graphEndistBright = eval(oo.graphEndistBright || "enFraction=>enFraction");
	for(let y=0; y<displayWidthAndHeight; y++){ //dist2d index
		//for(let x=0; x<displayWidthAndHeight; x++){ //pdist/distanceOnCurve index
		for(let x=y; x<displayWidthAndHeight*2; x++){ //pdist/distanceOnCurve index
		
			let potentialEnergy = graphEndistFloats[offset++];
			let enFraction = (potentialEnergy-minEn)/(maxEn-minEn);
			let bentEnFraction = graphEndistBright(enFraction);
			let bright = bentEnFraction*255;
			
			//FIXME use undoableVoxel
			canv.byteRect.writeSafeRGBA(y+offsetY, x+offsetX, bright, bright, bright);
		}
	}
};



var mouseY = 0;
var mouseX = 0;
var mouseButtonDown = {};

//called when mouse does stuff in canvas, especially around reef. FIXME this shouldnt happen (use preventDefault()?) when its not near the reef such as on sliders buttons checkboxes.
var doMouse = event=>{
	//event.preventDefault();
	//if(mouseButtonDown[2]){ //right mouse button
	//	selectOption(null); //unselect, so you can click without it interfering with things.
	//}else if(mouseButtonDown[0] && loops[selectedOption]){ //left mouse button
	if(mouseButtonDown[0] && loops[selectedOption]){ //if left mouse button down
		loops[selectedOption].clicks.push([mouseY,mouseX]); //schedule click for next time its painted, cuz need to know where its displayed to match the click to it.
	}
};

//reef color, not background
var randomizeColorsAndRestart_reef = ()=>{
	oo.colorSeed = Math.floor(Math.random()*Math.pow(2,48));
	restart();
};

//background color, not reef
var randomizeColorsAndRestart_background = ()=>{
	partialRandomizeReefBackgroundColor(oo);
	restart();
};

var bootUrlParams = ()=>{
	var urlParams = ()=>{
		let ret = {};
		new URLSearchParams(window.location.search).forEach((v,k)=>(ret[k]=v));
		return ret;
	};

	let urlp = copyMap(urlParams());
	console.log('urlParams = '+JSON.stringify(urlp));

	//If something in options is given as url param, like something.html?maxSpeed=.2&isSurface=true , then those replace options stored in this file in that one viewing of it in browser.
	for(let par in urlp){
		const ty = typeof(o[par]); //type of existing option of that name
		if(ty == 'number') o[par] = Number(urlp[par]);
		else if(ty == 'boolean') o[par] = (urlp[par] == 'true');
		else o[par] = urlp[par]; //probably string, keep it same type as in url param
	}
};


/*for making o/options map fit in smaller space
removeLowDigits(5.343465345345)
5.34
removeLowDigits(11115.343465345345)
11115.34
removeLowDigits(5.343465345345e55)
5.343465345345e+55
*/
var removeLowDigits = n=>{
	s = ''+n;
	if(s.includes('e') || !s.includes('.')) return n; //leave 2.2222222222222224e+31 and integers as they are
	let dotIndex = s.indexOf('.');
	s = s.substring(0,Math.min(dotIndex+4,s.length));
	//s = s.substring(0,Math.min(dotIndex+6,s.length));
	return Number(s);
};

/*var lossyCompressOptionsModifyAndReturn = options=>{
	switch(typeof(options)){
	case 'number': return removeLowDigits(options);
	case 'boolean': case 'string': return options; //no change
	case 'object':
		let ret = {};
		for(let k in options){
			ret[k] = lossyCompressOptionsModifyAndReturn(options[k]);
		}
		return ret;
	default:
		throw 'TODO whats type '+typeof(options);
	}
};*/

var removeIndent = s=>s.replaceAll(/^\s*$/mg,'');

var allOneLine = s=>s.replaceAll(/(\r|\n)/mg,'');

/*var rebuildMapWithSortedKeys = map=>{
	let m = {};
	let keys = mapKeys(map);
	keys.sort();
	for(let k of keys) m[k] = map[k]; //in case order of inserts matters.
	return m;
};*/

//replacement for JSON.stringify, since this is repeatable. it sorts keys first.
var betterJsonStringify = ob=>{
	let ret = '';
	let ty = typeof(ob);
	switch(ty){
		case 'number': case 'string': case 'boolean': return JSON.stringify(ob);
		case 'object':
			if(Array.isArray(ob)){ //{}
				let firstKey = true;
				ret += '[';
				for(let k=0; k<ob.length; k++){
					if(k) ret += ',';
					ret += betterJsonStringify(ob[k]);
				}
				ret += ']';
			}else{ //[]
				let keys = mapKeys(ob);
				keys.sort();
				ret += '{';
				let firstKey = true;
				for(let k of keys){
					if(!firstKey) ret += ',';
					firstKey = false;
					ret += JSON.stringify(k)+':'+betterJsonStringify(ob[k]); //the JSON.stringify of key is to put quotes
				}
				ret += '}';
			}
		break; default:
			throw 'Unknown type: '+ty;
	}
	return ret;
};

var lossyCompressOptionsModifyAndReturn = options=>{
	//if(options.meta) delete options.meta;
	switch(typeof(options)){
	case 'number': return removeLowDigits(options);
	case 'string': return options.replaceAll(/^\s*\/\/.*$/mg,'').replaceAll(/\s+/mg,' '); //replace all blocks of whitespace with 1 space. and remove // comments
	//case 'string': return options;
	case 'boolean': return options; //no change
	case 'object':
		for(let k in options){
			options[k] = lossyCompressOptionsModifyAndReturn(options[k]);
		}
		return options;
	default:
		throw 'TODO whats type '+typeof(options);
	}
};

var lossyCompressOptions = options=>lossyCompressOptionsModifyAndReturn(copyMap(options));

//var lossyCompressOptionsStr = options=>JSON.stringify(lossyCompressOptions(options)).replaceAll(/, /,',').replaceAll(/: /,':').replaceAll(/,"/,',').replaceAll(/":/,':').replaceAll(/{"/,'{');

//FIXME use replaceStringsForward andOr replaceStringsBackward instead.
//this is the step after lossyCompressOptions. it only removes some whitespace, quotes, etc, but doesnt change the numbers.
var lossyCompressOptionsStr = options=>JSON.stringify(options).replaceAll(', ',',').replaceAll(': ',':').replaceAll(',"',',').replaceAll('":',':').replaceAll('{"','{');

//var autoLossyCompressOptionsAtBootInBuilder = true;
//if(lossyCompressOptionsModifyAndReturn) o = lossyCompressOptions(o);


//This helps choose stringReplacements from minifiedJavascriptFromUglifyjs.
var mapOfSubstringsToQuantity = (str, minLen, maxLen, minQuantity)=>{
	let map = {};
	for(let len=minLen; len<=maxLen; len++){
		for(let start=0; start+len<=str.length; start++){
			let s = str.substring(start,start+len);
			map[s] = (map[s]|0)+1;
		}
	}
	let ret = {};
	for(let s in map) if(map[s] >= minQuantity) ret[s] = map[s];
	return ret;
};

var charsToReplaceBigSubstringsWithA = "abcdefghijklmnopqrstuvwxyz";

var charsToReplaceBigSubstringsWithB = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

//caller should do this first: setColorSeed(281474976710655n); //just a once-random constant from 0 to 2^48-1, so the compression is repeatable. 
var shortStringThatsNotInString = str=>{
	for(let i=0; i<500; i++){
		let s = charsToReplaceBigSubstringsWithA[randInt(charsToReplaceBigSubstringsWithA.length)]+charsToReplaceBigSubstringsWithB[randInt(charsToReplaceBigSubstringsWithB.length)];
		if(!str.includes(s)) return s;
	}
	throw 'didnt find one of size 2';
};

var nextSubstringToReplace = str=>{
	//let map = mapOfSubstringsToQuantity(str, 6, 40, 2);
	let map = mapOfSubstringsToQuantity(str, 4, 40, 2);
	let maxScore = 0;
	let quantity = 0;
	let maxS = null;
	for(let s in map){
		if(s.includes('"') || s.includes('\'') || s.includes('\\') || s.includes('%')) continue; //dont complicate things with escapes of quotes etc. just dont compress that part.
		let score = ((s.length-4) * (map[s]-1.1));
		if(score > maxScore){
			maxS = s;
			maxScore = score;
			quantity = map[s];
		}
	}
	if(maxS) return {replace: maxS, score: maxScore, quantity: quantity};
	return null;
};



//Makes list like this: "src":["data:text/html,<html><head><script>var%20options={'scr':false,'u","seColorSchemes':true,'swapPieceColors':true,'opponent':{'name':'","animegirl','transp':5,'dataUrl':'data:image/png;base64,iVBORw0KG","goAAAANSUhEUgAAAKAAAACgBAMAAAB54XoeAAAAD1BMVEW15h0AAAB0F1f/rgv//" ...
var splitStringForCardano = str=>{
	let ret = [];
	for(let i=0; i<str.length; i+=64){
		ret.push(i+64<=str.length ? str.substring(i,i+64) : str.substring(i)); //FIXME can this put an empty string at end?
	}
	return ret;
};

//warning, string to find will instead be a regex?
var replaceStringsForward = (str,stringReplacements)=>{
	for(let i=0; i<stringReplacements.length; i+=2) str = str.replaceAll(stringReplacements[i],stringReplacements[i+1]);
	return str;
};

//warning, string to find will instead be a regex?
var replaceStringsBackward = (str,stringReplacements)=>{
	for(let i=stringReplacements.length-2; i>=0; i-=2) str = str.replaceAll(stringReplacements[i+1],stringReplacements[i]);
	return str;
};

/* If it doesnt work, might have some chars that werent handled (and didnt want to escape all of them cuz that makes it bigger), so explore with code like this in browser console
(which I used to find that genereef has # char but chess NFT does not, so put in escape for # too.
Of course you could just use https://dopiaza.org/tools/datauri/index.php but that makes it bigger, both in base64 and non-base64 form.
charsIn(chess)
"!$%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}"
charsIn(htmlNFT)
" !#$%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{|}"
*/
var htmlToDataurl = html=>('data:text/html,'+allOneLine(removeIndent(html.replaceAll('%','%25').replaceAll('#','%23').replaceAll(' ','%20').replaceAll('\\','%5c'))));

var htmlNFT = null;

//if true, you cant drag the cardano json into the reef editor since its options are compressed.
//var includeOptionsEtcInCodeToCompress = true; //doesnt work cuz theres ' in options but \ seems to cause problems in cardano inside ", might be able to later???
var includeOptionsEtcInCodeToCompress = false;

//only cached if dom('cacheCompressionInCookies').checked and be careful not to use it if doing alot of reefs at once,
//since it caches into window.localStorage aka cookie. to avoid that, if its more than 30 reefs (or maybe it can do hundreds?),
//uncheck the "cache compression in cookies" checkbox.
//so the "click this before copy (takes 30 seconds or so)" button etc works instantly after taking 30 seconds the first time since loaded page
//var cachePartOfCompressingCode = null;
//var cachedDoStringReplacements_ = {};
var cachedDoStringReplacements = function(s){
	//sharedLogSuffix = ' - starting cachedDoStringReplacements';
	let cacheCompressionInCookies = dom('cacheCompressionInCookies').checked;
	if(cacheCompressionInCookies){
		let json = window.localStorage.getItem(s);
		if(json) return JSON.parse(json);
	}/*else{
		if(cachedDoStringReplacements_[s]) return cachedDoStringReplacements_[s];
	}*/
	let stringReplacements = []; //FIXME? cuz computing them with nextSubstringToReplace instead.
	let score = 0;
	if(includeOptionsEtcInCodeToCompress) throw 'Cant includeOptionsEtcInCodeToCompress while using cachedDoStringReplacements cache';
	let compressingCode = s;
	//let countReplace = 0;
	let prevSeed = getColorSeed(); //TODO use the repeatable(...) func in the other script?
	setColorSeed(281474976710655n); //just a once-random constant from 0 to 2^48-1, so the compression is repeatable. 
	//let compressionProgress = dom('compressionProgress');
	while(true){
		let m = nextSubstringToReplace(compressingCode);
		//if(!m || m.score < 5) break;
		if(!m || m.score < 1) break;
		let replaceThis = m.replace;
		//let replaceWith = (countReplace++)+'@';
		//let replaceWith = '<'+(countReplace++)+'>';
		let replaceWith = shortStringThatsNotInString(compressingCode); //uses randInt which uses color seed (pseudorandomness generator)
		stringReplacements.push(replaceThis,replaceWith);
		let msg = 'replace ['+replaceThis+'] with ['+replaceWith+'] '+m.quantity+' times'+sharedLogSuffix;
		//compressionProgress.innerHTML = msg;
		console.log(msg);
		compressingCode = compressingCode.split(replaceThis).join(replaceWith);
		//if(countReplace > 5) break;
	}
	setColorSeed(prevSeed);
	let retMap = {stringReplacements: stringReplacements, code: compressingCode};
	if(cacheCompressionInCookies){
		//FIXME this could fill up the browsers cookies for that site (localhost probably)
		//which might be limited to 5mB but we might need around 230mB of cookies for 8888 reefs.
		//Maybe browser settings could be adjusted to allow that.
		try{
			let json = JSON.stringify(retMap);
			window.localStorage.setItem(s,json);
			//return retMap;
		}catch(e){
			alert('Is browser cookies full?');
			throw e;
		}
	}/*else{
		//if(cachedDoStringReplacements_[s]) return cachedDoStringReplacements_[s];
		return retMap;
	}*/
	return retMap;
};

var adjustBordersOfOptions = options=>{
	//this code moved from dataUrlOfGenereef...
	//modifiedOptions.borderFraction = .1; //make it display bigger if in builder it was small cuz theres more stuff on screen
	//FIXME shouldnt change the physics of the reef in a conversion to dataurl (dataUrlOfGenereef),
	//but since borderFraction is changed here, it seems a good enough place for now...
	//options.borderFraction = .55; //display it smaller, so it extends to near the top and bottom of screen but screen is normally wider than it is tall. .5 would be exactly to top and bottom of screen.
	//options.borderRadiusMul = 2; //give it more space to expand
	//options.borderFraction = .4;
	//options.borderRadiusMul = 1.5;
	options.borderFraction = .25;
	options.borderRadiusMul = 1.3;
};

//Clicking this should make the background color remain (and extend past the square accelField
//cuz of simpler loop that doesnt select just the area of the accelfield, does it to the whole canvas),
//which paintAccelField was painting the background too, but not display hills.
//If !isSurface, paintAccelField is done every video frame (wasteful but still works).
//If isSurface, paintAccelField is done only when the reef starts.
//NFTs cant display accelField but stilld o accelField physics. paintAccelField is only in the builder. saves a little space,
//and GeneReefer said to not display the hills/accelField cuz it just looks better without it.
var remove_accelFieldPainter_likeInNFTs = function(){
	window.paintAccelField = null;
};

var dataUrlOfGenereef = (prefixHtml, options, nonminifiedJavascript, minifiedJavascriptFromUglifyjs, suffixHtml)=>{
	let modifiedOptions = lossyCompressOptions(options);
	
	adjustBordersOfOptions(modifiedOptions);
	
	/*
	let jsCode = 'let o='+lossyCompressOptionsStr(modifiedOptions)+';';
	jsCode += nonminifiedJavascript;
	*/
	
	let jsCode = '';
	
	//let doStringReplacements = dataUrlOfGenereef.length ? true : false;
	let doStringReplacements = dom('doStringReplacements').checked;
	//let doStringReplacements = false; //FIXME should be true
	let isCompressOptionsToo = dom('isCompressOptionsToo').checked;
	
	let firstCode = '';
	
	firstCode += "'use strict';";
	let optStr = lossyCompressOptionsStr(modifiedOptions);
	optStr = optStr.replaceAll('"',"'"); //so you dont get " like in: let code='\'use strict\'iCo={jH:"(en,dist,pdist)=>{ let x = 0cMp = ocMnd = p.bZcMnear = tD(-5*(dis
	firstCode += 'window.o='+optStr+';'; //the generated options map, which starts as not generated. its copied to oo, and from then on o is generated from oo, so you modify it in oo while its running.
	firstCode += nonminifiedJavascript;
	
	let beforeCodeToCompress = '';
	let codeToCompress = '';
	
	if(isCompressOptionsToo){
		codeToCompress += firstCode;
	}else{
		beforeCodeToCompress = firstCode;
	}
	codeToCompress += minifiedJavascriptFromUglifyjs;
	
	if(doStringReplacements){
	
		//let x = cachedDoStringReplacements(minifiedJavascriptFromUglifyjs);
		let x = cachedDoStringReplacements(codeToCompress);
		let compressingCode = x.code;
		stringReplacements = x.stringReplacements;
		/*
		stringReplacements = []; //FIXME? cuz computing them with nextSubstringToReplace instead.
		let score = 0;
		let compressingCode = '';
		if(includeOptionsEtcInCodeToCompress){
			compressingCode += jsCode;
			//compressingCode += jsCode.replaceAll('"','\'').replaceAll('\'','\\\'');
			jsCode = '';
		}
		compressingCode += minifiedJavascriptFromUglifyjs;
		//let countReplace = 0;
		let prevSeed = getColorSeed();
		setColorSeed(281474976710655n); //just a once-random constant from 0 to 2^48-1, so the compression is repeatable. 
		//let compressionProgress = dom('compressionProgress');
		while(true){
			let m = nextSubstringToReplace(compressingCode);
			if(!m || m.score < 5) break;
			let replaceThis = m.replace;
			//let replaceWith = (countReplace++)+'@';
			//let replaceWith = '<'+(countReplace++)+'>';
			let replaceWith = shortStringThatsNotInString(compressingCode); //uses randInt which uses color seed (pseudorandomness generator)
			stringReplacements.push(replaceThis,replaceWith);
			let msg = 'replace ['+replaceThis+'] with ['+replaceWith+']';
			//compressionProgress.innerHTML = msg;
			console.log(msg);
			compressingCode = compressingCode.split(replaceThis).join(replaceWith);
			//if(countReplace > 5) break;
		}
		setColorSeed(prevSeed);
		*/
		
		


		//compressionProgress.innerHTML = '';
		
		jsCode += beforeCodeToCompress;
		
		//jsCode += 'let code=\''+replaceStringsForward(minifiedJavascriptFromUglifyjs,stringReplacements).replaceAll('\'','\\\'')+'\';';
		jsCode += 'let code=\''+compressingCode.replaceAll('\'','\\\'')+'\';';
		//jsCode += 'let replace='+JSON.stringify(stringReplacements).replaceAll('"','\'')+';';
		if(compressingCode.includes("@")) throw 'has @ so cant use that to further compress';
		jsCode += 'let replace=\''+stringReplacements.join("@").replaceAll('"','\'').replaceAll('\'','\\\'')+'\'.split(\'@\');';
		//jsCode += 'let replace='+JSON.stringify(stringReplacements).replaceAll('"','\'').replaceAll('\'','\\\'')+';';
		jsCode += 'for(let i=replace.length-2; i>=0; i-=2) code = code.split(replace[i+1]).join(replace[i]);'; //cuz replaceAll uses regex, but split and join use literal.
		jsCode += 'console.log(code);';
		jsCode += 'eval(code);';
	}else{
		jsCode += minifiedJavascriptFromUglifyjs;
	}
	
	
	console.log('jsCode='+jsCode);
	//throw 'TODO';
	
	let html = prefixHtml+jsCode+suffixHtml;
	html = html.replaceAll('"','\'');
	console.log(html);
	htmlNFT = html;
	
	//throw 'TODO';
	
	//firstFile.src = splitStringForCardano('data:text/html,'+html.replaceAll('%','%25').replaceAll(' ','%20').replaceAll('\'','%27'));
	return htmlToDataurl(html);
};

var dataurl = null;

var jsonForCardano = (prefixHtml, options, nonminifiedJavascript, minifiedJavascriptFromUglifyjs, suffixHtml)=>{
	let map = copyMap(exampleCardanoMap2);
	//let gr0 = map[721].e09e4f4217669b7f735b7a3724e835d8d6344db128eb03d6ea72885e;
	let gr0 = map[721].ce429b833be000d4da1cc9bb63104cba87533b86109d28b0185b6997; //replace this multiple places
	let gr = gr0.genereef;
	if(options.options) options = options.options; //drop the outer map with timeSaved.
	if(!options.name) throw 'No name';
	
	let fileName = 'GeneReef';
	if(options.meta){
		for(let key in options.meta){ //makeSpecies put some metadata in options.meta.
			let val = options.meta[key];
			gr[key] = val;
		}
		if(options.meta.geneReefId){
			let reefIndex = Number(options.meta.geneReefId)-1;
			fileName = reefIndexToName(reefIndex);
		}else{
			throw 'No options.meta.geneReefId'; //'1' to '8888'
		}
		delete options.meta;
	}
	
	/*gr.reefType = options.name;
	gr.pseudorandomSeedForColors = options.colorSeed;
	gr.isSurface = ''+options.isSurface;
	gr.energyFuncLoopInterval = options.useTimePosition ? options.loopSeconds : 'Infinity';
	gr.numberOfLineSegmentsInPaintbrush = options.minPointsPerCurve+' to '+options.maxPointsPerCurve;
	*/
	
	let firstFile = gr.files[0];
	firstFile.mediaType = "text/html";
	
	/*let modifiedOptions = lossyCompressOptions(options);
	modifiedOptions.borderFraction = .1; //make it display bigger if in builder it was small cuz theres more stuff on screen
	
	let jsCode = 'let o='+lossyCompressOptionsStr(modifiedOptions)+';';
	jsCode += nonminifiedJavascript;
	jsCode += minifiedJavascriptFromUglifyjs;
	
	//jsCode += 'let code=\''+replaceStringsForward(minifiedJavascriptFromUglifyjs,stringReplacements).replaceAll('\'','\\\'')+'\';';
	//jsCode += 'let code=\''+replaceStringsForward(minifiedJavascriptFromUglifyjs,stringReplacements).replaceAll('\'','\\\'')+'\';';
	//jsCode += 'let replace='+JSON.stringify(stringReplacements).replaceAll('\'','\\\'').replaceAll(' ','')+';';
	//jsCode += 'for(let i=0; i<replace.length; i+=2) code = code.replaceAll(replace[i],replace[i+1]);';
	//jsCode += 'eval(code);';
	console.log('jsCode='+jsCode);
	//throw 'TODO';
	
	let html = prefixHtml+jsCode+suffixHtml;
	html = html.replaceAll('"','\'');
	console.log(html);
	htmlNFT = html;
	
	//throw 'TODO';
	
	//firstFile.src = splitStringForCardano('data:text/html,'+html.replaceAll('%','%25').replaceAll(' ','%20').replaceAll('\'','%27'));
	firstFile.src = splitStringForCardano(htmlToDataurl(html));
	*/
	
	dataurl = dataUrlOfGenereef(prefixHtml, options, nonminifiedJavascript, minifiedJavascriptFromUglifyjs, suffixHtml);
	firstFile.src = splitStringForCardano(dataurl);
	firstFile.name = fileName; //GeneReef0001 to GeneReef8888.
	
	
	gr0[fileName] = gr0.genereef; //change genereef to, for example, GeneReef4061
	delete gr0.genereef;
	
	//return lossyCompressOptionsStr(JSON.stringify(map));
	//THIS DOESNT COMPRESS: return allOneLine(removeIndent(packedOptionsStr(map))); //so {} has same order of keys every time
	return allOneLine(removeIndent(packedOptionsStr(map))); //so {} has same order of keys every time
};

var verifyGenereefNumber = number1To8888=>{
	if((number1To8888 < 1) || (8888 < number1To8888) || (number1To8888 != Math.floor(number1To8888))) throw 'Not a genereef NFT number: '+number1To8888;
};

var optionsForNFTNumber1To8888 = number1To8888=>{
	verifyGenereefNumber(number1To8888);
	if(number1To8888 != 1) throw 'TODO';
	//let options = o; //this is just a test to make a test NFT. o/options map its about to display when page loads (or page may have already loaded as this can be called later)
	//let options = oo; //this is just a test to make a test NFT. o/options map its about to display when page loads (or page may have already loaded as this can be called later)
	let options = copyMap(oo);
	for(let option in o){
		if(!options[option]) options[option] = o[option]; //Example: o.bootShape exists (is a code string) but oo.bootShape does not (dont remember if it should or not, TODO???)
	}
	return lossyCompressOptions(options);
};


//not using this one. use exampleCardanoMap2
//
//this is some variant of what an experimental chess nft was made with
//at https://cardanoscan.io/transaction/4207a4b213acde3c2b03db0d839570a5a7e086517abc4781dfd93315a1be1334?tab=metadata which is different content and metadata,
//and was slightly modified for genereef...
//and was slightly modified for genereef...
var exampleCardanoMap = {
	"721": {
		"e09e4f4217669b7f735b7a3724e835d8d6344db128eb03d6ea72885e": {
			"genereef": {
				"description": "dont_need_to_base64_anymore",
				"files": [
					{
						"mediaType": "text/html",
						"name": "genereef",
						"src": [
							"data:text/html,<ht",
							"ml><head><scr",
							"ipt>window.o",
							"nload=function(){document.getElementById('xyz').va",
							"lue='hello,%20this%20dataurl%20is%20'+win",
							"dow.location;}</scr",
							"ipt></head><body><texta",
							"rea%20id=xyz%20rows=7%20cols=50>aabb</text",
							"area></body></ht",
							"ml>"
						]
					}
				],
				/*"image": [ //a cardanotrees icon, dont use.
					"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcm",
					"cvMjAwMC9zdmciIHdpZHRoPSIyODAiIGhlaWdodD0iNDUwIj48cmVjdCB3aWR0aD",
					"0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjRkZENzAwIi8+PGNpcmNsZSBjeD",
					"0iMTQwIiBjeT0iMTQwIiByPSIxMjAiIGZpbGw9IiNEQzE0M0MiLz48dGV4dCB0ZX",
					"h0LWFuY2hvcj0ibWlkZGxlIiBzdHlsZT0iZm9udDo4MDAgMjRwdCBzYW5zLXNlcm",
					"lmIiB4PSIxNDAiIHk9IjQxMCI+Q2FyZGFub1RyZWVzPC90ZXh0Pjx0ZXh0IHRleH",
					"QtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJmb250OjgwMCAyNHB0IHNhbnMtc2VyaW",
					"YiIHg9IjE0MCIgeT0iNDQwIj4jOTM4OTwvdGV4dD48cGF0aCBmaWxsPSIjRkY0NT",
					"AwIiBkPSJNMTM0IDM4MHExMi00OSA2LTE1NS0yMS0xMDItMTA1LTM4IDIxLTIyID",
					"Q2LTI5LTE1LTgtMjMtMzYgMTUgMzMgMzAgMzQgNDEgMiA1NiA2MiA4LTM5LTIyLT",
					"E0MSAxMSAyMyAxNiA0MiAxNi0zOCA5OC00MS05MSAxMC05NCA0NSAwIDMxIDEyID",
					"c2IDIzLTM0IDk1LTQ3LTkxIDI0LTk0IDYwIDIgMTA4IDE5IDE2OHoiLz48L3N2Zz",
					"4K"
				],*/
				//data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAA3CAMAAACVWYwmAAAAgVBMVEX///8AAAD//7ZmAADb//8AOpAAAGYAZrb/25A6AAC2/////9vbkDpmtv86kNuQOgD/tma22/+QZjoAADqQ2/9mOgD/27YAOmY6ZrY6ZpBmttvb27YAOjpmkLa2ZjrbtpA6OpCQOjq2ZgDbtrZmtrYAZpDbtma2tmaQZma2kDo6OgCQ6EPmAAABlklEQVRYw+3V6XKCMBQF4HuAggugAcG6dl/f/wGb5I5NUzoNIeMf5Y4EifjNxciBxupUFN8kF8lNpi8V6ucGdSEPGmC90twjCmor4F54cqmYTOtt1KSzKM4SSantA6VUU9Eu0pkfl+lu5vp7T++fUCyQES1R8jCQi5r6sIuZk3iOIohboiC+2PQNJUtBXEa57EsvRb0K/u2OwLqSjjyW86eVHatTuFpO/TeugFMZdyu5PUde+wBsEppXapZHU3ByKuNeUUYx31tyE63c5yi+Xz7ckk83KVAS5fUqx36bEI8+XG5zOXQVkY55HgO749pVyHjsz7EjjRMn90Lt5fVOpiWPPhyvbHLiqFXXJ/SabhIevTh3jdzZOXg4cHcABzGIuzvYszxjdw/qx/Fju/sgtzmQ4RzeAkhnP0NurmdMS/yuH8e92CHH3f3iyIOzQ+4PDl6cHXIdDqbLXpwdcoM5gn5WkB1yasZwAHw4OiIVVsjpGe6Kt17r6jjDaiyYsz81LYZx9n3h5vpmBIDwCBuQZvinaKxz1RfiPBcpEVh5lwAAAABJRU5ErkJggg==
				
				/*image: [
					"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAA3CAMAAACVWY",
					"wmAAAAgVBMVEX///8AAAD//7ZmAADb//8AOpAAAGYAZrb/25A6AAC2/////9vbkD",
					"pmtv86kNuQOgD/tma22/+QZjoAADqQ2/9mOgD/27YAOmY6ZrY6ZpBmttvb27YAOj",
					"pmkLa2ZjrbtpA6OpCQOjq2ZgDbtrZmtrYAZpDbtma2tmaQZma2kDo6OgCQ6EPmAA",
					"ABlklEQVRYw+3V6XKCMBQF4HuAggugAcG6dl/f/wGb5I5NUzoNIeMf5Y4EifjNxc",
					"iBxupUFN8kF8lNpi8V6ucGdSEPGmC90twjCmor4F54cqmYTOtt1KSzKM4SSantA6",
					"VUU9Eu0pkfl+lu5vp7T++fUCyQES1R8jCQi5r6sIuZk3iOIohboiC+2PQNJUtBXE",
					"a57EsvRb0K/u2OwLqSjjyW86eVHatTuFpO/TeugFMZdyu5PUde+wBsEppXapZHU3",
					"ByKuNeUUYx31tyE63c5yi+Xz7ckk83KVAS5fUqx36bEI8+XG5zOXQVkY55HgO749",
					"pVyHjsz7EjjRMn90Lt5fVOpiWPPhyvbHLiqFXXJ/SabhIevTh3jdzZOXg4cHcABz",
					"GIuzvYszxjdw/qx/Fju/sgtzmQ4RzeAkhnP0NurmdMS/yuH8e92CHH3f3iyIOzQ+",
					"4PDl6cHXIdDqbLXpwdcoM5gn5WkB1yasZwAHw4OiIVVsjpGe6Kt17r6jjDaiyYsz",
					"81LYZx9n3h5vpmBIDwCBuQZvinaKxz1RfiPBcpEVh5lwAAAABJRU5ErkJggg=="
				],*/
				//image: "ipfs://QmXiQJp19sVcow8QH6SUMPrV7PKogmCDQGnGmKJ8BFSamj",
				image: splitStringForCardano('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcIAAAEsCAYAAABQVrO3AAAgAElEQVR4nO1cbZbjIA7MIfpefYU5295jzub9sUMWK5KQ+BDCKd7juROXkUpAVUj3zOv1el2l//z+593r96UOPPDAAw888A/AH5Mo8MADDzzwwK/AH5Mo8MADDzzwwK/Ap0sIeOCBBx544CPxxyQKPPDAAw888DBC4IEHHnjggV9mhEkSAh544IEHHvhI/DGJAg888MB/Lb6nZ8o/Of6YRIEHHnjgvw5//f1zdbW/f0x5ZOO7CZ8uIeCBBx74r8R3m94ic8xWn4X4YxIFHnjggX8cfrn5DZri7voE4Y9JFHjggQf+8XhPHzbRv3+ahpitPsuNMElCwAMPPPDAO/HF1EzmWDD1M/8M8RS+k/HHJAo88MADD3wDP2qIllwy8Z2EPyZR4IEHHnjgjXjWEIWTIHcy3J3/NiNMkhDwwAP/YLy3Z8v/NDx7MqwNUTDGLPkH4Y9JFHjggU+I57r5a7mqS3Gz8T0Z3zoJ0vnIlv9C/DGJAg888Mnw5r9aNJpeK6fZ2JHxT8LX929flzrN8BS+Hfh0CQEPPPAJ8aX3mJ9HrFcYQC/X8ozl92fZ5qvG0metp8Ly7El8O/HHJAo88MBvxI8Y4Mr8LVg6vtcQ6TicIWabL8kIPWZYj3UKXxgh8MADPx2/2gBH8veMLz3ba4w9/13Zjvmlz5Y+eirMsj4n4dMlBDzwwG/Elz7yBy878u/h2WuCXMysf3VJc+sxwjJOhvW5CH9MosADD3wAvnQYoS83GGEOvp34YxIFHnjgA/A9Blj/hWFk/vU9qVtj0DEtz7XG7Pn6dHZ9uHny/DMKrkYnrWe3ESZJCHjggd+E95qgFmt1/q0xesxxlgnSMbm/OI2YX4/heY3whPXswB+TKPDAA78A/3r1/0HMzvylMehYPcaoif5IflFfmc4yQc68s69nGCHwwAPvwr9ea0wwIn/6zKj5Wca35qX1+i8xV9RnpglyHwgyr+cpRpgkIeCBBz4IP8MEIwxPG6P0+vdf9XXUFGeaYD3mivrMNEHu95uWnE5a/1WPDTy6KK2b4r05gpt140l8vc96G1e/lfy88zVj/nq59fAb7V4+lm6uzaST4Goha60fyQC5a8sctZiz8ufGHK1PzQ9G2IWPDdwrnp6NMSqkI61HDL31GeHH1W8lP+98zZi/Xm49/Ea7l4+lW8Yym+B1Nb8OXS1k0rqpTY3D9ZwMW3mN6JQ03kiMwm9F5+Jz5hi9Hhbh9ySkLTzvJtXGj249G67w4H53MMsobrUVPvXN4vexeQg/65romT8unqetMLsefjP2g3S/xwTp2owUrI+aCQZYGwPFWce25mjhY+09Y3I86cl3tgmWtbjDLwLwewKzZvCvcQuf25y3+4KJeBs7+Y5mFcB6bMq1VS8vv7KAb3WsXztMw8Lplpdhs43yKxxb9bQ0r5F51rmV38z9MNyEuVqpD1otW6dAirHG9+Ct68DbvblqRlivgx4TlPKAEU4OTJ+dtfF7hbQ0dvIdzSug9BkYIYxw5n7obszaWK0PWg2puXE46STYMy/WOfbyGu0cz5mG2OL1FUYYkRB3j252uiFvkykJQ4cRshNdxZQ4aM26sVjhId2yeS2tLGDOCL3CaeHE5kg2Wj13mlCZ+dEm1LOXn7T2Syzrmtf4rdgP3Y0xwmh9qMWce8aCbe4fwTws82/l6+nS3uBwNNeWId7WTYcJzpjfxPjYwNw9buNLm7u18a1C+nq92DG58bk4JW/aLJtPerYIjyYMVn4iV8aQbrhGM/OpjZa+FjaiZ/4++EmN1LOH35vj4Hppzd+K/dDdmJP7an2QatjaS/XccPe0cS0GKMWc3Vt5S3jJELnXvSZYahztF4H4fUYoCakmKq2NbxHS98ZhNr4a23DCMG3ahgDVtZJqpvET+UqnshrXaOL80XpWfLR69sxfnW9PPafw61wv5vXZyCnyRLhKH6QxqHBL9+pnJUHn6lKPo12tBtFbB2mfc+9768a95vh5OH6NEUYm9CE0kza+WWhghB9jNHMT+LH1rPho9eyZvzrfnnpO4fcNRqicaGfqgyTWVLil/UTva+Nqc2aNN0MLtf3N3eeulvpJXKTTcyvXhAY2C7/fCKUFYe3a+KLQSMJNhYCIwmojpIu1VRetcYuY401x1vxqXrfaaI0x5JVGyNWzm5+FF+HYY4SF2+h+GGrVHO3UB2pMdD1zwk7HkszPi2lxsfDkcq/fp/elK43FcbAYoHVuuNNg5HoIwH+fERahMQs3EQdNaEwCxcVkTkizjNC6yYeNguFgEZlhI3TW08vvg6PWlPXiXZ+j+6GrETOP0gdJB6xG2KsllrUp4Sw1sPKUuHFXep+ObTFE7zwmMKrV+NiEtAkZ3fheoYERfm56iZfG71ZLGOFHDr3rc3Q/dDXFCGfrg8Uc6jnkhLm3Rpa9YFm7Ht7WfClPOj6H4cYfNcB6f3GxIvwiEJ/PCGmr3+MWrDa21noXqNZMzwtfnVm/TvPy83xd2cuv5lXmxSImM+bPW88efprgWATNO38z9kNXY+q1Qh/os1Kt6Fee9BmK0U5DnjVpWQPeblkzlCd3le5bYnhzphoU7ReB+DxGKH7irt6bKaR1qyeeboT3PUOzLnCLaNcL3SuklJsmqrc5mMCPOx1KgjPCr7eevfw0rtI8t7rGbXQ/dLWAEyEVcnX/EiPk7msfvrhvBaS1udIAreuBi8vVyVPH3ry5/RntF4H4PQlxk5XCCJk49J7WrOLJbWSJW4+QUm63zS/kaeFo3bwekejl11vPUX7cmuDuWcaxzNlHW2GExACpEdaiPFsf1PoIRqgZXE+nsbzzKfGyrgNtXHql47fueTtdRyv0PyEeRnhdMML3HAzw86wFy5po8eut5yg/bk1w9yzjWObso8EIYYTktXbP2+k6WmQ82fAwwuuKMcIbV44j2dyWTWTlVucnfR1k4Wjm1zCkVfxa9ZzBj1sTXuFs8ZuxH7oaMcQRcbXoQz0/2prh1g/brRwNhliu3FxyuXr0zrPO6Njca+/caHMxc34PwscmZBHP3o3fK6TXFWuEtzHJhmrx8fC7xahqeRMThusoP24uORGxcLQ2Sz0tzT1/zHMz5m/GfjA14SRY13GF6NbCK8XluLHPjLaGMXJ5cPcsOtfby5g0hvbaMw/asxLHh+FhhNcFI7zNwyA/bi45IbFwtDZLPS3NPX/MczPmb8Z+6GqMMbb2uLfX41iM+LZeZxqgxL9xQrRwo3MyUi9aM/q69X6vASYzKhjh442wem6WEYr1bBhhS0it3LYaoVBPS3PPH/Pc0vm7rtATIXcq7BHZ+jX9+ZaLED/EBGldBENsrQturVvXVWtcWmPt9QwtT2RUq/F7EtIWkLhZL/mPPKTxrc0ibJZmXdQrjaI2hFZ+13WJn745zi1e72caXy/Vou3lJ/I11LPVPMLUWi+WcTROo/uhq9XGWK6LzZB+Y9Hskc1piLd5m2SCtPbaXHBYaZykhrQLv98Iy2aYsVgyC+lboLTNzHytZxVSdXxhU3pPF+oc1rEM/GiMFj/aeuupNes6i/ggM2M/aHX5uDa6Z697jPBWB6sRRhoiU6Myz+rcTjBCqwFSjHeuDjAqGKFn0XiEtDQYIZ87jFBfr0cboVKvj6tyuu8xwuba2W2Ajg8J4rxOMkGu1lrd6T3LPB1iVHFGGJGQuhGYxaONz2F7hZTipcXdK6Qfzxk3So9RcDmqMQSMZ5xIfizHjnhcawlTz3qx1J7lNmE/iK3jRDhD3LlcS03pXG43RNqUWnH8emvV0kqt1+s7icGcgk9khP8avfeBFRbgiBFysemiHjZCcoqoN5gWd9gojF/hFFyPUfTwK7G7+Q3W08PvVhfnelFr35q763M/iHXwGKHUJpyGWjXh1tutFlEGyHF11qDmcfuA1GmErfVS7sMIYYQwQgM/GCGMUF2rHWK/orO5Wp/neMxoA8Yo7amZndNUqwkmMp5s+D0JaRuW3hMFd9AIS2uJqtUEae6qkBp7j5DWvGjtpY17y+8wft54vfzYNUibg1s6I5SuAWZoMkIuP6X+uzrdax6D6zHC5AZzCn6/EWrPexaBV0ipoLS6pc1cyL1C+m38PPFm8Jux3lv8rPm7uSYwim4jdIzHGqVgVKLJatfJRljWiwUvrbXJxvBt+NjAWvMIlrVZF5RVAEeEG/zALw2/QbHfaoRKvj+/ggnSRvGT+dBxW/Nc8JY5hBEuNsKIhLT2KKEBP/DLyC/Q4JYZocUora1liAXjzIvW2zIvlvlr6W5CgzkFn8MI6UbQxvc0bUFZ480QUvADvxT8jCerjEZoMvLe5okx0Qhfr5fZLGGES/GxgaVW36uf+1jclShYmkVorPFmCSn4gd8ufqwhbu43Q/jHiTMmU+6jbZIhWozwzdlhgpoGH2Y82fCxCUntKUIDfuCXmd9tLyYxQWoKnBGajXxWsxqv0Qgls7MaodXsKDaBwZyCz2mEmjCtEBpLvJlCCn7gt4Pfx37caIBUvD3GEGGE5dqMaTRDiYNn3lpaS7Gr9fxBeBghhBT8voWfuC83GKBkhFru7zpUp0V6epzeOs2QPnObR8ZoLXNm0Vpaq5V6/iB8bEJSoxtf/BT1b/Fcf/+YxMYqNNZ4s4QU/MBvBz/L3l1leB7hrvOluWs5vuviNcTKmMSr0xAplps373xJdaX1SWQwp+BhhBBS8PsWfpa9CyMUrjDCJ+P3G+H7/WrBvBdUEQK6aAeEZiRej5CCH/hl4Wc1J24vzx5bEvGWAdzmi9aHMx2vKWrNYYYU95FPwwhbtdLqc4DxZMPHJlS38j7d3Ooi/rfhy3OtxuXYG88iBuAHfpn5WfZpZKd5WXIsdbCaEY1Vf6hwX//9XMa1GuHHGus4DWr1oe+X1wkM5hR8bOCnCw34gV9mfp79GtF7cqH1eNdF6KIWjRgiY7LaqfRj/hQj7KkXfb+8Tmw82fCxgSWhoQuouZg6vnqaEa9XSMEP/DLwo3vXsm9Xdm8ONeeau9cIb5pkGKN16qO5iXNVza02P6/XizVbax1pTqv0/EH42IQ4oaH3bouTNrL4eoRmJF6PkIIf+GXhp+1VC35m74nxMV8GQ7TE+Kix5UrMrM6PM7r6WUutNSOkePpa+wCQ3JB24WMDS62+97GwlYXnERrpWU88j5CCH/hl42fZv9JeHh1v5vOeE2HrVEhjzDoZfqwtBq/Vocw95S/lfXsWRujFwwghpOD3Lfxm7/dWPG9sbyyrIfbE6jFCbR6sRljPO82J+5l7DSMcMMKIhCSRoQuAbvyWWHiEZiRej5CCH/hl4Re53y1jaPlxz4nGd13q1ZKzVCOvEVJudBxxvsnc0jzqK3ev7sUIV87vw/D7jPA9aYo4cBtfeq4lNKPxWiIDfuCXnV/kfteel8Zp5VnX4V0PYzfpk4BrxZK41VeNf09NuJ/fawhG6MXHBn660IAf+GXmN3u/W5/15kffu/E3nAC5a4trmf+mhjUMkOYtcbfWjLtq9edirtLzB+FjE6pF5t3Kp7uFQjMjnkdIwQ/8MvKbvd8lDH2/zl+7cuNJeO5U9mGUAk7jU+b/PY/MM9Zacz+36iqNw9WXG6t1+l25Hg7G7zfC2yYnn7I4MaBjeYWmN16vkIIf+GXhN3O/S/e5Zy25WThd1/V54qtqQt/7wDvMsDzTwmocSk6WWkrPc1et/jDCQ41Q2/Dcxq+/8+8RmpF4PUIKfuCXhd+s/U4FWYtV56id5OorHVt8vtSrqsmtjlU9vSdDT824Z2jerbnh6kevdZzWvCQ3nmz42ISeLjTgB36Z+c3Y76/Xqxmvfk4zPMkgPnSj4Et9uFZjhPsfp0nDaa2nv+eFiWU1xTKOZ67q02Dv/H4pfp8RSuNJYvAhWgax0fLrjWcVUvADv2z8Rvfvex8zol6PedvzymlQOhnSMbWTIK3nx/v0ZFj/LOTh7VZ+Xl31zNGM+f1ifGxgrRUct5BHhUZbWN54FiEFP/DLyG90/3Lja2JsNT7tZFjuiydBpjYm7D+8eB3pypgaX6221vk5xHiy4WMT0toThAb8wC8zvxn7vRb81jg9JiLWQDkJcvVRcbONz2iI1jko9bNiPfjkhrQLn8cIS6ObTeqW8TRRqHO0xmuNBX7gl5nfjP1uHc9jfPQq8rc2Mo752VGDrJ9t5MZx7ZmvMif1daae0xgrOoxQaJY4lmYRmh5eI0IKfuC3i9+M/V4bL32u/rn3FFU/Wwu8ywhLa5gNa3zlOtKVMT3zYMHV2FlGyM2JNRfu2VmGb82/A788gGujzu7RDfzALzO/kf3LPSONMWKAXJ3eY0Y3zSDr194xjafCXiOsP6hYx9HmhebTmkePsdXraJcfwQgnN/ADv8z8YITOBiNk84ERwgjVBn7gl5nfqBFaRO/nt/9rUUmElxuh9nVmuTLGoH4lysTw1Nqrrdq11wQtpriqe2MN4mMTerrQgB/4Zea3Yv/2iqp2IhSNcMepkGucITawWr1bHwK8RljqxY3vXQPWvtoYFxskjHBmAz/wy8xvdP9avgKbdRqkZvDz2/kHMyNNOiH++/k2lzQ3UqMbpnHaor3HCKXn3nk44nvmCUYIIwQ/8EvNb2T/0tzNIntdqgFYToQlXqpT4XV95F6///Ge8LxlnfQYYalXPXezjciT4zFGuCjANhOEkIIf+N3byP6tjU56ZuZpkJrjh9Emaq75rD4UWGpvmaO6Ptz7qw2pZy1tMjwJDyOc2cAP/DLzW73f1ZMgvTbMjzstsTEytJL3yLMDX4+W+xyu/r2gda5nmCKMEEYIfuCXkt/I/m39LujnV/hd0nWZDLB1IqxjZzRD13xOPBXW9zhMbYSrO13fRxphREJPFxrwA7/M/Hr3r/QeFVz2j0q41vijkdYfcKQ0w5E8jKdCWnOr5tKfpXGymOAGg4QRzmzgB36Z+Y0YIf2Kje5v9SRY2pNPht4cDKdCrs4e7CrT29m59QkjTCY04Ad+mfn17F8pd/pclyExxvjz+x/VALn8UhjiaGzhd6LSHHneL7VZbY6WdZLeCBcF2GaCEFLwA797692/t5zJCaZ+3/XVaEev49PcbznsMMWeeORU2JoLyrfXCE/onvU5AQ8jnNnAD/wy8xvdv7UhUZG9rmvKiVAyPutfVdZ5hhpi54nYWv+WMbbeozWSsDtMDEb4MKEBP/DLzG+GEVJ8l+l0/q7Qc0IUTXGVMRr+0EXrM02vZYQn9J71OYCPTejpQgN+4JeZX+/+pXmzRnhdYyfCcjWeDC3Gw/FaZYr1+Lc5duZpNcGe9+l9S+xZZmbluskgYYQzG/iBX2Z+I0bICefPb6exTDoRWk6Ikg5NNcR/v3+7ze1EQ5Tued9/QrfUC0YIIQU/8BNbz/7V9v2wkRhPhLNOiDWX9xxMMMO6Vi0DlPL0muCMexpmtmlZ+W43wkUBtpkghBT8wO/eRvYvJ6IfJrL5ROg9IX7MR89Xu9VpsB7XY4jlZ1pn7v0ZRnhC967PQTyMcGYDP/DLzG/mfv8ws57WeSKccUKkvHo4cPWjY1tOhOyptML1GF0xaO1Z69zPMrSR9QYjPEhowA/8MvOrjUMST4r5+f38L88otuskVeUTdTKUzOV938lBM6b6tXl8h3m39FYzwhM6xzvECCMSerrQgB/4ncSPMwxu/9bY8n6mE6HlhChxq3XJm7ukf5o21jw1bEtjR4ywPE+vUcbGzcFmg4QRzmzgB34n8YMRwghhhDDC6Q38wO8p/DgTLP1thId+NSqalJMHrZXFrEYM0GpeI+Nn79wanYBfHoDFQ2jAD/z2//MJunfr1z+/wv/KUhvhdaU/EXLdok8mToaTHa2jhrXqqPa6zI1lDHrdYWSW+VjtRzDCyQ38wO8J/KioXtfFfzWa/ET483v/irR1Iqz5v5/xNiGGFLfXBLXxWkZ4QpfWI4zwQUIDfuC3g19LnLnX33QipGY5PEcTToB0bixz5h1rVo49MTVe2nwtM8JFAbaaYXQDP/A7nV/LBAvmtBOhpEvlNeX75jmjDRqiljftTzgNRvlR1WMDRzcIG/iBn7wf6/dqzM+vboIspqdtOBFKBkP5lPe7uQl8uXmwGCC9SoZoMUJpTE9uI0Y2ElNbzzBCoUFIwQ/87J3uX81o3iZx2IlQMpoPPv8MZXhd0NpUuc2YL/rBZLWR7e4S/2lGuCjAfaKCG4QU/MBP3qf1e/T+h8ExJjH1RBjwlSjlSN9XDX+0GU6/1nnr1eD6mXrO6TXK0LSYXm6DeBghhBT8voWfpX8YodDfe7rHDBefBC0nQo53k2dP406E5Frn1dJajov0YebkrvGEETobhBT8wM8unPXrn9/2V6Mf5uFtk0+EJef6KtWAe5/j/HHPy43j+u/K1d96SrTOcctU63m3PD/T6LTYHk5TjTDCmaMbhBT8wM/f6T7WzPADo7XJxjfzRFjutbjeOHKcDa/rPLQPHXQ+LKb29O7la8TDCCGk4Pct/Li9qr3+EOnrEk+GHzitLTLEkoOlBtK9Gw/PydBpgFwcet86R9r7kjZL3HcYmye2tp5hhEKDkIIf+PX1D9FXTiwfeO1rweCToHQCM/FW+JoM/x9nbWx6z/MhxWuET+h0rqYb4aIAN3x0g5CCH/jJ+7QlthbDYfd5jatbbYjlGnQitBphwbI8hLE1w/zAMeO0PlxYDO/6+8ek1Z71EWVsEk9PXoN4GCGEFPy+hZ+nq0Z4Xc2v9aJOf1ZD9BqDauqK2d3WE3dqrPJrcaA11fRVM8KW6WTs0tzBCDsahBT8wE/ep/Q97vVNuK/LdUp8P7f4JDj7RFg/c+NAjU04AUoG2MvFanAWrbaujR3Gl8IIFwW49egGIQU/8OvrnCFe12UW8TLG+9nDToRNDp42wMFidpbTYD0GvZ7UpTkdxMMIIaTg9y38JGFsie3Pr8HMros9FbrGSHYirJ9V85faJC6a3rZMsGdd7DI4GOGiBiEFP/Ab60VsW+bXEvXdhthrgvXzEbnXHOq8pQ8WHoOpeXjMJ1Pn5nSqES4KcJ+4hwsN+IFfZn6aSGqvWaO5rm5h//ldYyhlXI37aP3eayXACEcM0MN3t7lJa8+T3yAeRgghBb9v4QcjhBFa1gWMcHHgpwsN+IFfZn49vRbf8loV8eu6X4PNUDLEGUYojTM79zpOrwG2uHLmk6lzNQ8xwoiEni404Ad+mflxe9Xz+r2PNRO8Ltcp5+d3npGUsTTuM2v5sX4WnQCleyNG2FobO4xvo0HCCCGk4Pct/Ea6ZITv2gmnQKv4v8dIfiKUasKuJ+Ppzxqjx0As41viZOme2sAINwkN+IFfZn4tEbW+/vkl/9B+gnHNMMQ6L4n76trOniOrAXKvZ8bL0r25G/HLA9wX+MOFBvzALzO/Wf324dZqVNelnhq5sX9++0yxPMflHFkbL95ifFwMTZtn5vAAw5PwMMKZHfzALzM/SVx7X3NG+K6lZID0qnxV6DXEgtO476y31wg8BljjonOFETrxTxca8AO/zPxmd2qE7zpyJ0GjkZVxRQ1JfiKcUVPNCGl9uNcjcbN0b26D+NiEni404Ad+mflxe3XktSS8XgP0/h5RMsXyXnRde+dCuvYY4KjJ7za+zQYJI5zZwQ/8MvOb3aX9322E5ZnSjKZIjbH8vLs+IzUtP0tXDjdzHrN2b95GPIxwZgc/8MvMj9urs1///A78Jel1fRphuTq+To2u6+ic0KvFCGdw3m1qKY1wUYAb/ulCA37gl5nfyv7e46MGKBlhuSpmWOdyqjFyNdUM8Klm6M1xEA8jnNnBD/wy8+P25OzXU4yw83eIXD6SPkXXXpsTetUMUOJY3x9ZE1m6N8dB/J7AUf3pwgZ+4JeF3xQjHOjW2HW+u/XJWlPNLGfEyNi9OQ7iYxOC0IAf+O3jx+3Hma/dZnhd04zwNmbdDF+n7tQpzeRa1xmxT+ve/I14GOHMBn7g9838JEOsf15uhB1fp9a5Ux47dKvOiV5n5bTb0GCEEBrwA78t/Lj9OPM1fa/WAdYUr2vNKZBrja9Jb3kRTISOcbWTjPC9fhhD98Y8rXvzN+KXB9hmghBS8AO/vfzq/V+bynQjHDgR9jwTpW/Shw8ub894EodMXVpHi/AwwpOFBvzAz9O4PTnztYap3//5nfS/z2htxljOr1VH9I+rkVbj9xpyGqE0ZrY+Ul8YIYQU/MAvDb+6Uy3YeRKceaIs3Dz8R0yBi2c1wvrZ3UaX1ggjEoLQgB/47ePH7ceZrz2Yn99BM5Ra4Di3uTRg6u7VQ4/ZaX23wSU1SBjhzAZ+4JeZH4wQRrjbyGCEMELwA7+v4if1Wg88X0Pu/BpUMznVWJ0Gya6Tzue02p/avVyM+OUBtpngNwgN+IGfp3F7cubr3jE0s7vVi5qN9Lr3NLjRTDnuM0y07rtNLIHhSXgY4cwGfuAHfvZOtUHTid2nP7ep1i2JGe42NxghjBD8wG87P25Pznzd+0xLK16v16fpaK97zGuzkYprZNAIdxvacUYYkdDThQb8wA/8+npLQ3Yblfs0OMkI32vlC80w0CBhhDMb+IFfZn7cfpz5etWY5f0ZJy7WwHYbqdEce4xwt3HBCIVN8mShAT/wA7+5vdaP6Ua46kS4yAxbRkh1drdpHWmEiwJsM8FvEBrwAz9Po/uxvtKfe17PGEPTk5/f//97Ovper5lc17X95NeTv7SmdhtVcsOT8DDCmQ38wO8kfrv2ZW9v6Qs1D5MRzj4RBhjhSJ1O6V4+g3gY4UqhAT/wy8SP7sf6Ku1Zz+ueZ6z64dEYTXN2n+5GjdDSd5vYzLm08hnExyb0dKEBP/A7id+OPTmz10ZarhbNmWFM7KkwgRnuNrBDDRJGuFJowA/8MvGje1EzEGlva68tGE+8WcJJtWeJEW44FVJd3W1SUfPp4WvExwZ+utCAH/idwm/HflzVqeHVV0mDRg0pgxFKHNDwZ+QAAA6lSURBVJ/cvdyN+OUBtpngbqEBP/DLxq/ei5pZfEv/+f3/H5/ACHP1EX/pwO8J/FShAT/wO4Xfrj05q5f8PVf6M8V4jbD+2WtqHqPVavDU7uU5iIcRrhIa8AO/bPw48d8teJm6x6g+5nLC16vcmPXrWkd312p1p7wX42MTerrQgB/4ncJvx37s7SXX0asVW362muB7Ph0mSmNY6/Dt3VsPIx5GuEpowA/8svGr9yEVfvS2nrnmtmGgLb2U8N/evTUx4mMDP11owA/8TuG3Yz+2esmp1ouZVy9W0ziPDlKO6ImNcFGAG37nxn+6sIEf+LV69H4HHvhD8LGBny404Ad+mfkdJEzAAx+Jjw38dKEBP/DLzO8gYQIe+Eh8bEJPFxrwA7/M/BIKEPDAZ8DHBn660IAf+GXmd5AwAQ98JD428NOFBvzALzO/g4QJeOAj8bEJPV1owA/8MvNLKEDAA58BHxv46UIDfuCXmd9BwgQ88JH42MBPFxrwA7/M/A4SJuCBj8THJvR0oQE/8MvML6EAAQ98Bnxs4KcLDfiBX2Z+BwkT8MBH4mMDP11owA/8MvM7SJiABz4SH5vQ04UG/MAvM7+EAgQ88BnwsYGfLjTgB36Z+R0kTMADH4mPDfx0oQE/8MvM7yBhAh74SHxsQk8XGvADv8z8EgoQ8MBnwMcGfrrQgB/4ZeZ3kDABD3wkPjbw04UG/MAvM7+DhAl44CPxsQk9XWjAD/wy80soQMADnwEfG/jpQgN+4JeZ30HCBDzwkfjYwE8XGvADv8z8DhIm4IGPxMcm9HShAT/wy8wvoQABD3wGfGzgpwsN+IFfZn4HCRPwwEfiYwM/XWjAD/wy8ztImIAHPhIfm9DThQb8wC8zv4QCBDzwGfCxgZ8uNOAHfpn5HSRMwAMfiY8N/HShAT/wy8zvIGECHvhIfGxCTxca8AO/zPwSChDwwGfAxwa2btIIYavjRQgb+IHfbn4HCRPwwEfiYwM/XWjAD/wy8ztImIAHPhK/JyFOZGox6h3HKjSeeJ4GfuCXmV9CAQIe+Az4PYFZofn757r+/vl4prx//f1zizUsNM54lgZ+4JeZ30HCBDzwkfg9gZ8qNOAHfpn5HSRMwAMfiY9NyCs0198//9vB1eZvjTUiNFq8FUIKfuAXyS+hAAEPfAZ8bOAuoSG9Ndaw0Ajxlgkp+IFfEL+DhAl44CPxsYGtQiM9X74OKvdmCY013iwhBT/w28HvIGECHvhI/J6Enio04Ad+mfklFCDggc+A3xP4Q2QqEaqxRQjqr4JGhWYkXo+Qgh/4ZeF3kDABD3wkfk/g+pn35md+J1I2f73ppfFaQjMaz9LAD/wy8ztImIAHfo8RRiT0dKEBP/DLzC+hAAEPfAZ8bGBWaKqvd8r7WjwO5xKagXhdQgp+4JeE30HCBDzwkfjYwNo97o8D3o35BEzHswrNSLweIQU/8MvC7yBhAh74SPyehGh/vfiNXza/FMcjNFQQeuJ5hBT8wC8bv4QCBDzwGfB7Aj9VaMAP/DLzO0iYgAc+Er8nMPestvG9Y2pCMxKvR0jBD/yy8DtImIAHPhIfm5AmMNpfybXiWIRmNJ6lgR/4ZeYXvd+BB/4QfGzgpwsN+IFfZn4bhQZ44DPjYwPX75eNTl9T/AyhmRHPI6TgB34Z+W0UGuCBz4zflxDd6NxYnBhw43mEpjder5CCH/hl4bdzvwMPfGL8vkTrT8DShpc+FRd8j9CMxOsRUvADvyz8DhIm4IGPxO9L9IlCA37gl5nfQcIEPPCR+NiELONIYsCNReNpQjMrnlVIwQ/8svHTnq/HSSxYwAO/Ah8bWBOFGlN/+pXieoRGEwVvPIuQgh/4ZeR3kDABD3wkPjbw04UG/MAvM7+DhAl44CPxexJqCc4snKV54rUa+IFfZn4JBQh44DPg9wS2bOoZ41mbJZ6lgR/4ZeZ3kDABD3wkPjbwrE1fd61ZhW1W72lWLjP4teZxNj/vfI3yoxwj5m+k9c6ZdV9aa5NQmIAHPhIfm5ClWWJYx+wR0pHe07z1GeHXmq/Z/LzzNcpPE/tV8zfSeufMuv96xgIe+C/ExwaWGn3+/ccBXBP+cKBXaGZ2b3u9Pv883tO85uC918PvY86VP/+fxe9WPxJv5fyNttZ8jeyH1rjJhQl44CPxsYG5Rt/nxquFQBJwbvweIdX4zBLSdz2Yfxyt1aqHX82BPuc1DQunwqseW6v1KL/bWEo9Z84fx9kzbxq/mfvBsr6TChPwwEfiYxOSxGTWxrcIjUVQJZ6zhLSMDSOEEXJctBie/aCt7yQCBDzwGfCxgbkNTjf7dV0fX/XUQiXl8X62ITRazuUZK+8eIX29Pv/LLIsgWoWUG4fmx91rcdP41Zw+aqp8NVq/N8LPWs9efoVjz3qxzt+K/aCt+eTCBDzwkfjYwJywUPHkxPS98ZV7r5fdCKUxufG5OJS/RUhr3u/GCPitFo1mNQpNEGsD6zGKegzu/8u0njo98yc+16hnD7/CcXS9tOZvxX7Q5j25MAEPfCQ+NiGLkGpjzjDC8owk3BofbhyLkBaeb65G4ZZqpvFr5SmNr3HV+H3Us+LFxZNys84fZxyeeg7zG1gvFn4z94NUs0QCBDzwGfCxgSWhgRHCCK3zR3nACOX9INXsAGECHvhIfGxgqVnGbXWuacYgiWctdNoffFCukpBSjlw8TvQk8Wzxa4n0LSZT+16jqGt2a8Lv7mg8jquFn7eevfw4Pt71YuU3Yz/0jgs88F+Ij01IapbnW51rFhOTRLuImnQKsAop5fhhRsrv0CReLX40T+v8SLwsRsFxsMTvMQrKz1NPLz/KsXe9eOZvxn5ojZtEgIAHPgM+NrAmNKPdKzSjwuYR0pqjV7i1ZjUK6/xIvDR+XM70Z8s64rha+cEI9f3JjZtcmIAHPhIfG1gTmtK5r7ek35f0Cs2I2PQIac1Re57LUWtuoxDEe6ZRcD9rtRydP289R+fP23vmb8Z+aI2bXJiABz4SH5uQRUi1T9lcLG1sj0DWObR4jQqpJ6ceIfWIqicvCz8aW6vnCL/eevby07hy/CxNy3V0P7RqlkSAgAc+Az42sCYsoxvfK6Rcnpa/1JthFHRMKZ5WMys/GkfiZ+FoaZY10loPFn699RzlV3PU1oulWeYMRgg88MvxsYE1YRnd+F4h5fKEEcIIPRxhhMAD/wh8bEKasIxufK+QcvmvNMKaq+WPOyROXn6Ul2QiFo5Wfi1DWsWvVc8Z/ArH1nqxNI3T6H7Q1nkiAQIe+Az42MAW8Xy6EdZCSuO3+Hj43epe1ZLW2sPTyo3OJTe+haN3/rR6rpg/GCHwwD8CHxvYI54wwn4hpWPCCGGEdJ8mFybggY/ExybkEc9vMcI6XovPqJBy96R69vLjYnN1tHD0zp9WzxXzd7IRJhEg4IHPgI8N3BIWDlMLlBbXIzSSQET9jnClUZQxqIByvOjv02h8Dz9uTG3NWDha585azxnzR7muMsLR/dAaN7kwAQ98JD42sCQq1rFb3So0qpASgZklpPV4nEnVJ7a6JlYh1caX5kMyDzonLX6v14s9sWj8aIwWP0nUvfUcNULPemk1bT3O2A8wQuCBdxphREKasFjGaHWPkMIIYYTfbIRJBAh44DPgYwNrIuoZq4xH3+sV0vfzjLBRXI+QvsduGJPG0SOkra9EbzVzfB2cgR/HsSee1wh714vWNG4z9gOMEHjgTfjYwBYRpc9RrBbXKqRUEK1mQF97jOKNaZySaFyJm8avrmlrfixCuYJfeaaX32g9PfwKx571orXW3EkndWk9alhtfhMKE/DAR+JjE5IEBkYox9Vqp3GDEer19PArHHvWi9Zac7fSCJMIEPDAZ8DHBpYEZocRWkVVEp0RIbV2qWYWfq25sWKy8/PG6+VX87Sul1YTawIjBB74SHxs4JaItvBaXK+QjvAaFVJr7xHSb+PniTeDn5WjpXk5ebjPWAfAA/8l+HQJAQ888MADD3wk/phEgQceeOCBB34F/phEgQceeOCBB34FPl1CwAMPPPDAAx+JPyZR4IEHHnjggYcRAg888MADD/wyI0ySEPDAAw888MBH4o9JFHjggX8ovsZqfVY+3j7Kd0aczPV8AP6YRIEHHviH4qOF29tH+c6Ik7meD8CnSwh44IH/IvxsU2phR+ON8J3NNUM9H4I/JlHggQf+YfgVJiFhZsWz8l3JMUM9H4Y/JlHggQf+YfhI4Z4Vz8p3JccM9XwYPl1CwAMP/BfgZwl4lGF4+c6Ol7me3hwSrs88GwN44IH/HvxO4V4Rg2Jnx8tcT28OCddnno0BPPDAfw9+p3CviEGxs+Nlrqc3h4TrM11CwAMP/JfgV4i1hJkVz8p3JccM9fTmkmG9KbhcGwN44IH/HnykcM+KZ+W7kmOGenpzybDeFFyujQE88MB/Dz5SuGfFs/JdyTFDPb25ZFhvCi5dQsADD/wX4GcJeJRhePnOjpe5nt4cEq7PPBsDeOCB/x78TuFeEYNiZ8fLXM8H4I9JFHjggX8gvlekR/KJNIZZsTLX8wH4dAkBDzzwX4YfNQlvPiPxRvKxxDuxng/AH5Mo8MAD/1B8tHCPxBvJxxLvxHo+AH9MosADDzzwwAO/1giTJAQ88MADDzzwkfhjEgUeeOCBBx74FfhjEgUeeOCBBx74Ffh0CQEPPPDAAw98JP6YRIEHHnjggQceRgg88MADDzzwy4wwSULAAw888MADH4k/JlHggQceeOCBX4E/JlHggQceeOCBX4FPlxDwwAMPPPDAR+KPSRR44IEHHnjgYYTAAw888MADv8wIkyQEPPDAAw888JH4YxIFHnjggQce+BX4YxIFHnjggQce+BX4dAkBDzzwwAMPfCT+mESBBx544IEHHkYIPPDAAw888MuMMElCwAMPPPDAAx+JPyZR4IEHHnjggV+BPyZR4IEHHnjggV+BT5cQ8MADDzzwwEfij0kUeOCBBx544GGEwAMPPPDAAz8T/1/gO7/+V+v1dQAAAABJRU5ErkJggg=='),
				
				"mediaType": "image/png",
				"name": "TODO choose name of thumbnail"
			}
		}
	}
};

/*
https://pro.nft-maker.io/projects
{
  "type": "all",
  "scripts": [
    {
      "type": "sig",
      "keyHash": "37413c025ae57be5273cdb158f13aa3063a603fb71c87129121c8d39"
    }
  ]
}
ce429b833be000d4da1cc9bb631 04cba87533b86109d28b0185b6997 but without the space.
*/
//var cardanoPolicyId = 'ce429b833be000d4da1cc9bb63104cba87533b86109d28b0185b6997';

var exampleCardanoMap2 = {
	"721": {
		//"e09e4f4217669b7f735b7a3724e835d8d6344db128eb03d6ea72885e": {
		//(cardanoPolicyId): {
		ce429b833be000d4da1cc9bb63104cba87533b86109d28b0185b6997: { //replace this multiple places
			"genereef": {
				
				//"~license": splitStringForCardano("You own the moving shape/color combo. Some code from opensourceMIT https://github.com/benrayfield/augmentedballs"),
				"files": [
					{
						"mediaType": "text/html",
						"name": "GeneReef_TEST",
						"src": [
							"data:text/html,<ht",
							"ml><head><scr",
							"ipt>window.o",
							"nload=function(){document.getElementById('xyz').va",
							"lue='hello,%20this%20dataurl%20is%20'+win",
							"dow.location;}</scr",
							"ipt></head><body><texta",
							"rea%20id=xyz%20rows=7%20cols=50>aabb</text",
							"area></body></ht",
							"ml>"
						]
					}
				],
				
				//"description": "GeneReef", //I moved description down to make sure it gets sorted to the top (description files license image... <abc order>)
				//"~description": "A collection of 8,888 Corals growing, evolving, & fully stored on the #Cardano Blockchain. Moving art. Reef/coral-like physics sim of a curvy line as a neuralnet paintbrush. Many parameters tuned by hand per species, including hand painted loops of varying parts of potential-energy equation over time, and other parts generated. Some species were evolved by harmony-search and some manually modified after that. Like 3body, small changes in timing or starting shape lead to different outcomes.", //I moved description down to make sure it gets sorted to the top (description files license image... <abc order>)
				//"~description": splitStringForCardano("A collection of 8,888 Corals/reefs growing by neuralnet paintbrush, evolving, & fully stored on the #Cardano Blockchain."), //I moved description down to make sure it gets sorted to the top (description files license image... <abc order>)
				//"~description": splitStringForCardano("A collection of 8888 Corals growing by physics and neuralnet paintbrush, some evolved, & fully stored on the #Cardano Blockchain."), //I moved description down to make sure it gets sorted to the top (description files license image... <abc order>)
				
				//image: 'ipfs://QmXiQJp19sVcow8QH6SUMPrV7PKogmCDQGnGmKJ8BFSamj', //png. from chess experiment earlier project.
				//"mediaType": "image/png",
				image: 'ipfs://QmdBYWqvXrsR4D36aGAb2sja8fTcY4nyCnnKJJFGYjUTSn', //geneReefIconFromTwitter(QmdBYWqvXrsR4D36aGAb2sja8fTcY4nyCnnKJJFGYjUTSn).jpg aka  https://twitter.com/GeneReefs/photo Its a jpg.
				"mediaType": "image/jpeg",
				
				//"name": "GeneReef",
				//image2: 'sha256://TODOsadfasdfasdfsdf',
				
				/*
				image: splitStringForCardano(		'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAFA3PEY8MlBGQUZaVVBfeMiCeG5uePWvuZHI////////////////////////////////////////////////////2wBDAVVaWnhpeOuCguv/////////////////////////////////////////////////////////////////////////wAARCABAAEADAREAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAQIDAAT/xAApEAEAAgEDBAEDBAMAAAAAAAABAhEAEiExAyJBUXETMmFCgaGxkcHw/8QAGAEAAwEBAAAAAAAAAAAAAAAAAAECAwT/xAAnEQACAgIBAgYCAwAAAAAAAAAAAQIRITESQVEDYYGRsfAToSJx8f/aAAwDAQACEQMRAD8A4sANgAxB1BIS/wAYJpivGAzgRaJXTTtjaCLs2i/t3yL7ltYtCpTTlEgwA2AGwAeAlSK+HE+xXDkivIAoSNr8JkGGt9N+onU5utpbmawdpxKj8DRO6RVx/GZs08R8f4iyQiGn5fbm0UqzozSe/YRhKIKbOZ2ik0xcYwkWXBgJtIp42Kv9sXF9TZSTWBo90Wmn7o/Jzk6f6M5xt8u6DJPpkzfe/i+f5yliVmcHxkLE1apEntK25cTxg1k0/RBjGQvmQfsY8y/oylPlvQeqxl0tpRu7o84lGmTG0znyjUr0rbKEltS1eHKhON5KfTtb6co16kP94fkRGV1Qk4aI6o2HqWTabwVGb0xjpF07z5Q4PnKwiHNvPT7oVvp3KDW9U+HBxTKTvDNCc4jSt78Zpxr/AAbhy6Dzmy6TGmva5L0EfBads55FOSjSSofpxlMQCje3xjRLmoqmH6W/3dN/A5XsRz8n7BmQjCRff6MToSbbvoNJFlPmLXHJkyTeUSl06/IJSGtTr9Bsf9/WS235Fwj2QrUSzUb7l403o2aaWMFEgjpjVl2xXJSk3kxU2u3uR6ox6iNbesuqLUuSsPTnp7UJC8OHQmUbyVntHS1Xqq/xma7kRTbF1mhgRBdvg/3jUbZuo1jqKdsr6aiHznQ44tE+Jx0btmaj7vMff5zN5Ji3F09C/p2ib8ZBv0wtlCSCWumi7zSDvZEvDjTojJZSWTbieyEqWAYhjm4b7nleMlmkVjHqE4PXOBa1+/vyVOmsGIg1a1vv4zRao43LNv75m1PY7XE1bevP74Crfnj1JzNM5RsKdshqmb+HK47+9RGVSWO2VFuI5POBcRJsANgAxJ4dzChuTaorLqgdraytK/jKsyUe/YWfVNtFiN7+MVjUe5OUmUlW1xFJVhAwGbAD/9k='
				),
				"mediaType": "image/jpeg",
				"name": "GeneReef icon"
				*/
			}
		},
		version: "1.0"
	}
};





var prefixHtml = "<ht"+"ml><he"+"ad><sc"+"ript>"; //TODO

//(options)

var nonminifiedJavascript = 'var builder=false;var seed=BigInt64Array.of(0n);var setColorSeed=sss=>{seed[0]=(BigInt(sss)^0x5DEECE66Dn)&((1n<<48n)-1n);};var pseudorandomNext=bits1To32=>{seed[0]=(seed[0]*0x5DEECE66Dn+0xBn)&((1n<<48n)-1n);let retLong=(seed[0]>>(48n-BigInt(bits1To32)));return Number(retLong)|0;};var pseudorandomFraction=()=>pseudorandomNext(31)/0x80000000; console.log(\'Uses opensourceMIT AugmentedBalls\');';
//var nonminifiedJavascript = 'var builder=false;var seed=BigInt64Array.of(0n);var setColorSeed=sss=>{seed[0]=(BigInt(sss)^0x5DEECE66Dn)&((1n<<48n)-1n);};var pseudorandomNext=bits1To32=>{seed[0]=(seed[0]*0x5DEECE66Dn+0xBn)&((1n<<48n)-1n);let retLong=(seed[0]>>(48n-BigInt(bits1To32)));return Number(retLong)|0;};var pseudorandomFraction=()=>pseudorandomNext(31)/0x80000000; console.log(\'Uses AugmentedBalls\');';



//make sure to use the custom uglifyjs options at the bottom of this file "let uglifyjsOptions ="
//v697
//var minifiedJavascriptFromUglifyjs = "if(!window.o)throw'No o/options';if(!o.endist)throw'no endist';var t=null,e=t=>JSON.parse(JSON.stringify(t));builder&&buboot(),window.oo={},oo.endist=o.endist,oo.loops=e(o.loops||{}),eval('console.log(JSON.stringify(oo));');var optionIsBit={},optionIsInteger={};for(let t in o){let e=o[t];optionIsBit[t]=!1===e||!0===e,optionIsInteger[t]=Number.isInteger(e),(optionIsBit[t]||'number'==typeof e)&&(oo[t]=o[t])}var i=()=>56+200*pseudorandomFraction(),r=(t,e,r)=>{let s=i(),n=i(),l=i(),h=oo.loops[t],a=new st(t,e,s,n,l);if(r)for(let t=0;t<h.length;t++)a.radius[t]=h[t];return a},s=()=>{for(let t in oo)o.loops[t]?(loops[t]||(loops[t]=r(t,o.loops[t].length)),o[t]=loops[t].sliderOrCheckboxValueNow()):o[t]=oo[t]};const ro=Math.round,mn=Math.min,mx=Math.max,sin=Math.sin,cos=Math.cos,wi=window,px='px',fl=Math.floor,ce=Math.ceil,n=t=>new Float64Array(t),l=t=>new Float32Array(t);var h=0,a=350,u=850,p=100,d=600,c=60;const f=0,v=1,y=2,b=3,x=4;var g=function(t){this.dom=document.createElement('canvas'),this.context=null,this.imageData=null,this.pixels=null,this.byteRect=null,t.appendChild(this.dom);let e=this.dom.style;this.dom.width=10,this.dom.height=10,e.position='absolute',e.left='0px',e.top='0px',e.zIndex=-1e6,this.resizeCanvas=function(t,e,i,r){void 0===t&&(t=0),void 0===e&&(e=mx(10,wi.innerWidth)),void 0===i&&(i=0),void 0===r&&(r=mx(10,wi.innerHeight));let s=e-t,n=r-i,l=this.dom,h=l.style;l.setAttribute('height',n+px),l.setAttribute('width',s+px),h.height=n+px,h.width=s+px,h.top=i+px,h.left=t+px},this.beforePaint=function(){this.context=this.dom.getContext('2d'),this.imageData=this.context.getImageData(0,0,mx(10,this.dom.width),mx(10,this.dom.height)),this.pixels=this.imageData.data,this.byteRect=new m(this.pixels,this.dom.height,this.dom.width)},this.afterPaint=function(){this.context.putImageData(this.imageData,0,0)},this.resizeCanvas(0,10,0,10),this.beforePaint()},m=function(t,e,i){this.b=t,this.h=e,this.w=i},M=m;let P=M.prototype;P.writeSafeRGBA=function(t,e,i,r,s,n){void 0===n&&(n=255);let l=W(0,4*(ro(t)*this.w+ro(e)),this.b.length-4);this.b[l+f]=i,this.b[l+v]=r,this.b[l+y]=s,this.b[l+b]=n};const w=Math.pow(2,38),S=16383,A=1<<24;M.voxelY=(t=>fl(t/w)&S),M.voxelX=(t=>fl(t/A)&S),M.voxelXorRed=(t=>t>>16&255),M.voxelXorGreen=(t=>t>>8&255),M.voxelXorBlue=(t=>255&t),M.voxelYXXorsRGB=((t,e,i,r,s)=>((t&S)<<14|e&S)*A+((255&i)<<16|(255&r)<<8|255&s)),P.writeSafeUndoable2dVoxel=function(t){let e=M.voxelY(t),i=M.voxelX(t),r=M.voxelXorRed(t),s=M.voxelXorGreen(t),n=M.voxelXorBlue(t);this.writeSafeXorRGB(e,i,r,s,n)},P.paintVoxels=function(t){for(let e=0;e<t.length;e++)this.writeSafeUndoable2dVoxel(t[e])},P.undoable2dVoxel=function(t,e,i,r,s){let n=W(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);return M.voxelYXXorsRGB(t,e,i^this.b[n+f],r^this.b[n+v],s^this.b[n+y])},P.writeSafeXorRGB=function(t,e,i,r,s){let n=W(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);this.b[n+f]^=i,this.b[n+v]^=r,this.b[n+y]^=s,this.b[n+b]=255},P.streamUndoable2dVoxelsForLineYXYXRGBSafe=function(t,e,i,r,s,n,l,h,a){let u=r-e,p=s-i,d=Math.hypot(u,p),c=Math.ceil(1.5*d),f=-1,v=-1,y=e,b=i;for(let e=0;e<a;e++){for(let e=0;e<c;e++){let i=ro(y+u*e/c),r=ro(b+p*e/c);i==f&&r==v||(t(this.undoable2dVoxel(i,r,n,l,h)),f=i,v=r)}y+=p/d,b+=u/d}};const C=(t,e,i,r,s)=>{let l=n(i*s);for(let n=0;n<i;n++)for(let i=0;i<s;i++){let h=0;for(let l=0;l<r;l++)h+=t[n*r+l]*e[l*s+i];l[n*s+i]=h}return l};var R=t=>{let e=t[0];for(let i=1;i<t.length;i++)e*=t[i];return e},B=function(t,e){if(this.sizes=t,e)if('function'==typeof e){this.arr=l(R(t));for(let t=0;t<this.arr.length;t++)this.arr[t]=e()}else this.arr=e;else this.arr=l(R(t))};B.prototype.matmul=function(t){return new B([this.sizes[0],t.sizes[1]],C(this.arr,t.arr,this.sizes[0],this.sizes[1],t.sizes[1]))};var F=t=>{let e=[];return e.push(...t),e},D=(t,e,i)=>{let r=t;for(let t=0;t<e.length;t++){r=r.matmul(e[t]);for(let t=0;t<r.arr.length;t++)r.arr[t]=i(r.arr[t])}return r};const sigmoid=t=>.5+.5*Math.tanh(.5*t);var O=t=>{let e=t.sizes[0],i=t.sizes[1],r=e-1;for(let e=0;e<i;e++)t.arr[r*i+e]=e==i-1?100:0};const X=()=>{if(_=!_){let t=0,e=0,i=0;do{i=(t=2*pseudorandomFraction()-1)*t+(e=2*pseudorandomFraction()-1)*e}while(i>=1||0==i);let r=Math.sqrt(-2*Math.log(i)/i);return j=t*r,e*r}return j},V=(t,e)=>Math.exp(-.5*(t*t+e*e)),bell=(t,e,i,r)=>i*Math.exp(-.5*sqr((r-t)/e)),T=t=>Math.floor(pseudorandomFraction()*t);var N=Math.tanh,E=5,G=1+2*E,I=3,z=G*I+1,Y=I,U=t=>{O(t)},k=t=>{for(let e=0;e<t.length;e++)U(t[e])},L=[z,Math.ceil(1.5*z),Y],J=null;const twoPi=2*Math.PI,q=eval('performance.timing.navigationStart'),H=()=>.001*(q+performance.now()),W=(t,e,i)=>mx(t,mn(e,i));var _=!1,j=0;const Z=t=>document.getElementById(t);var K=l(1<<21),Q=(t,e)=>{let i=W(0,512+256*t,1023.99),r=W(0,512+256*e,1023.99),s=fl(i)<<11|fl(r)<<1;return{y:K[s],x:K[s+1]}},putHills=t=>{for(let t=0;t<K.length;t++)K[t]=0;for(let e=0;e<t.length;e+=6)$(t[e],t[e+1],t[e+2],t[e+3],t[e+4],t[e+5])},$=(t,e,i,r,s,n)=>{let l=ce(4*(256*i)),h=et(0,512+256*t,1023),a=et(0,512+256*e,1023);for(let t=h-l;t<h+l;t++)for(let e=a-l;e<a+l;e++){let l=2097151&(t<<11|e<<1),u=l+1,p=(t-h)/256/i,d=(e-a)/256/i,c=V(p,d),f=-r*((V(p+pt,d)-c)/pt),v=-r*((V(p,d+pt)-c)/pt),y=2.5;K[l]=Math.tanh(K[l]/y+c*s+f)*y,K[u]=Math.tanh(K[u]/y+c*n+v)*y}};let tt=function(t,e,i,r,maxDistanceToAffectEachother,addRandomness,maxSpeed,friction,s,h,a,u){if(!s)throw'no points';let p=e;if(t)throw'removed code';{let t=o.accelFieldMul;this.dt=i;let e=dt,d=e.centerY,c=e.centerX,b=e.radius,x=b*o.borderRadiusMul;this.undoableVoxels=[],this.numPoints=s;let g=Math.pow(o.maxDistanceToAffectEachother,2);if(i=mx(-.9,mn(i,.9)),this.yp=n(s),this.xp=n(s),this.yv=n(s),this.xv=n(s),this.red=l(s),this.green=l(s),this.blue=l(s),p){let t=new B([1,z]),e=p,n=p.perimeter(),u=l(s),b=l(s);for(let t=0;t<s;t++){let e=(t+1)%s,i=this.yp[e]-this.yp[t],r=this.xp[e]-this.xp[t],n=Math.hypot(i,r);u[t]=0==n?1:i/n,b[t]=0==n?0:r/n}let m=0;for(let l=0;l<s;l++){this.yp[l]=p.yp[l],this.xp[l]=p.xp[l],l>0&&(m+=Math.hypot(p.yp[l]-p.yp[l-1],p.xp[l]-p.xp[l-1]));for(let e=0;e<G;e++){let i=(e+l-E+s)%s;t.arr[3*e+f]=p.red[i]/127.5-1,t.arr[3*e+v]=p.green[i]/127.5-1,t.arr[3*e+y]=p.blue[i]/127.5-1}t[t.length-1]=1;let M=D(t,h,a),P=ot(127.5+127.5*M.arr[f]),w=ot(127.5+127.5*M.arr[v]),S=ot(127.5+127.5*M.arr[y]),A=mx(0,mn(o.colorDecayPerSec*i,1));this.red[l]=p.red[l]*(1-A)+A*P,this.green[l]=p.green[l]*(1-A)+A*w,this.blue[l]=p.blue[l]*(1-A)+A*S;let C=0,R=0,B=i*o.scalePotentialEnergyForce,F=Q(this.yp[l],this.xp[l]);C+=o.accelFieldMul*B*F.y,R+=o.accelFieldMul*B*F.x;for(let t=0;t<e.numPoints;t++){let i=this.yp[l]-p.yp[t],s=this.xp[l]-p.xp[t],h=i*i+s*s;if(0!=h&&h<=g){let i=t/e.numPoints*n,s=mn(Math.abs(i-m),Math.abs(i+n-m)),a=u[l],p=b[l],f=u[t],v=b[t],y=Math.sqrt(h),g=1-y/maxDistanceToAffectEachother,M=r(this.yp[l],this.xp[l],e.yp[t],e.xp[t],a,p,f,v,d,c,x,s)*g,P=r(this.yp[l]-pt/2,this.xp[l],e.yp[t]+pt/2,e.xp[t],a,p,f,v,d,c,x,s)*g,w=r(this.yp[l],this.xp[l]-pt/2,e.yp[t],e.xp[t]+pt/2,a,p,f,v,d,c,x,s)*g,S=(P-M)/pt,A=(w-M)/pt;C+=S*B,R+=A*B}}let O=addRandomness*Math.sqrt(Math.abs(i));if(0!=addRandomness){let t=(l+1)%s,e=this.yp[t]-this.yp[l],i=this.xp[t]-this.xp[l],r=Math.hypot(e,i);if(0!=r){let t=e/r,s=i/r,n=s,l=-t,h=O*X();C+=n*h,R+=l*h}}this.yv[l]=p.yv[l]+C,this.xv[l]=p.xv[l]+R;let V=Math.hypot(this.yv[l],this.xv[l]);if(0!=V){let t=mx(0,mn(V-friction*i,o.maxSpeed)),e=t/V;this.yv[l]*=e,this.xv[l]*=e}this.yp[l]+=this.yv[l]*i,this.xp[l]+=this.xv[l]*i,o.setSpeedsToZeroAfterEveryDtMove&&(this.xv[l]=this.yv[l]=0)}}else{let t=0,e=0,r=i*addRandomness,n=0,bootShape=eval(o.bootShapeYX||o.bootShape);for(let i=0;i<s;i++){let r=i/s*twoPi,l=cos(r),h=sin(r),a=bootShape(r);'number'==typeof a?(this.yp[i]=a*l,this.xp[i]=a*h):(this.yp[i]=a[0],this.xp[i]=a[1]),this.yp[i]=t+o.bootShapeY+o.bootShapeScale*this.yp[i],this.xp[i]=e+o.bootShapeX+o.bootShapeScale*this.xp[i],this.yv[i]=n*l,this.xv[i]=n*h,this.red[i]=this.green[i]=this.blue[i]=T(256)}u||this.balanceSparsityBoot(),s=this.numPoints}}};const et=(t,e,i)=>ro(mx(t,mn(e,i)));var ot=t=>ro(mx(0,mn(t,255))),it=(t,e,i)=>{let r='000000'+(65536*ot(t)+256*ot(e)+ot(i)).toString(16);return'#'+r.substring(r.length-6)};tt.prototype.balanceSparsity=function(){let t=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue],e=this.numPoints,i=this.perimeterDistances(),r=i[e],s=W(mx(o.minPointsPerCurve,e-o.maxNumPointsPerCurveChangeAtOnce),Math.ceil(r/o.targetDistanceBetweenAdjacentCurvePoints),mn(e+o.maxNumPointsPerCurveChangeAtOnce,o.maxPointsPerCurve)),h=r/s;this.yp=n(s),this.xp=n(s),this.yv=n(s),this.xv=n(s),this.red=l(s),this.green=l(s),this.blue=l(s);let a=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue];this.numPoints=s;let u=0;for(let r=0;r<s;r++){let s=r*h;for(;i[u+1]<s;)u++;let n=(u+1)%e,l=i[u+1]-i[u],p=(s-i[u])/l;for(let e=0;e<t.length;e++)a[e][r]=t[e][u]*(1-p)+p*t[e][n]}return builder&&displayText(this),r};var sqr=t=>t*t;tt.prototype.balanceSparsityBoot=function(){let t=o.maxNumPointsPerCurveChangeAtOnce;o.maxNumPointsPerCurveChangeAtOnce=1e6,this.balanceSparsity(),o.maxNumPointsPerCurveChangeAtOnce=t},tt.prototype.perimeter=function(){let t=this.perimeterDistances();return t[t.length-1]},tt.prototype.perimeterDistances=function(){let t=this.numPoints,e=n(t+1);e[0]=0;for(let i=0;i<t;i++){let r=(i+1)%t,s=Math.hypot(this.yp[r]-this.yp[i],this.xp[r]-this.xp[i]);e[i+1]=e[i]+s}return e},tt.prototype.holdInRect=function(t,e,i,r){for(let s=0;s<this.numPoints;s++)this.yp[s]=W(i,this.yp[s],r),this.xp[s]=W(t,this.xp[s],e)};var rt=t=>JSON.parse(JSON.stringify(t)),st=function(name,t,e,i,r){this.clicks=[],this.name=name,this.radius=new Float32Array(t);let s=.7+.6*pseudorandomFraction();for(let e=0;e<t;e++){let i=2*Math.PI*e/t;this.radius[e]=1+.3*(Math.sin(5*i*s)+Math.sin(7*i*s+.3))}this.red=e,this.green=i,this.blue=r,this.curve=null,this.domLabel=null};st.prototype.sliderOrCheckboxValueNow=function(){let t=oo[this.name]*this.radiusAtAngle(h);return optionIsBit[this.name]?0<t:optionIsInteger[this.name]?Math.round(t)||1:t||pt},st.prototype.radiusAtAngle=function(t){let e=t/twoPi*this.radius.length;(e%=this.radius.length)<0&&(e+=this.radius.length);let i=Math.floor(e),r=(i+1)%this.radius.length,s=e-i;return this.radius[Math.floor(i)]*(1-s)+s*this.radius[r]},st.prototype.color=function(){return it(this.red,this.green,this.blue)},st.prototype.copyRadiusArrayToCurve=function(){let t=this.radius.length;this.curve||(this.curve=vt(t));for(let e=0;e<t;e++){let i=2*Math.PI*e/t-h,r=loopRadiusOfZeroOption+loopRadiusMul*this.radius[e];this.curve.xp[e]=Math.sin(i)*r,this.curve.yp[e]=Math.cos(i)*r,this.curve.red[e]=this.red,this.curve.green[e]=this.green,this.curve.blue[e]=this.blue}};var nt=(e,i,r,s,n)=>{for(let t in loops){let n=loops[t];n.countPaints&&n.paintOrUnpaint(e,i,r,s),n.countPaints=(n.countPaints||0)+1}for(let l in loops)if(!n||l==t){let t=loops[l];t.copyRadiusArrayToCurve(),t.curve.undoableVoxels=[],t.paintOrUnpaint(e,i,r,s)}},ht=function(t,e,i,r,addRandomness){this.curves=t,this.potentialEnergyFunc=e,this.neuralWeights=i,this.neuralFunc=r,this.addRandomness=null};ht.prototype.timePosition=function(){let t=0;for(let e=0;e<this.curves.length;e++)t+=this.curves[e].dt;return t};var at=(t,e)=>{let i=0,r=e-t;if(r>0)i+=r*r*o.stayInsideBorderCircleForce;else{i+=10*(sigmoid(.001*(e/t))-sigmoid(.001))}return i},endist=eval(o.endist);if(!endist)throw'endist='+endist;var ut=(t,e,i,r,s,n,l,h,a,u,p,d)=>{let c=Math.hypot(i-t,r-e),en=0;if(!o.onlyEndist){o.distanceScale;let s=Math.hypot(t-a,e-u);Math.hypot(i-a,r-u);en=at(p,s)+at(p,s)}return en=endist(en,c,d)},pt=1e-6,dt={centerY:0,centerX:0,radius:1},ct=()=>-.1+X(),ft=()=>{let t=[];for(let e=0;e<L.length-1;e++)t.push(new B([L[e],L[e+1]],ct));return k(t),t},vt=t=>new tt(!1,void 0,pt,ut,o.maxDistanceToAffectEachother,0,o.maxSpeed,o.friction,t,ft(),N,!0),yt=()=>{let t=ft();return new ht([vt(o.minPointsPerCurve)],ut,t,N,null)},bt=()=>{Rt=!0,Bt=!0,builder&&clearLoops()},loops={},xt=()=>{adjustBordersOfOptions(oo)},mt=()=>{if(builder&&(putInDefaults(oo),o=e(oo)),!o.endist)throw'no endist';setColorSeed(oo.colorSeed),h=0,bt(),Pt=[yt()];for(let t in oo.loops)loops[t]=r(t,oo.loops[t].length,!0);o.accelVoxels&&putHills(o.accelVoxels),builder&&(t=loops.timePosition?'timePosition':null,Z('bootShapeEditor').value=o.bootShape)},Mt=0,Pt=[],wt=()=>Pt[0],St=H(),At=()=>{let t=wt(),e=H(),i=W(0,e-St,.1);h+=2*i*Math.PI/o.loopSeconds,(h%=twoPi)<0&&(h+=twoPi),s();let r=0;if(o.useTimePosition){let e=o.timePosition-t.timePosition();r=W(0,o.timePositionDecay,1)*i*e}else r=i*o.timeSpeed;r*=W(0,oo.computeSpeed,1),St=e,c=c*(1-i)+1;let n=r<0,l=r,a=r;for(o.negTimeDoesUndo&&n&&(Mt=0);Mt<t.curves.length-3&&o.negTimeDoesUndo&&r<0;)Mt++,l=a,a=r,r+=Math.abs(t.curves[t.curves.length-Mt].dt);let u=t.curves[t.curves.length-1-Mt];if(o.negTimeDoesUndo&&(r=mx(0,r)),!u)return;let p=u.numPoints;if(0!=r){let e=new tt(!1,u,r,t.potentialEnergyFunc,o.maxDistanceToAffectEachother,o.addRandomness,o.maxSpeed,o.friction,p,t.neuralWeights,t.neuralFunc);o.balanceSparsity&&e.balanceSparsity();let i=1/(1-W(0,o.borderFraction,.95));e.holdInRect(-i,i,-i,i),t.curves.push(e)}t.curves.length>o.maxCurvesPerReef&&(t.curves=t.curves.slice(-o.maxCurvesPerReef))},Ct=(t,e,i,r,s,n,l,h)=>{let a=e.undoableVoxels.length>0,u=t&&!a,p=t,d=e.numPoints,c=0,f=t=>e.undoableVoxels.push(t);for(let t=0;t<d;t++){let a=(t+1)%d,v=ro(s+l*e.xp[t]),y=ro(r+n*e.yp[t]),b=ro(s+l*e.xp[a]),x=ro(r+n*e.yp[a]),g=b-v,m=x-y;c=mx(c,m*m+g*g);let M=o.sameColorness,P=o.paintBrightAdd,w=(e.red[t]*(1-M)+255*M)*o.paintBrightMult*o.brightMultRed+P,S=(e.green[t]*(1-M)+255*M)*o.paintBrightMult*o.brightMultGreen+P,A=(e.blue[t]*(1-M)+255*M)*o.paintBrightMult*o.brightMultBlue+P;if(o.wrapPaintBrightMult||(w=ot(w),S=ot(S),A=ot(A)),u&&i.streamUndoable2dVoxelsForLineYXYXRGBSafe(f,y,v,x,b,w,S,A,h),!p)throw'!paintVoxels'}p&&i.paintVoxels(e.undoableVoxels)},Rt=!0,Bt=!0,Ft=null,Dt=()=>{let e=wt();var i=Z('aDiv');e.curves[e.curves.length-1];p=0,a=0,d=wi.innerHeight,u=wi.innerWidth;let r=(d+p)/2,s=(u+a)/2,n=Math.abs((1-o.borderFraction)*mn(d-p,u-a)/2),l=n,h=r+'_'+s+'_'+n+'_'+l;Ft!=h&&setTimeout(()=>{Bt=Rt=!0},200),Ft=h,builder&&''!=i.innerHTML&&(i.innerHTML='');let c=Rt;a+10<u&&p+10<d&&J.resizeCanvas(a,u,p,d);let x=J.byteRect;!Rt&&o.isSurface||(Rt=!1,J.beforePaint(),x=J.byteRect);for(let t=b;t<J.byteRect.length;t+=4)x[t]=255;if(!c){let t=Bt||!o.isSurface;if(Bt=!1,t)if(window.paintAccelField)paintAccelField(o.brightAddRed,o.brightAddGreen,o.brightAddBlue,o.brightMult,K,0,1024,0,1024,J.byteRect,fl(r-2*l),fl(r+2*n),fl(s-2*l),fl(s+2*l));else{let t=x.b,e=ot(o.brightAddRed),i=ot(o.brightAddGreen),r=ot(o.brightAddBlue);for(let s=0;s<t.length;s+=4)t[s+f]=e,t[s+v]=i,t[s+y]=r,t[s+b]=255}let i=o.ifCanvasUseUndoGraphics,h=e.curves.pop();if(i&&Mt>0){for(;e.curves.length>2&&Mt>0;){let t=e.curves.pop();Ct(i,t,J.byteRect,r,s,n,l,mx(1,o.lineThick)),Mt--}Mt=0}e.curves.push(h),Ct(i,h,J.byteRect,r,s,n,l,mx(1,o.lineThick)),builder&&chkBuilder()&&tryDispOutCirc(r,s,n,l)}if(builder){let e=Z('chkOnlyPaintSelectedLoop').checked;chkBuilder()&&o.displayOuterCircle&&nt(r,s,n,l,e);for(let i in loops){!(o.displayOuterCircle&&(!e||i==t))&&loops[i].domLabel&&(loops[i].domLabel.remove(),delete loops[i].domLabel)}chkBuilder()&&o.graphEndist&&graphEndist()}J.afterPaint()},Ot=!1,Xt=0,Vt=()=>{Xt++;var t=!0;if(o.pause||o.computeSpeed<=0)t=!1;else{let e=Math.ceil(1/o.computeSpeed);t=Xt%e==0}t&&(At(),Dt()),requestAnimationFrame(Vt)},Tt=null;wi.onload=(()=>{Ot=!0,builder&&bootBuilder(),Tt=Z('divabxy'),J||(J=new g(Tt)),mt(),Vt()});";

//make sure to use the custom uglifyjs options at the bottom of this file "let uglifyjsOptions ="
//v700
//var minifiedJavascriptFromUglifyjs = "if(!window.o)throw'No o/options';if(!o.endist)throw'no endist';var t=null,e=t=>JSON.parse(JSON.stringify(t));builder&&buboot(),window.oo={},oo.endist=o.endist,oo.loops=e(o.loops||{}),eval('console.log(JSON.stringify(oo));');var optionIsBit={},optionIsInteger={};for(let t in o){let e=o[t];optionIsBit[t]=!1===e||!0===e,optionIsInteger[t]=Number.isInteger(e),(optionIsBit[t]||'number'==typeof e)&&(oo[t]=o[t])}var i=()=>56+200*pseudorandomFraction(),r=(t,e,r)=>{let s=i(),n=i(),l=i(),h=oo.loops[t],a=new it(t,e,s,n,l);if(r)for(let t=0;t<h.length;t++)a.radius[t]=h[t];return a},s=()=>{for(let t in oo)o.loops[t]?(loops[t]||(loops[t]=r(t,o.loops[t].length)),o[t]=loops[t].sliderOrCheckboxValueNow()):o[t]=oo[t]};const ro=Math.round,mn=Math.min,mx=Math.max,sin=Math.sin,cos=Math.cos,wi=window,px='px',fl=Math.floor,ce=Math.ceil,n=t=>new Float64Array(t),l=t=>new Float32Array(t);var h=0,a=350,u=850,p=100,d=600,c=60;const f=0,v=1,y=2,b=3,x=4;var m=function(t){this.dom=document.createElement('canvas'),this.context=null,this.imageData=null,this.pixels=null,this.byteRect=null,t.appendChild(this.dom);let e=this.dom.style;this.dom.width=10,this.dom.height=10,e.position='absolute',e.left='0px',e.top='0px',e.zIndex=-1e6,this.resizeCanvas=function(t,e,i,r){void 0===t&&(t=0),void 0===e&&(e=mx(10,wi.innerWidth)),void 0===i&&(i=0),void 0===r&&(r=mx(10,wi.innerHeight));let s=e-t,n=r-i,l=this.dom,h=l.style;l.setAttribute('height',n+px),l.setAttribute('width',s+px),h.height=n+px,h.width=s+px,h.top=i+px,h.left=t+px},this.beforePaint=function(){this.context=this.dom.getContext('2d'),this.imageData=this.context.getImageData(0,0,mx(10,this.dom.width),mx(10,this.dom.height)),this.pixels=this.imageData.data,this.byteRect=new g(this.pixels,this.dom.height,this.dom.width)},this.afterPaint=function(){this.context.putImageData(this.imageData,0,0)},this.resizeCanvas(0,10,0,10),this.beforePaint()},g=function(t,e,i){this.b=t,this.h=e,this.w=i},M=g;let P=M.prototype;P.writeSafeRGBA=function(t,e,i,r,s,n){void 0===n&&(n=255);let l=H(0,4*(ro(t)*this.w+ro(e)),this.b.length-4);this.b[l+f]=i,this.b[l+v]=r,this.b[l+y]=s,this.b[l+b]=n};const w=Math.pow(2,38),S=16383,A=1<<24;M.voxelY=(t=>fl(t/w)&S),M.voxelX=(t=>fl(t/A)&S),M.voxelXorRed=(t=>t>>16&255),M.voxelXorGreen=(t=>t>>8&255),M.voxelXorBlue=(t=>255&t),M.voxelYXXorsRGB=((t,e,i,r,s)=>((t&S)<<14|e&S)*A+((255&i)<<16|(255&r)<<8|255&s)),P.writeSafeUndoable2dVoxel=function(t){let e=M.voxelY(t),i=M.voxelX(t),r=M.voxelXorRed(t),s=M.voxelXorGreen(t),n=M.voxelXorBlue(t);this.writeSafeXorRGB(e,i,r,s,n)},P.paintVoxels=function(t){for(let e=0;e<t.length;e++)this.writeSafeUndoable2dVoxel(t[e])},P.undoable2dVoxel=function(t,e,i,r,s){let n=H(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);return M.voxelYXXorsRGB(t,e,i^this.b[n+f],r^this.b[n+v],s^this.b[n+y])},P.writeSafeXorRGB=function(t,e,i,r,s){let n=H(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);this.b[n+f]^=i,this.b[n+v]^=r,this.b[n+y]^=s,this.b[n+b]=255},P.streamUndoable2dVoxelsForLineYXYXRGBSafe=function(t,e,i,r,s,n,l,h,a){let u=r-e,p=s-i,d=Math.hypot(u,p),c=Math.ceil(1.5*d),f=-1,v=-1,y=e,b=i;for(let e=0;e<a;e++){for(let e=0;e<c;e++){let i=ro(y+u*e/c),r=ro(b+p*e/c);i==f&&r==v||(t(this.undoable2dVoxel(i,r,n,l,h)),f=i,v=r)}y+=p/d,b+=u/d}};const C=(t,e,i,r,s)=>{let l=n(i*s);for(let n=0;n<i;n++)for(let i=0;i<s;i++){let h=0;for(let l=0;l<r;l++)h+=t[n*r+l]*e[l*s+i];l[n*s+i]=h}return l};var R=t=>{let e=t[0];for(let i=1;i<t.length;i++)e*=t[i];return e},B=function(t,e){if(this.sizes=t,e)if('function'==typeof e){this.arr=l(R(t));for(let t=0;t<this.arr.length;t++)this.arr[t]=e()}else this.arr=e;else this.arr=l(R(t))};B.prototype.matmul=function(t){return new B([this.sizes[0],t.sizes[1]],C(this.arr,t.arr,this.sizes[0],this.sizes[1],t.sizes[1]))};var F=(t,e,i)=>{let r=t;for(let t=0;t<e.length;t++){r=r.matmul(e[t]);for(let t=0;t<r.arr.length;t++)r.arr[t]=i(r.arr[t])}return r};const sigmoid=t=>.5+.5*Math.tanh(.5*t);var D=t=>{let e=t.sizes[0],i=t.sizes[1],r=e-1;for(let e=0;e<i;e++)t.arr[r*i+e]=e==i-1?100:0};const O=()=>{if(W=!W){let t=0,e=0,i=0;do{i=(t=2*pseudorandomFraction()-1)*t+(e=2*pseudorandomFraction()-1)*e}while(i>=1||0==i);let r=Math.sqrt(-2*Math.log(i)/i);return _=t*r,e*r}return _},X=(t,e)=>Math.exp(-.5*(t*t+e*e)),bell=(t,e,i,r)=>i*Math.exp(-.5*sqr((r-t)/e)),V=t=>Math.floor(pseudorandomFraction()*t);var T=Math.tanh,N=5,E=1+2*N,G=3,I=E*G+1,z=G,Y=t=>{D(t)},U=t=>{for(let e=0;e<t.length;e++)Y(t[e])},k=[I,Math.ceil(1.5*I),z],L=null;const twoPi=2*Math.PI,J=eval('performance.timing.navigationStart'),q=()=>.001*(J+performance.now()),H=(t,e,i)=>mx(t,mn(e,i));var W=!1,_=0;const j=t=>document.getElementById(t);var Z=l(1<<21),K=(t,e)=>{let i=H(0,512+256*t,1023.99),r=H(0,512+256*e,1023.99),s=fl(i)<<11|fl(r)<<1;return{y:Z[s],x:Z[s+1]}},putHills=t=>{for(let t=0;t<Z.length;t++)Z[t]=0;for(let e=0;e<t.length;e+=6)Q(t[e],t[e+1],t[e+2],t[e+3],t[e+4],t[e+5])},Q=(t,e,i,r,s,n)=>{let l=ce(4*(256*i)),h=tt(0,512+256*t,1023),a=tt(0,512+256*e,1023);for(let t=h-l;t<h+l;t++)for(let e=a-l;e<a+l;e++){let l=2097151&(t<<11|e<<1),u=l+1,p=(t-h)/256/i,d=(e-a)/256/i,c=X(p,d),f=-r*((X(p+at,d)-c)/at),v=-r*((X(p,d+at)-c)/at),y=2.5;Z[l]=Math.tanh(Z[l]/y+c*s+f)*y,Z[u]=Math.tanh(Z[u]/y+c*n+v)*y}};let $=function(t,e,i,r,maxDistanceToAffectEachother,addRandomness,maxSpeed,friction,s,h,a,u){if(!s)throw'no points';let p=e;if(t)throw'removed code';{let t=o.accelFieldMul;this.dt=i;let e=ut,d=e.centerY,c=e.centerX,b=e.radius,x=b*o.borderRadiusMul;this.undoableVoxels=[],this.numPoints=s;let m=Math.pow(o.maxDistanceToAffectEachother,2);if(i=mx(-.9,mn(i,.9)),this.yp=n(s),this.xp=n(s),this.yv=n(s),this.xv=n(s),this.red=l(s),this.green=l(s),this.blue=l(s),p){let t=new B([1,I]),e=p,n=p.perimeter(),u=l(s),b=l(s);for(let t=0;t<s;t++){let e=(t+1)%s,i=this.yp[e]-this.yp[t],r=this.xp[e]-this.xp[t],n=Math.hypot(i,r);u[t]=0==n?1:i/n,b[t]=0==n?0:r/n}let g=0;for(let l=0;l<s;l++){this.yp[l]=p.yp[l],this.xp[l]=p.xp[l],l>0&&(g+=Math.hypot(p.yp[l]-p.yp[l-1],p.xp[l]-p.xp[l-1]));for(let e=0;e<E;e++){let i=(e+l-N+s)%s;t.arr[3*e+f]=p.red[i]/127.5-1,t.arr[3*e+v]=p.green[i]/127.5-1,t.arr[3*e+y]=p.blue[i]/127.5-1}t[t.length-1]=1;let M=F(t,h,a),P=et(127.5+127.5*M.arr[f]),w=et(127.5+127.5*M.arr[v]),S=et(127.5+127.5*M.arr[y]),A=mx(0,mn(o.colorDecayPerSec*i,1));this.red[l]=p.red[l]*(1-A)+A*P,this.green[l]=p.green[l]*(1-A)+A*w,this.blue[l]=p.blue[l]*(1-A)+A*S;let C=0,R=0,B=i*o.scalePotentialEnergyForce,D=K(this.yp[l],this.xp[l]);C+=o.accelFieldMul*B*D.y,R+=o.accelFieldMul*B*D.x;for(let t=0;t<e.numPoints;t++){let i=this.yp[l]-p.yp[t],s=this.xp[l]-p.xp[t],h=i*i+s*s;if(0!=h&&h<=m){let i=t/e.numPoints*n,s=mn(Math.abs(i-g),Math.abs(i+n-g)),a=u[l],p=b[l],f=u[t],v=b[t],y=Math.sqrt(h),m=1-y/maxDistanceToAffectEachother,M=r(this.yp[l],this.xp[l],e.yp[t],e.xp[t],a,p,f,v,d,c,x,s)*m,P=r(this.yp[l]-at/2,this.xp[l],e.yp[t]+at/2,e.xp[t],a,p,f,v,d,c,x,s)*m,w=r(this.yp[l],this.xp[l]-at/2,e.yp[t],e.xp[t]+at/2,a,p,f,v,d,c,x,s)*m,S=(P-M)/at,A=(w-M)/at;C+=S*B,R+=A*B}}let X=addRandomness*Math.sqrt(Math.abs(i));if(0!=addRandomness){let t=(l+1)%s,e=this.yp[t]-this.yp[l],i=this.xp[t]-this.xp[l],r=Math.hypot(e,i);if(0!=r){let t=e/r,s=i/r,n=s,l=-t,h=X*O();C+=n*h,R+=l*h}}this.yv[l]=p.yv[l]+C,this.xv[l]=p.xv[l]+R;let V=Math.hypot(this.yv[l],this.xv[l]);if(0!=V){let t=mx(0,mn(V-friction*i,o.maxSpeed)),e=t/V;this.yv[l]*=e,this.xv[l]*=e}this.yp[l]+=this.yv[l]*i,this.xp[l]+=this.xv[l]*i,o.setSpeedsToZeroAfterEveryDtMove&&(this.xv[l]=this.yv[l]=0)}}else{let t=0,e=0,r=i*addRandomness,n=0,bootShape=eval(o.bootShapeYX||o.bootShape);for(let i=0;i<s;i++){let r=i/s*twoPi,l=cos(r),h=sin(r),a=bootShape(r);'number'==typeof a?(this.yp[i]=a*l,this.xp[i]=a*h):(this.yp[i]=a[0],this.xp[i]=a[1]),this.yp[i]=t+o.bootShapeY+o.bootShapeScale*this.yp[i],this.xp[i]=e+o.bootShapeX+o.bootShapeScale*this.xp[i],this.yv[i]=n*l,this.xv[i]=n*h,this.red[i]=this.green[i]=this.blue[i]=V(256)}u||this.balanceSparsityBoot(),s=this.numPoints}}};const tt=(t,e,i)=>ro(mx(t,mn(e,i)));var et=t=>ro(mx(0,mn(t,255)));$.prototype.balanceSparsity=function(){let t=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue],e=this.numPoints,i=this.perimeterDistances(),r=i[e],s=H(mx(o.minPointsPerCurve,e-o.maxNumPointsPerCurveChangeAtOnce),Math.ceil(r/o.targetDistanceBetweenAdjacentCurvePoints),mn(e+o.maxNumPointsPerCurveChangeAtOnce,o.maxPointsPerCurve)),h=r/s;this.yp=n(s),this.xp=n(s),this.yv=n(s),this.xv=n(s),this.red=l(s),this.green=l(s),this.blue=l(s);let a=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue];this.numPoints=s;let u=0;for(let r=0;r<s;r++){let s=r*h;for(;i[u+1]<s;)u++;let n=(u+1)%e,l=i[u+1]-i[u],p=(s-i[u])/l;for(let e=0;e<t.length;e++)a[e][r]=t[e][u]*(1-p)+p*t[e][n]}return builder&&displayText(this),r};var sqr=t=>t*t;$.prototype.balanceSparsityBoot=function(){let t=o.maxNumPointsPerCurveChangeAtOnce;o.maxNumPointsPerCurveChangeAtOnce=1e6,this.balanceSparsity(),o.maxNumPointsPerCurveChangeAtOnce=t},$.prototype.perimeter=function(){let t=this.perimeterDistances();return t[t.length-1]},$.prototype.perimeterDistances=function(){let t=this.numPoints,e=n(t+1);e[0]=0;for(let i=0;i<t;i++){let r=(i+1)%t,s=Math.hypot(this.yp[r]-this.yp[i],this.xp[r]-this.xp[i]);e[i+1]=e[i]+s}return e},$.prototype.holdInRect=function(t,e,i,r){for(let s=0;s<this.numPoints;s++)this.yp[s]=H(i,this.yp[s],r),this.xp[s]=H(t,this.xp[s],e)};var ot=t=>JSON.parse(JSON.stringify(t)),it=function(name,t,e,i,r){this.clicks=[],this.name=name,this.radius=new Float32Array(t);let s=.7+.6*pseudorandomFraction();for(let e=0;e<t;e++){let i=2*Math.PI*e/t;this.radius[e]=1+.3*(Math.sin(5*i*s)+Math.sin(7*i*s+.3))}this.red=e,this.green=i,this.blue=r,this.curve=null,this.domLabel=null};it.prototype.sliderOrCheckboxValueNow=function(){let t=oo[this.name]*this.radiusAtAngle(h);return optionIsBit[this.name]?0<t:optionIsInteger[this.name]?Math.round(t)||1:t||at},it.prototype.radiusAtAngle=function(t){let e=t/twoPi*this.radius.length;(e%=this.radius.length)<0&&(e+=this.radius.length);let i=Math.floor(e),r=(i+1)%this.radius.length,s=e-i;return this.radius[Math.floor(i)]*(1-s)+s*this.radius[r]},it.prototype.copyRadiusArrayToCurve=function(){let t=this.radius.length;this.curve||(this.curve=ct(t));for(let e=0;e<t;e++){let i=2*Math.PI*e/t-h,r=loopRadiusOfZeroOption+loopRadiusMul*this.radius[e];this.curve.xp[e]=Math.sin(i)*r,this.curve.yp[e]=Math.cos(i)*r,this.curve.red[e]=this.red,this.curve.green[e]=this.green,this.curve.blue[e]=this.blue}};var rt=(e,i,r,s,n)=>{for(let t in loops){let n=loops[t];n.countPaints&&n.paintOrUnpaint(e,i,r,s),n.countPaints=(n.countPaints||0)+1}for(let l in loops)if(!n||l==t){let t=loops[l];t.copyRadiusArrayToCurve(),t.curve.undoableVoxels=[],t.paintOrUnpaint(e,i,r,s)}},st=function(t,e,i,r,addRandomness){this.curves=t,this.potentialEnergyFunc=e,this.neuralWeights=i,this.neuralFunc=r,this.addRandomness=null};st.prototype.timePosition=function(){let t=0;for(let e=0;e<this.curves.length;e++)t+=this.curves[e].dt;return t};var nt=(t,e)=>{let i=0,r=e-t;if(r>0)i+=r*r*o.stayInsideBorderCircleForce;else{i+=10*(sigmoid(.001*(e/t))-sigmoid(.001))}return i},endist=eval(o.endist);if(!endist)throw'endist='+endist;var ht=(t,e,i,r,s,n,l,h,a,u,p,d)=>{let c=Math.hypot(i-t,r-e),en=0;if(!o.onlyEndist){o.distanceScale;let s=Math.hypot(t-a,e-u);Math.hypot(i-a,r-u);en=nt(p,s)+nt(p,s)}return en=endist(en,c,d)},at=1e-6,ut={centerY:0,centerX:0,radius:1},pt=()=>-.1+O(),dt=()=>{let t=[];for(let e=0;e<k.length-1;e++)t.push(new B([k[e],k[e+1]],pt));return U(t),t},ct=t=>new $(!1,void 0,at,ht,o.maxDistanceToAffectEachother,0,o.maxSpeed,o.friction,t,dt(),T,!0),ft=()=>{let t=dt();return new st([ct(o.minPointsPerCurve)],ht,t,T,null)},vt=()=>{At=!0,Ct=!0,builder&&clearLoops()},loops={},yt=()=>{adjustBordersOfOptions(oo)},bt=()=>{if(builder&&(putInDefaults(oo),o=e(oo)),!o.endist)throw'no endist';setColorSeed(oo.colorSeed),h=0,vt(),mt=[ft()];for(let t in oo.loops)loops[t]=r(t,oo.loops[t].length,!0);o.accelVoxels&&putHills(o.accelVoxels),builder&&(t=loops.timePosition?'timePosition':null,j('bootShapeEditor').value=o.bootShape)},xt=0,mt=[],Mt=()=>mt[0],Pt=q(),wt=()=>{let t=Mt(),e=q(),i=H(0,e-Pt,.1);h+=2*i*Math.PI/o.loopSeconds,(h%=twoPi)<0&&(h+=twoPi),s();let r=0;if(o.useTimePosition){let e=o.timePosition-t.timePosition();r=H(0,o.timePositionDecay,1)*i*e}else r=i*o.timeSpeed;r*=H(0,oo.computeSpeed,1),Pt=e,c=c*(1-i)+1;let n=r<0,l=r,a=r;for(o.negTimeDoesUndo&&n&&(xt=0);xt<t.curves.length-3&&o.negTimeDoesUndo&&r<0;)xt++,l=a,a=r,r+=Math.abs(t.curves[t.curves.length-xt].dt);let u=t.curves[t.curves.length-1-xt];if(o.negTimeDoesUndo&&(r=mx(0,r)),!u)return;let p=u.numPoints;if(0!=r){let e=new $(!1,u,r,t.potentialEnergyFunc,o.maxDistanceToAffectEachother,o.addRandomness,o.maxSpeed,o.friction,p,t.neuralWeights,t.neuralFunc);o.balanceSparsity&&e.balanceSparsity();let i=1/(1-H(0,o.borderFraction,.95));e.holdInRect(-i,i,-i,i),t.curves.push(e)}t.curves.length>o.maxCurvesPerReef&&(t.curves=t.curves.slice(-o.maxCurvesPerReef))},St=(t,e,i,r,s,n,l,h)=>{let a=e.undoableVoxels.length>0,u=t&&!a,p=t,d=e.numPoints,c=0,f=t=>e.undoableVoxels.push(t);for(let t=0;t<d;t++){let a=(t+1)%d,v=ro(s+l*e.xp[t]),y=ro(r+n*e.yp[t]),b=ro(s+l*e.xp[a]),x=ro(r+n*e.yp[a]),m=b-v,g=x-y;c=mx(c,g*g+m*m);let M=o.sameColorness,P=o.paintBrightAdd,w=(e.red[t]*(1-M)+255*M)*o.paintBrightMult*o.brightMultRed+P,S=(e.green[t]*(1-M)+255*M)*o.paintBrightMult*o.brightMultGreen+P,A=(e.blue[t]*(1-M)+255*M)*o.paintBrightMult*o.brightMultBlue+P;if(o.wrapPaintBrightMult||(w=et(w),S=et(S),A=et(A)),u&&i.streamUndoable2dVoxelsForLineYXYXRGBSafe(f,y,v,x,b,w,S,A,h),!p)throw'!paintVoxels'}p&&i.paintVoxels(e.undoableVoxels)},At=!0,Ct=!0,Rt=null,Bt=()=>{let e=Mt();var i=j('aDiv');e.curves[e.curves.length-1];p=0,a=0,d=wi.innerHeight,u=wi.innerWidth;let r=(d+p)/2,s=(u+a)/2,n=Math.abs((1-o.borderFraction)*mn(d-p,u-a)/2),l=n,h=r+'_'+s+'_'+n+'_'+l;Rt!=h&&setTimeout(()=>{Ct=At=!0},200),Rt=h,builder&&''!=i.innerHTML&&(i.innerHTML='');let c=At;a+10<u&&p+10<d&&L.resizeCanvas(a,u,p,d);let x=L.byteRect;!At&&o.isSurface||(At=!1,L.beforePaint(),x=L.byteRect);for(let t=b;t<L.byteRect.length;t+=4)x[t]=255;if(!c){let t=Ct||!o.isSurface;if(Ct=!1,t)if(window.paintAccelField)paintAccelField(o.brightAddRed,o.brightAddGreen,o.brightAddBlue,o.brightMult,Z,0,1024,0,1024,L.byteRect,fl(r-2*l),fl(r+2*n),fl(s-2*l),fl(s+2*l));else{let t=x.b,e=et(o.brightAddRed),i=et(o.brightAddGreen),r=et(o.brightAddBlue);for(let s=0;s<t.length;s+=4)t[s+f]=e,t[s+v]=i,t[s+y]=r,t[s+b]=255}let i=o.ifCanvasUseUndoGraphics,h=e.curves.pop();if(i&&xt>0){for(;e.curves.length>2&&xt>0;){let t=e.curves.pop();St(i,t,L.byteRect,r,s,n,l,mx(1,o.lineThick)),xt--}xt=0}e.curves.push(h),St(i,h,L.byteRect,r,s,n,l,mx(1,o.lineThick)),builder&&chkBuilder()&&tryDispOutCirc(r,s,n,l)}if(builder){let e=j('chkOnlyPaintSelectedLoop').checked;chkBuilder()&&o.displayOuterCircle&&rt(r,s,n,l,e);for(let i in loops){!(o.displayOuterCircle&&(!e||i==t))&&loops[i].domLabel&&(loops[i].domLabel.remove(),delete loops[i].domLabel)}chkBuilder()&&o.graphEndist&&graphEndist()}L.afterPaint()},Ft=!1,Dt=0,Ot=()=>{Dt++;var t=!0;if(o.pause||o.computeSpeed<=0)t=!1;else{let e=Math.ceil(1/o.computeSpeed);t=Dt%e==0}t&&(wt(),Bt()),requestAnimationFrame(Ot)},Xt=null;wi.onload=(()=>{Ft=!0,builder&&bootBuilder(),Xt=j('divabxy'),L||(L=new m(Xt)),bt(),Ot()});";

//make sure to use the custom uglifyjs options at the bottom of this file "let uglifyjsOptions ="
//v702
//var minifiedJavascriptFromUglifyjs = "if(!window.o)throw'opt';if(!o.endist)throw'endist';var t=null,e=t=>JSON.parse(JSON.stringify(t));builder&&buboot(),window.oo={},oo.endist=o.endist,oo.loops=e(o.loops||{}),eval('console.log(JSON.stringify(oo));');var optionIsBit={},optionIsInteger={};for(let t in o){let e=o[t];optionIsBit[t]=!1===e||!0===e,optionIsInteger[t]=Number.isInteger(e),(optionIsBit[t]||'number'==typeof e)&&(oo[t]=o[t])}var i=()=>56+200*pseudorandomFraction(),s=(t,e,s)=>{let r=i(),n=i(),h=i(),l=oo.loops[t],a=new it(t,e,r,n,h);if(s)for(let t=0;t<l.length;t++)a.radius[t]=l[t];return a},r=()=>{for(let t in oo)o.loops[t]?(loops[t]||(loops[t]=s(t,o.loops[t].length)),o[t]=loops[t].sliderOrCheckboxValueNow()):o[t]=oo[t]};const ro=Math.round,mn=Math.min,mx=Math.max,sin=Math.sin,cos=Math.cos,wi=window,px='px',fl=Math.floor,ce=Math.ceil,n=t=>new Float64Array(t),h=t=>new Float32Array(t);var l=0,a=350,u=850,p=100,c=600,d=60;const f=0,v=1,y=2,x=3;var b=function(t){this.dom=document.createElement('canvas'),this.context=null,this.imageData=null,this.pixels=null,this.byteRect=null,t.appendChild(this.dom);let e=this.dom.style;this.dom.width=10,this.dom.height=10,e.position='absolute',e.left='0px',e.top='0px',e.zIndex=-1e6,this.resizeCanvas=function(t,e,i,s){t||(t=0),e||(e=mx(10,wi.innerWidth)),i||(i=0),s||(s=mx(10,wi.innerHeight));let r=e-t,n=s-i,h=this.dom,l=h.style;h.setAttribute('height',n+px),h.setAttribute('width',r+px),l.height=n+px,l.width=r+px,l.top=i+px,l.left=t+px},this.beforePaint=function(){this.context=this.dom.getContext('2d'),this.imageData=this.context.getImageData(0,0,mx(10,this.dom.width),mx(10,this.dom.height)),this.pixels=this.imageData.data,this.byteRect=new m(this.pixels,this.dom.height,this.dom.width)},this.afterPaint=function(){this.context.putImageData(this.imageData,0,0)},this.resizeCanvas(0,10,0,10),this.beforePaint()},m=function(t,e,i){this.b=t,this.h=e,this.w=i},g=m;let M=g.prototype;M.writeSafeRGBA=function(t,e,i,s,r,n){void 0===n&&(n=255);let h=q(0,4*(ro(t)*this.w+ro(e)),this.b.length-4);this.b[h+f]=i,this.b[h+v]=s,this.b[h+y]=r,this.b[h+x]=n};const P=Math.pow(2,38),w=16383,S=1<<24;g.voxelY=(t=>fl(t/P)&w),g.voxelX=(t=>fl(t/S)&w),g.voxelXorRed=(t=>t>>16&255),g.voxelXorGreen=(t=>t>>8&255),g.voxelXorBlue=(t=>255&t),g.voxelYXXorsRGB=((t,e,i,s,r)=>((t&w)<<14|e&w)*S+((255&i)<<16|(255&s)<<8|255&r)),M.writeSafeUndoable2dVoxel=function(t){let e=g.voxelY(t),i=g.voxelX(t),s=g.voxelXorRed(t),r=g.voxelXorGreen(t),n=g.voxelXorBlue(t);this.writeSafeXorRGB(e,i,s,r,n)},M.paintVoxels=function(t){for(let e=0;e<t.length;e++)this.writeSafeUndoable2dVoxel(t[e])},M.undoable2dVoxel=function(t,e,i,s,r){let n=q(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);return g.voxelYXXorsRGB(t,e,i^this.b[n+f],s^this.b[n+v],r^this.b[n+y])},M.writeSafeXorRGB=function(t,e,i,s,r){let n=q(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);this.b[n+f]^=i,this.b[n+v]^=s,this.b[n+y]^=r,this.b[n+x]=255},M.streamUndoable2dVoxelsForLineYXYXRGBSafe=function(t,e,i,s,r,n,h,l,a){let u=s-e,p=r-i,c=Math.hypot(u,p),d=Math.ceil(1.5*c),f=-1,v=-1,y=e,x=i;for(let e=0;e<a;e++){for(let e=0;e<d;e++){let i=ro(y+u*e/d),s=ro(x+p*e/d);i==f&&s==v||(t(this.undoable2dVoxel(i,s,n,h,l)),f=i,v=s)}y+=p/c,x+=u/c}};const A=(t,e,i,s,r)=>{let h=n(i*r);for(let n=0;n<i;n++)for(let i=0;i<r;i++){let l=0;for(let h=0;h<s;h++)l+=t[n*s+h]*e[h*r+i];h[n*r+i]=l}return h};var R=t=>{let e=t[0];for(let i=1;i<t.length;i++)e*=t[i];return e},C=function(t,e){if(this.sizes=t,e)if('function'==typeof e){this.arr=h(R(t));for(let t=0;t<this.arr.length;t++)this.arr[t]=e()}else this.arr=e;else this.arr=h(R(t))};C.prototype.matmul=function(t){return new C([this.sizes[0],t.sizes[1]],A(this.arr,t.arr,this.sizes[0],this.sizes[1],t.sizes[1]))};var B=(t,e,i)=>{let s=t;for(let t=0;t<e.length;t++){s=s.matmul(e[t]);for(let t=0;t<s.arr.length;t++)s.arr[t]=i(s.arr[t])}return s};const sigmoid=t=>.5+.5*Math.tanh(.5*t);var F=t=>{let e=t.sizes[0],i=t.sizes[1],s=e-1;for(let e=0;e<i;e++)t.arr[s*i+e]=e==i-1?100:0};const D=()=>{if(H=!H){let t=0,e=0,i=0;do{i=(t=2*pseudorandomFraction()-1)*t+(e=2*pseudorandomFraction()-1)*e}while(i>=1||0==i);let s=Math.sqrt(-2*Math.log(i)/i);return W=t*s,e*s}return W},X=(t,e)=>Math.exp(-.5*(t*t+e*e)),bell=(t,e,i,s)=>i*Math.exp(-.5*sqr((s-t)/e)),O=t=>Math.floor(pseudorandomFraction()*t);var V=Math.tanh,T=5,G=1+2*T,I=3,N=G*I+1,z=I,Y=t=>{F(t)},E=t=>{for(let e=0;e<t.length;e++)Y(t[e])},U=[N,Math.ceil(1.5*N),z],k=null;const twoPi=2*Math.PI,L=eval('performance.timing.navigationStart'),J=()=>.001*(L+performance.now()),q=(t,e,i)=>mx(t,mn(e,i));var H=!1,W=0;const _=t=>document.getElementById(t);var j=h(1<<21),Z=(t,e)=>{let i=q(0,512+256*t,1023.99),s=q(0,512+256*e,1023.99),r=fl(i)<<11|fl(s)<<1;return{y:j[r],x:j[r+1]}},putHills=t=>{for(let t=0;t<j.length;t++)j[t]=0;for(let e=0;e<t.length;e+=6)K(t[e],t[e+1],t[e+2],t[e+3],t[e+4],t[e+5])},K=(t,e,i,s,r,n)=>{let h=ce(4*(256*i)),l=$(0,512+256*t,1023),a=$(0,512+256*e,1023);for(let t=l-h;t<l+h;t++)for(let e=a-h;e<a+h;e++){let h=2097151&(t<<11|e<<1),u=h+1,p=(t-l)/256/i,c=(e-a)/256/i,d=X(p,c),f=-s*((X(p+ht,c)-d)/ht),v=-s*((X(p,c+ht)-d)/ht),y=2.5;j[h]=Math.tanh(j[h]/y+d*r+f)*y,j[u]=Math.tanh(j[u]/y+d*n+v)*y}};let Q=function(t,e,i,maxDistanceToAffectEachother,addRandomness,maxSpeed,friction,s,r,l,a){if(!s)throw'no points';let u=t,p=o.accelFieldMul;this.dt=e;let c=at,d=c.centerY,x=c.centerX,b=c.radius,m=b*o.borderRadiusMul;this.undoableVoxels=[],this.numPoints=s;let g=Math.pow(o.maxDistanceToAffectEachother,2);if(e=mx(-.9,mn(e,.9)),this.yp=n(s),this.xp=n(s),this.yv=n(s),this.xv=n(s),this.red=h(s),this.green=h(s),this.blue=h(s),u){let t=new C([1,N]),n=u,a=u.perimeter(),p=h(s),c=h(s);for(let t=0;t<s;t++){let e=(t+1)%s,i=this.yp[e]-this.yp[t],r=this.xp[e]-this.xp[t],n=Math.hypot(i,r);p[t]=0==n?1:i/n,c[t]=0==n?0:r/n}let b=0;for(let h=0;h<s;h++){this.yp[h]=u.yp[h],this.xp[h]=u.xp[h],h>0&&(b+=Math.hypot(u.yp[h]-u.yp[h-1],u.xp[h]-u.xp[h-1]));for(let e=0;e<G;e++){let i=(e+h-T+s)%s;t.arr[3*e+f]=u.red[i]/127.5-1,t.arr[3*e+v]=u.green[i]/127.5-1,t.arr[3*e+y]=u.blue[i]/127.5-1}t[t.length-1]=1;let M=B(t,r,l),P=tt(127.5+127.5*M.arr[f]),w=tt(127.5+127.5*M.arr[v]),S=tt(127.5+127.5*M.arr[y]),A=mx(0,mn(o.colorDecayPerSec*e,1));this.red[h]=u.red[h]*(1-A)+A*P,this.green[h]=u.green[h]*(1-A)+A*w,this.blue[h]=u.blue[h]*(1-A)+A*S;let R=0,C=0,F=e*o.scalePotentialEnergyForce,X=Z(this.yp[h],this.xp[h]);R+=o.accelFieldMul*F*X.y,C+=o.accelFieldMul*F*X.x;for(let t=0;t<n.numPoints;t++){let e=this.yp[h]-u.yp[t],s=this.xp[h]-u.xp[t],r=e*e+s*s;if(0!=r&&r<=g){let e=t/n.numPoints*a,s=mn(Math.abs(e-b),Math.abs(e+a-b)),l=p[h],u=c[h],f=p[t],v=c[t],y=Math.sqrt(r),g=1-y/maxDistanceToAffectEachother,M=i(this.yp[h],this.xp[h],n.yp[t],n.xp[t],l,u,f,v,d,x,m,s)*g,P=i(this.yp[h]-ht/2,this.xp[h],n.yp[t]+ht/2,n.xp[t],l,u,f,v,d,x,m,s)*g,w=i(this.yp[h],this.xp[h]-ht/2,n.yp[t],n.xp[t]+ht/2,l,u,f,v,d,x,m,s)*g,S=(P-M)/ht,A=(w-M)/ht;R+=S*F,C+=A*F}}let O=addRandomness*Math.sqrt(Math.abs(e));if(0!=addRandomness){let t=(h+1)%s,e=this.yp[t]-this.yp[h],i=this.xp[t]-this.xp[h],r=Math.hypot(e,i);if(0!=r){let t=e/r,s=i/r,n=s,h=-t,l=O*D();R+=n*l,C+=h*l}}this.yv[h]=u.yv[h]+R,this.xv[h]=u.xv[h]+C;let V=Math.hypot(this.yv[h],this.xv[h]);if(0!=V){let t=mx(0,mn(V-friction*e,o.maxSpeed)),i=t/V;this.yv[h]*=i,this.xv[h]*=i}this.yp[h]+=this.yv[h]*e,this.xp[h]+=this.xv[h]*e,o.setSpeedsToZeroAfterEveryDtMove&&(this.xv[h]=this.yv[h]=0)}}else{let t=0,i=0,r=e*addRandomness,n=0,bootShape=eval(o.bootShapeYX||o.bootShape);for(let e=0;e<s;e++){let r=e/s*twoPi,h=cos(r),l=sin(r),a=bootShape(r);'number'==typeof a?(this.yp[e]=a*h,this.xp[e]=a*l):(this.yp[e]=a[0],this.xp[e]=a[1]),this.yp[e]=t+o.bootShapeY+o.bootShapeScale*this.yp[e],this.xp[e]=i+o.bootShapeX+o.bootShapeScale*this.xp[e],this.yv[e]=n*h,this.xv[e]=n*l,this.red[e]=this.green[e]=this.blue[e]=O(256)}a||this.balanceSparsityBoot(),s=this.numPoints}};const $=(t,e,i)=>ro(mx(t,mn(e,i)));var tt=t=>ro(mx(0,mn(t,255)));Q.prototype.balanceSparsity=function(){let t=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue],e=this.numPoints,i=this.perimeterDistances(),s=i[e],r=q(mx(o.minPointsPerCurve,e-o.maxNumPointsPerCurveChangeAtOnce),Math.ceil(s/o.targetDistanceBetweenAdjacentCurvePoints),mn(e+o.maxNumPointsPerCurveChangeAtOnce,o.maxPointsPerCurve)),l=s/r;this.yp=n(r),this.xp=n(r),this.yv=n(r),this.xv=n(r),this.red=h(r),this.green=h(r),this.blue=h(r);let a=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue];this.numPoints=r;let u=0;for(let s=0;s<r;s++){let r=s*l;for(;i[u+1]<r;)u++;let n=(u+1)%e,h=i[u+1]-i[u],p=(r-i[u])/h;for(let e=0;e<t.length;e++)a[e][s]=t[e][u]*(1-p)+p*t[e][n]}return builder&&displayText(this),s};var sqr=t=>t*t;Q.prototype.balanceSparsityBoot=function(){let t=o.maxNumPointsPerCurveChangeAtOnce;o.maxNumPointsPerCurveChangeAtOnce=1e6,this.balanceSparsity(),o.maxNumPointsPerCurveChangeAtOnce=t},Q.prototype.perimeter=function(){let t=this.perimeterDistances();return t[t.length-1]},Q.prototype.perimeterDistances=function(){let t=this.numPoints,e=n(t+1);e[0]=0;for(let i=0;i<t;i++){let s=(i+1)%t,r=Math.hypot(this.yp[s]-this.yp[i],this.xp[s]-this.xp[i]);e[i+1]=e[i]+r}return e},Q.prototype.holdInRect=function(t,e,i,s){for(let r=0;r<this.numPoints;r++)this.yp[r]=q(i,this.yp[r],s),this.xp[r]=q(t,this.xp[r],e)};var et=t=>JSON.parse(JSON.stringify(t)),it=function(name,t,e,i,s){this.clicks=[],this.name=name,this.radius=new Float32Array(t);let r=.7+.6*pseudorandomFraction();for(let e=0;e<t;e++){let i=2*Math.PI*e/t;this.radius[e]=1+.3*(Math.sin(5*i*r)+Math.sin(7*i*r+.3))}this.red=e,this.green=i,this.blue=s,this.curve=null,this.domLabel=null};it.prototype.sliderOrCheckboxValueNow=function(){let t=oo[this.name]*this.radiusAtAngle(l);return optionIsBit[this.name]?0<t:optionIsInteger[this.name]?Math.round(t)||1:t||ht},it.prototype.radiusAtAngle=function(t){let e=t/twoPi*this.radius.length;(e%=this.radius.length)<0&&(e+=this.radius.length);let i=Math.floor(e),s=(i+1)%this.radius.length,r=e-i;return this.radius[Math.floor(i)]*(1-r)+r*this.radius[s]},it.prototype.copyRadiusArrayToCurve=function(){let t=this.radius.length;this.curve||(this.curve=ct(t));for(let e=0;e<t;e++){let i=2*Math.PI*e/t-l,s=loopRadiusOfZeroOption+loopRadiusMul*this.radius[e];this.curve.xp[e]=Math.sin(i)*s,this.curve.yp[e]=Math.cos(i)*s,this.curve.red[e]=this.red,this.curve.green[e]=this.green,this.curve.blue[e]=this.blue}};var ot=(e,i,s,r,n)=>{for(let t in loops){let n=loops[t];n.countPaints&&n.paintOrUnpaint(e,i,s,r),n.countPaints=(n.countPaints||0)+1}for(let h in loops)if(!n||h==t){let t=loops[h];t.copyRadiusArrayToCurve(),t.curve.undoableVoxels=[],t.paintOrUnpaint(e,i,s,r)}},st=function(t,e,i,s,addRandomness){this.curves=t,this.potentialEnergyFunc=e,this.neuralWeights=i,this.neuralFunc=s,this.addRandomness=null};st.prototype.timePosition=function(){let t=0;for(let e=0;e<this.curves.length;e++)t+=this.curves[e].dt;return t};var rt=(t,e)=>{let i=0,s=e-t;if(s>0)i+=s*s*o.stayInsideBorderCircleForce;else{i+=10*(sigmoid(.001*(e/t))-sigmoid(.001))}return i},endist=eval(o.endist);if(!endist)throw'endist='+endist;var nt=(t,e,i,s,r,n,h,l,a,u,p,c)=>{let d=Math.hypot(i-t,s-e),en=0;if(!o.onlyEndist){o.distanceScale;let r=Math.hypot(t-a,e-u);Math.hypot(i-a,s-u);en=rt(p,r)+rt(p,r)}return en=endist(en,d,c)},ht=1e-6,at={centerY:0,centerX:0,radius:1},ut=()=>-.1+D(),pt=()=>{let t=[];for(let e=0;e<U.length-1;e++)t.push(new C([U[e],U[e+1]],ut));return E(t),t},ct=t=>new Q(void 0,ht,nt,o.maxDistanceToAffectEachother,0,o.maxSpeed,o.friction,t,pt(),V,!0),dt=()=>{let t=pt();return new st([ct(o.minPointsPerCurve)],nt,t,V,null)},ft=()=>{St=!0,At=!0,builder&&clearLoops()},loops={},vt=()=>{adjustBordersOfOptions(oo)},yt=()=>{if(builder&&(putInDefaults(oo),o=e(oo)),!o.endist)throw'no endist';setColorSeed(oo.colorSeed),l=0,ft(),bt=[dt()];for(let t in oo.loops)loops[t]=s(t,oo.loops[t].length,!0);o.accelVoxels&&putHills(o.accelVoxels),builder&&(t=loops.timePosition?'timePosition':null,_('bootShapeEditor').value=o.bootShape)},xt=0,bt=[],mt=()=>bt[0],Mt=J(),Pt=()=>{let t=mt(),e=J(),i=q(0,e-Mt,.1);l+=2*i*Math.PI/o.loopSeconds,(l%=twoPi)<0&&(l+=twoPi),r();let s=0;if(o.useTimePosition){let e=o.timePosition-t.timePosition();s=q(0,o.timePositionDecay,1)*i*e}else s=i*o.timeSpeed;s*=q(0,oo.computeSpeed,1),Mt=e,d=d*(1-i)+1;let n=s<0,h=s,a=s;for(o.negTimeDoesUndo&&n&&(xt=0);xt<t.curves.length-3&&o.negTimeDoesUndo&&s<0;)xt++,h=a,a=s,s+=Math.abs(t.curves[t.curves.length-xt].dt);let u=t.curves[t.curves.length-1-xt];if(o.negTimeDoesUndo&&(s=mx(0,s)),!u)return;let p=u.numPoints;if(0!=s){let e=new Q(u,s,t.potentialEnergyFunc,o.maxDistanceToAffectEachother,o.addRandomness,o.maxSpeed,o.friction,p,t.neuralWeights,t.neuralFunc);o.balanceSparsity&&e.balanceSparsity();let i=1/(1-q(0,o.borderFraction,.95));e.holdInRect(-i,i,-i,i),t.curves.push(e)}t.curves.length>o.maxCurvesPerReef&&(t.curves=t.curves.slice(-o.maxCurvesPerReef))},wt=(t,e,i,s,r,n,h,l)=>{let a=e.undoableVoxels.length>0,u=t&&!a,p=t,c=e.numPoints,d=0,f=t=>e.undoableVoxels.push(t);for(let t=0;t<c;t++){let a=(t+1)%c,p=ro(r+h*e.xp[t]),v=ro(s+n*e.yp[t]),y=ro(r+h*e.xp[a]),x=ro(s+n*e.yp[a]),b=y-p,m=x-v;d=mx(d,m*m+b*b);let g=o.sameColorness,M=o.paintBrightAdd,P=(e.red[t]*(1-g)+255*g)*o.paintBrightMult*o.brightMultRed+M,w=(e.green[t]*(1-g)+255*g)*o.paintBrightMult*o.brightMultGreen+M,S=(e.blue[t]*(1-g)+255*g)*o.paintBrightMult*o.brightMultBlue+M;o.wrapPaintBrightMult||(P=tt(P),w=tt(w),S=tt(S)),u&&i.streamUndoable2dVoxelsForLineYXYXRGBSafe(f,v,p,x,y,P,w,S,l)}p&&i.paintVoxels(e.undoableVoxels)},St=!0,At=!0,Rt=null,Ct=()=>{let t=mt();var e=_('aDiv');t.curves[t.curves.length-1];p=0,a=0,c=wi.innerHeight,u=wi.innerWidth;let i=(c+p)/2,s=(u+a)/2,r=Math.abs((1-o.borderFraction)*mn(c-p,u-a)/2),n=r,h=i+'_'+s+'_'+r+'_'+n;Rt!=h&&setTimeout(()=>{At=St=!0},200),Rt=h,builder&&''!=e.innerHTML&&(e.innerHTML='');let l=St;a+10<u&&p+10<c&&k.resizeCanvas(a,u,p,c);let d=k.byteRect;!St&&o.isSurface||(St=!1,k.beforePaint(),d=k.byteRect);for(let t=x;t<k.byteRect.length;t+=4)d[t]=255;if(!l){let e=At||!o.isSurface;if(At=!1,e)if(window.paintAccelField)paintAccelField(o.brightAddRed,o.brightAddGreen,o.brightAddBlue,o.brightMult,j,0,1024,0,1024,k.byteRect,fl(i-2*n),fl(i+2*r),fl(s-2*n),fl(s+2*n));else{let t=d.b,e=tt(o.brightAddRed),i=tt(o.brightAddGreen),s=tt(o.brightAddBlue);for(let r=0;r<t.length;r+=4)t[r+f]=e,t[r+v]=i,t[r+y]=s,t[r+x]=255}let h=o.ifCanvasUseUndoGraphics,l=t.curves.pop();if(h&&xt>0){for(;t.curves.length>2&&xt>0;){let e=t.curves.pop();wt(h,e,k.byteRect,i,s,r,n,mx(1,o.lineThick)),xt--}xt=0}t.curves.push(l),wt(h,l,k.byteRect,i,s,r,n,mx(1,o.lineThick)),builder&&chkBuilder()&&tryDispOutCirc(i,s,r,n)}builder&&bldDisp(i,s,r,n),k.afterPaint()},Bt=!1,Ft=0,Dt=()=>{Ft++;var t=!0;if(o.pause||o.computeSpeed<=0)t=!1;else{let e=Math.ceil(1/o.computeSpeed);t=Ft%e==0}t&&(Pt(),Ct()),requestAnimationFrame(Dt)},Xt=null;wi.onload=(()=>{Bt=!0,builder&&bootBuilder(),Xt=_('divabxy'),k||(k=new b(Xt)),yt(),Dt()});";

//make sure to use the custom uglifyjs options at the bottom of this file "let uglifyjsOptions ="
//v703
var minifiedJavascriptFromUglifyjs = "if(!window.o)throw'opt';if(!o.endist)throw'endist';var t=null,e=t=>JSON.parse(JSON.stringify(t));builder&&buboot(),window.oo={},oo.endist=o.endist,oo.loops=e(o.loops||{}),eval('console.log(JSON.stringify(oo));');var optionIsBit={},optionIsInteger={};for(let t in o){let e=o[t];optionIsBit[t]=!1===e||!0===e,optionIsInteger[t]=Number.isInteger(e),(optionIsBit[t]||'number'==typeof e)&&(oo[t]=o[t])}var i=()=>56+200*pseudorandomFraction(),s=(t,e,s)=>{let r=i(),n=i(),h=i(),l=oo.loops[t],a=new ot(t,e,r,n,h);if(s)for(let t=0;t<l.length;t++)a.radius[t]=l[t];return a},r=()=>{for(let t in oo)o.loops[t]?(loops[t]||(loops[t]=s(t,o.loops[t].length)),o[t]=loops[t].sliderOrCheckboxValueNow()):o[t]=oo[t]};const ro=Math.round,mn=Math.min,mx=Math.max,sin=Math.sin,cos=Math.cos,wi=window,px='px',fl=Math.floor,ce=Math.ceil,n=t=>new Float64Array(t),h=t=>new Float32Array(t);var l=0,a=350,u=850,p=100,c=600,d=60;const f=0,v=1,y=2,x=3;var b=function(t){this.dom=document.createElement('canvas'),this.context=null,this.imageData=null,this.pixels=null,this.byteRect=null,t.appendChild(this.dom);let e=this.dom.style;this.dom.width=10,this.dom.height=10,e.position='absolute',e.left='0px',e.top='0px',e.zIndex=-1e6,this.resizeCanvas=function(t,e,i,s){t||(t=0),e||(e=mx(10,wi.innerWidth)),i||(i=0),s||(s=mx(10,wi.innerHeight));let r=e-t,n=s-i,h=this.dom,l=h.style;h.setAttribute('height',n+px),h.setAttribute('width',r+px),l.height=n+px,l.width=r+px,l.top=i+px,l.left=t+px},this.beforePaint=function(){this.context=this.dom.getContext('2d'),this.imageData=this.context.getImageData(0,0,mx(10,this.dom.width),mx(10,this.dom.height)),this.pixels=this.imageData.data,this.byteRect=new m(this.pixels,this.dom.height,this.dom.width)},this.afterPaint=function(){this.context.putImageData(this.imageData,0,0)},this.resizeCanvas(0,10,0,10),this.beforePaint()},m=function(t,e,i){this.b=t,this.h=e,this.w=i},g=m;let M=g.prototype;M.writeSafeRGBA=function(t,e,i,s,r,n){void 0===n&&(n=255);let h=H(0,4*(ro(t)*this.w+ro(e)),this.b.length-4);this.b[h+f]=i,this.b[h+v]=s,this.b[h+y]=r,this.b[h+x]=n};const P=Math.pow(2,38),w=16383,S=1<<24;g.voxelY=(t=>fl(t/P)&w),g.voxelX=(t=>fl(t/S)&w),g.voxelXorRed=(t=>t>>16&255),g.voxelXorGreen=(t=>t>>8&255),g.voxelXorBlue=(t=>255&t),g.voxelYXXorsRGB=((t,e,i,s,r)=>((t&w)<<14|e&w)*S+((255&i)<<16|(255&s)<<8|255&r)),M.writeSafeUndoable2dVoxel=function(t){let e=g.voxelY(t),i=g.voxelX(t),s=g.voxelXorRed(t),r=g.voxelXorGreen(t),n=g.voxelXorBlue(t);this.writeSafeXorRGB(e,i,s,r,n)},M.paintVoxels=function(t){for(let e=0;e<t.length;e++)this.writeSafeUndoable2dVoxel(t[e])},M.undoable2dVoxel=function(t,e,i,s,r){let n=H(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);return g.voxelYXXorsRGB(t,e,i^this.b[n+f],s^this.b[n+v],r^this.b[n+y])},M.writeSafeXorRGB=function(t,e,i,s,r){let n=H(0,4*(Math.floor(t)*this.w+Math.floor(e)),this.b.length-4);this.b[n+f]^=i,this.b[n+v]^=s,this.b[n+y]^=r,this.b[n+x]=255},M.streamUndoable2dVoxelsForLineYXYXRGBSafe=function(t,e,i,s,r,n,h,l,a){let u=s-e,p=r-i,c=Math.hypot(u,p),d=Math.ceil(1.5*c),f=-1,v=-1,y=e,x=i;for(let e=0;e<a;e++){for(let e=0;e<d;e++){let i=ro(y+u*e/d),s=ro(x+p*e/d);i==f&&s==v||(t(this.undoable2dVoxel(i,s,n,h,l)),f=i,v=s)}y+=p/c,x+=u/c}};const A=(t,e,i,s,r)=>{let h=n(i*r);for(let n=0;n<i;n++)for(let i=0;i<r;i++){let l=0;for(let h=0;h<s;h++)l+=t[n*s+h]*e[h*r+i];h[n*r+i]=l}return h};var R=t=>{let e=t[0];for(let i=1;i<t.length;i++)e*=t[i];return e},C=function(t,e){if(this.sizes=t,e)if('function'==typeof e){this.arr=h(R(t));for(let t=0;t<this.arr.length;t++)this.arr[t]=e()}else this.arr=e;else this.arr=h(R(t))};C.prototype.matmul=function(t){return new C([this.sizes[0],t.sizes[1]],A(this.arr,t.arr,this.sizes[0],this.sizes[1],t.sizes[1]))};var B=t=>{let e=[];return e.push(...t),e},F=(t,e,i)=>{let s=t;for(let t=0;t<e.length;t++){s=s.matmul(e[t]);for(let t=0;t<s.arr.length;t++)s.arr[t]=i(s.arr[t])}return s};const sigmoid=t=>.5+.5*Math.tanh(.5*t);var D=t=>{let e=t.sizes[0],i=t.sizes[1],s=e-1;for(let e=0;e<i;e++)t.arr[s*i+e]=e==i-1?100:0};const X=()=>{if(W=!W){let t=0,e=0,i=0;do{i=(t=2*pseudorandomFraction()-1)*t+(e=2*pseudorandomFraction()-1)*e}while(i>=1||0==i);let s=Math.sqrt(-2*Math.log(i)/i);return _=t*s,e*s}return _},O=(t,e)=>Math.exp(-.5*(t*t+e*e)),bell=(t,e,i,s)=>i*Math.exp(-.5*sqr((s-t)/e)),V=t=>Math.floor(pseudorandomFraction()*t);var T=Math.tanh,G=5,I=1+2*G,N=3,z=I*N+1,Y=N,E=t=>{D(t)},U=t=>{for(let e=0;e<t.length;e++)E(t[e])},k=[z,Math.ceil(1.5*z),Y],L=null;const twoPi=2*Math.PI,J=eval('performance.timing.navigationStart'),q=()=>.001*(J+performance.now()),H=(t,e,i)=>mx(t,mn(e,i));var W=!1,_=0;const j=t=>document.getElementById(t);var Z=h(1<<21),K=(t,e)=>{let i=H(0,512+256*t,1023.99),s=H(0,512+256*e,1023.99),r=fl(i)<<11|fl(s)<<1;return{y:Z[r],x:Z[r+1]}},putHills=t=>{for(let t=0;t<Z.length;t++)Z[t]=0;for(let e=0;e<t.length;e+=6)Q(t[e],t[e+1],t[e+2],t[e+3],t[e+4],t[e+5])},Q=(t,e,i,s,r,n)=>{let h=ce(4*(256*i)),l=tt(0,512+256*t,1023),a=tt(0,512+256*e,1023);for(let t=l-h;t<l+h;t++)for(let e=a-h;e<a+h;e++){let h=2097151&(t<<11|e<<1),u=h+1,p=(t-l)/256/i,c=(e-a)/256/i,d=O(p,c),f=-s*((O(p+at,c)-d)/at),v=-s*((O(p,c+at)-d)/at),y=2.5;Z[h]=Math.tanh(Z[h]/y+d*r+f)*y,Z[u]=Math.tanh(Z[u]/y+d*n+v)*y}};let $=function(t,e,i,maxDistanceToAffectEachother,addRandomness,maxSpeed,friction,s,r,l,a){if(!s)throw'no points';let u=t,p=o.accelFieldMul;this.dt=e;let c=ut,d=c.centerY,x=c.centerX,b=c.radius,m=b*o.borderRadiusMul;this.undoableVoxels=[],this.numPoints=s;let g=Math.pow(o.maxDistanceToAffectEachother,2);if(e=mx(-.9,mn(e,.9)),this.yp=n(s),this.xp=n(s),this.yv=n(s),this.xv=n(s),this.red=h(s),this.green=h(s),this.blue=h(s),u){let t=new C([1,z]),n=u,a=u.perimeter(),p=h(s),c=h(s);for(let t=0;t<s;t++){let e=(t+1)%s,i=this.yp[e]-this.yp[t],r=this.xp[e]-this.xp[t],n=Math.hypot(i,r);p[t]=0==n?1:i/n,c[t]=0==n?0:r/n}let b=0;for(let h=0;h<s;h++){this.yp[h]=u.yp[h],this.xp[h]=u.xp[h],h>0&&(b+=Math.hypot(u.yp[h]-u.yp[h-1],u.xp[h]-u.xp[h-1]));for(let e=0;e<I;e++){let i=(e+h-G+s)%s;t.arr[3*e+f]=u.red[i]/127.5-1,t.arr[3*e+v]=u.green[i]/127.5-1,t.arr[3*e+y]=u.blue[i]/127.5-1}t[t.length-1]=1;let M=F(t,r,l),P=et(127.5+127.5*M.arr[f]),w=et(127.5+127.5*M.arr[v]),S=et(127.5+127.5*M.arr[y]),A=mx(0,mn(o.colorDecayPerSec*e,1));this.red[h]=u.red[h]*(1-A)+A*P,this.green[h]=u.green[h]*(1-A)+A*w,this.blue[h]=u.blue[h]*(1-A)+A*S;let R=0,C=0,B=e*o.scalePotentialEnergyForce,D=K(this.yp[h],this.xp[h]);R+=o.accelFieldMul*B*D.y,C+=o.accelFieldMul*B*D.x;for(let t=0;t<n.numPoints;t++){let e=this.yp[h]-u.yp[t],s=this.xp[h]-u.xp[t],r=e*e+s*s;if(0!=r&&r<=g){let e=t/n.numPoints*a,s=mn(Math.abs(e-b),Math.abs(e+a-b)),l=p[h],u=c[h],f=p[t],v=c[t],y=Math.sqrt(r),g=1-y/maxDistanceToAffectEachother,M=i(this.yp[h],this.xp[h],n.yp[t],n.xp[t],l,u,f,v,d,x,m,s)*g,P=i(this.yp[h]-at/2,this.xp[h],n.yp[t]+at/2,n.xp[t],l,u,f,v,d,x,m,s)*g,w=i(this.yp[h],this.xp[h]-at/2,n.yp[t],n.xp[t]+at/2,l,u,f,v,d,x,m,s)*g,S=(P-M)/at,A=(w-M)/at;R+=S*B,C+=A*B}}let O=addRandomness*Math.sqrt(Math.abs(e));if(0!=addRandomness){let t=(h+1)%s,e=this.yp[t]-this.yp[h],i=this.xp[t]-this.xp[h],r=Math.hypot(e,i);if(0!=r){let t=e/r,s=i/r,n=s,h=-t,l=O*X();R+=n*l,C+=h*l}}this.yv[h]=u.yv[h]+R,this.xv[h]=u.xv[h]+C;let V=Math.hypot(this.yv[h],this.xv[h]);if(0!=V){let t=mx(0,mn(V-friction*e,o.maxSpeed)),i=t/V;this.yv[h]*=i,this.xv[h]*=i}this.yp[h]+=this.yv[h]*e,this.xp[h]+=this.xv[h]*e,o.setSpeedsToZeroAfterEveryDtMove&&(this.xv[h]=this.yv[h]=0)}}else{let t=0,i=0,r=e*addRandomness,n=0,bootShape=eval(o.bootShapeYX||o.bootShape);for(let e=0;e<s;e++){let r=e/s*twoPi,h=cos(r),l=sin(r),a=bootShape(r);'number'==typeof a?(this.yp[e]=a*h,this.xp[e]=a*l):(this.yp[e]=a[0],this.xp[e]=a[1]),this.yp[e]=t+o.bootShapeY+o.bootShapeScale*this.yp[e],this.xp[e]=i+o.bootShapeX+o.bootShapeScale*this.xp[e],this.yv[e]=n*h,this.xv[e]=n*l,this.red[e]=this.green[e]=this.blue[e]=V(256)}a||this.balanceSparsityBoot(),s=this.numPoints}};const tt=(t,e,i)=>ro(mx(t,mn(e,i)));var et=t=>ro(mx(0,mn(t,255)));$.prototype.balanceSparsity=function(){let t=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue],e=this.numPoints,i=this.perimeterDistances(),s=i[e],r=H(mx(o.minPointsPerCurve,e-o.maxNumPointsPerCurveChangeAtOnce),Math.ceil(s/o.targetDistanceBetweenAdjacentCurvePoints),mn(e+o.maxNumPointsPerCurveChangeAtOnce,o.maxPointsPerCurve)),l=s/r;this.yp=n(r),this.xp=n(r),this.yv=n(r),this.xv=n(r),this.red=h(r),this.green=h(r),this.blue=h(r);let a=[this.yp,this.xp,this.yv,this.xv,this.red,this.green,this.blue];this.numPoints=r;let u=0;for(let s=0;s<r;s++){let r=s*l;for(;i[u+1]<r;)u++;let n=(u+1)%e,h=i[u+1]-i[u],p=(r-i[u])/h;for(let e=0;e<t.length;e++)a[e][s]=t[e][u]*(1-p)+p*t[e][n]}return builder&&displayText(this),s};var sqr=t=>t*t;$.prototype.balanceSparsityBoot=function(){let t=o.maxNumPointsPerCurveChangeAtOnce;o.maxNumPointsPerCurveChangeAtOnce=1e6,this.balanceSparsity(),o.maxNumPointsPerCurveChangeAtOnce=t},$.prototype.perimeter=function(){let t=this.perimeterDistances();return t[t.length-1]},$.prototype.perimeterDistances=function(){let t=this.numPoints,e=n(t+1);e[0]=0;for(let i=0;i<t;i++){let s=(i+1)%t,r=Math.hypot(this.yp[s]-this.yp[i],this.xp[s]-this.xp[i]);e[i+1]=e[i]+r}return e},$.prototype.holdInRect=function(t,e,i,s){for(let r=0;r<this.numPoints;r++)this.yp[r]=H(i,this.yp[r],s),this.xp[r]=H(t,this.xp[r],e)};var it=t=>JSON.parse(JSON.stringify(t)),ot=function(name,t,e,i,s){this.clicks=[],this.name=name,this.radius=new Float32Array(t);let r=.7+.6*pseudorandomFraction();for(let e=0;e<t;e++){let i=2*Math.PI*e/t;this.radius[e]=1+.3*(Math.sin(5*i*r)+Math.sin(7*i*r+.3))}this.red=e,this.green=i,this.blue=s,this.curve=null,this.domLabel=null};ot.prototype.sliderOrCheckboxValueNow=function(){let t=oo[this.name]*this.radiusAtAngle(l);return optionIsBit[this.name]?0<t:optionIsInteger[this.name]?Math.round(t)||1:t||at},ot.prototype.radiusAtAngle=function(t){let e=t/twoPi*this.radius.length;(e%=this.radius.length)<0&&(e+=this.radius.length);let i=Math.floor(e),s=(i+1)%this.radius.length,r=e-i;return this.radius[Math.floor(i)]*(1-r)+r*this.radius[s]},ot.prototype.copyRadiusArrayToCurve=function(){let t=this.radius.length;this.curve||(this.curve=dt(t));for(let e=0;e<t;e++){let i=2*Math.PI*e/t-l,s=loopRadiusOfZeroOption+loopRadiusMul*this.radius[e];this.curve.xp[e]=Math.sin(i)*s,this.curve.yp[e]=Math.cos(i)*s,this.curve.red[e]=this.red,this.curve.green[e]=this.green,this.curve.blue[e]=this.blue}};var st=(e,i,s,r,n)=>{for(let t in loops){let n=loops[t];n.countPaints&&n.paintOrUnpaint(e,i,s,r),n.countPaints=(n.countPaints||0)+1}for(let h in loops)if(!n||h==t){let t=loops[h];t.copyRadiusArrayToCurve(),t.curve.undoableVoxels=[],t.paintOrUnpaint(e,i,s,r)}},rt=function(t,e,i,s,addRandomness){this.curves=t,this.potentialEnergyFunc=e,this.neuralWeights=i,this.neuralFunc=s,this.addRandomness=null};rt.prototype.timePosition=function(){let t=0;for(let e=0;e<this.curves.length;e++)t+=this.curves[e].dt;return t};var nt=(t,e)=>{let i=0,s=e-t;if(s>0)i+=s*s*o.stayInsideBorderCircleForce;else{i+=10*(sigmoid(.001*(e/t))-sigmoid(.001))}return i},endist=eval(o.endist);if(!endist)throw'endist='+endist;var ht=(t,e,i,s,r,n,h,l,a,u,p,c)=>{let d=Math.hypot(i-t,s-e),en=0;if(!o.onlyEndist){o.distanceScale;let r=Math.hypot(t-a,e-u);Math.hypot(i-a,s-u);en=nt(p,r)+nt(p,r)}return en=endist(en,d,c)},at=1e-6,ut={centerY:0,centerX:0,radius:1},pt=()=>-.1+X(),ct=()=>{let t=[];for(let e=0;e<k.length-1;e++)t.push(new C([k[e],k[e+1]],pt));return U(t),t},dt=t=>new $(void 0,at,ht,o.maxDistanceToAffectEachother,0,o.maxSpeed,o.friction,t,ct(),T,!0),ft=()=>{let t=ct();return new rt([dt(o.minPointsPerCurve)],ht,t,T,null)},vt=()=>{At=!0,Rt=!0,builder&&clearLoops()},loops={},yt=()=>{adjustBordersOfOptions(oo)},xt=()=>{if(builder&&(putInDefaults(oo),o=e(oo)),!o.endist)throw'no endist';setColorSeed(oo.colorSeed),l=0,vt(),mt=[ft()];for(let t in oo.loops)loops[t]=s(t,oo.loops[t].length,!0);o.accelVoxels&&putHills(o.accelVoxels),builder&&(t=loops.timePosition?'timePosition':null,j('bootShapeEditor').value=o.bootShape)},bt=0,mt=[],Mt=()=>mt[0],Pt=q(),wt=()=>{let t=Mt(),e=q(),i=H(0,e-Pt,.1);l+=2*i*Math.PI/o.loopSeconds,(l%=twoPi)<0&&(l+=twoPi),r();let s=0;if(o.useTimePosition){let e=o.timePosition-t.timePosition();s=H(0,o.timePositionDecay,1)*i*e}else s=i*o.timeSpeed;s*=H(0,oo.computeSpeed,1),Pt=e,d=d*(1-i)+1;let n=s<0,h=s,a=s;for(o.negTimeDoesUndo&&n&&(bt=0);bt<t.curves.length-3&&o.negTimeDoesUndo&&s<0;)bt++,h=a,a=s,s+=Math.abs(t.curves[t.curves.length-bt].dt);let u=t.curves[t.curves.length-1-bt];if(o.negTimeDoesUndo&&(s=mx(0,s)),!u)return;let p=u.numPoints;if(0!=s){let e=new $(u,s,t.potentialEnergyFunc,o.maxDistanceToAffectEachother,o.addRandomness,o.maxSpeed,o.friction,p,t.neuralWeights,t.neuralFunc);o.balanceSparsity&&e.balanceSparsity();let i=1/(1-H(0,o.borderFraction,.95));e.holdInRect(-i,i,-i,i),t.curves.push(e)}t.curves.length>o.maxCurvesPerReef&&(t.curves=t.curves.slice(-o.maxCurvesPerReef))},St=(t,e,i,s,r,n,h,l)=>{let a=e.undoableVoxels.length>0,u=t&&!a,p=t,c=e.numPoints,d=0,f=t=>e.undoableVoxels.push(t);for(let t=0;t<c;t++){let a=(t+1)%c,p=ro(r+h*e.xp[t]),v=ro(s+n*e.yp[t]),y=ro(r+h*e.xp[a]),x=ro(s+n*e.yp[a]),b=y-p,m=x-v;d=mx(d,m*m+b*b);let g=o.sameColorness,M=o.paintBrightAdd,P=(e.red[t]*(1-g)+255*g)*o.paintBrightMult*o.brightMultRed+M,w=(e.green[t]*(1-g)+255*g)*o.paintBrightMult*o.brightMultGreen+M,S=(e.blue[t]*(1-g)+255*g)*o.paintBrightMult*o.brightMultBlue+M;o.wrapPaintBrightMult||(P=et(P),w=et(w),S=et(S)),u&&i.streamUndoable2dVoxelsForLineYXYXRGBSafe(f,v,p,x,y,P,w,S,l)}p&&i.paintVoxels(e.undoableVoxels)},At=!0,Rt=!0,Ct=null,Bt=()=>{let t=Mt();var e=j('aDiv');t.curves[t.curves.length-1];p=0,a=0,c=wi.innerHeight,u=wi.innerWidth;let i=(c+p)/2,s=(u+a)/2,r=Math.abs((1-o.borderFraction)*mn(c-p,u-a)/2),n=r,h=i+'_'+s+'_'+r+'_'+n;Ct!=h&&setTimeout(()=>{Rt=At=!0},200),Ct=h,builder&&''!=e.innerHTML&&(e.innerHTML='');let l=At;a+10<u&&p+10<c&&L.resizeCanvas(a,u,p,c);let d=L.byteRect;!At&&o.isSurface||(At=!1,L.beforePaint(),d=L.byteRect);for(let t=x;t<L.byteRect.length;t+=4)d[t]=255;if(!l){let e=Rt||!o.isSurface;if(Rt=!1,e)if(window.paintAccelField)paintAccelField(o.brightAddRed,o.brightAddGreen,o.brightAddBlue,o.brightMult,Z,0,1024,0,1024,L.byteRect,fl(i-2*n),fl(i+2*r),fl(s-2*n),fl(s+2*n));else{let t=d.b,e=et(o.brightAddRed),i=et(o.brightAddGreen),s=et(o.brightAddBlue);for(let r=0;r<t.length;r+=4)t[r+f]=e,t[r+v]=i,t[r+y]=s,t[r+x]=255}let h=o.ifCanvasUseUndoGraphics,l=t.curves.pop();if(h&&bt>0){for(;t.curves.length>2&&bt>0;){let e=t.curves.pop();St(h,e,L.byteRect,i,s,r,n,mx(1,o.lineThick)),bt--}bt=0}t.curves.push(l),St(h,l,L.byteRect,i,s,r,n,mx(1,o.lineThick)),builder&&chkBuilder()&&tryDispOutCirc(i,s,r,n)}builder&&bldDisp(i,s,r,n),L.afterPaint()},Ft=!1,Dt=0,Xt=()=>{Dt++;var t=!0;if(o.pause||o.computeSpeed<=0)t=!1;else{let e=Math.ceil(1/o.computeSpeed);t=Dt%e==0}t&&(wt(),Bt()),requestAnimationFrame(Xt)},Ot=null;wi.onload=(()=>{Ft=!0,builder&&bootBuilder(),Ot=j('divabxy'),L||(L=new b(Ot)),xt(),Xt()});";

//putminifiedcodehere^^^


let thingsMinifiedCodeShouldntContain = ['var lt=', 'var gt=', 'var amp=', 'var nbsp='];
//If you dont tell uglifyjs not to make a var name lt, it sometimes does.
//You can tell it not to by including that in mangle reserved.
//RIGHT: if(builder&&chkBuilder()&&o.displayOuterCircle&<(i,r,s,n),!o.displayOuterCircle)for(let t in loops)
//WRONG: if(builder&&chkBuilder()&&o.displayOuterCircle&&lt(i,r,s,n),!o.displayOuterCircle)for(let t in loops)
for(let dontContain of thingsMinifiedCodeShouldntContain){
	if(minifiedJavascriptFromUglifyjs.includes(dontContain)){
		throw 'minified code contains: '+dontContain+' which is likely to cause parsing errors in poolpm when eval(code) (code is a var) just after it decompresses/stringSubstitutes.'
		//Error example in poolpm:
		/*
		Uncaught SyntaxError: Unexpected token '<'
		at eval (eval at <anonymous> (data:text/html,<html><head><script>'use%20strict';let%20o={endist:'(en,dist,pdist)=>{%20let%20x%20=%200;%20let%20p%20=%20o;%20let%20nd%20=%20p.nearPdist;%20let%20near%20=%20sigmoid(-5*(dist-nd));%20if(dist%20>%20o.attractIfFartherThan)%20x%20+=%20o.ampAttractIfFartherThan*sqr(dist-o.attractIfFartherThan);%20x%20+=%20o.ampStraightIfNear*near*sqr(dist-pdist);%20let%20midDist%20=%20p.midDist;%20x%20+=%20bel
		*/
	}
}


/*var stringReplacements = [
	'this.','a@',
	'function','b@',
	'let ','c@',
	'return','d@',
	'.prototype.','e@',
	'radius','f@',
	'curve','g@',
	'numPoints','h@',
	'for(let ','i@',
	'sizes[','j@',
	'Point','k@',
	'const ','l@',
	'loops','m@',
	'maxNumPointsPerCurveChangeAtOnce','n@',
	'addRandomness','o@',
	'green','p@',
	'blue','q@',
	'Math.','r@',
	'balanceSparsity','s@',
	'undoableVoxels','t@',
	'.length','u@',
	'hypot(','v@',
	'write','w@',
	';for(','x@',
	'byteRect','y@',
	'maxDist','z@',
	'dist','A@',
	
	
	//'pseudorandomNext','z@',
]; //TODO find more things to make it smaller
*/

var suffixHtml = "</scr"+"ipt></he"+"ad><bo"+"dy style='background-color:black;color:white;user-select:none'><di"+"v id=divabxy style='background-color:black;color:white;width:0px;height:0px'></di"+"v></bo"+"dy></ht"+"ml>";







let charsIn = s=>{
	let map = {};
	let list = [];
	for(let i=0; i<s.length; i++){
		let c = s.charAt(i);
		if(!map[c]){
			list.push(c);
			map[c] = true;
		}
	}
	list.sort();
	return list.join('');
};


/*
let optionNum = 100;
for(let option in o){
	if(option.length > 8){
		let replacement = 'o'+(optionNum++);
		stringReplacements.push(option, replacement);
	}
}
*/



/*TODO generate random bootshape code string then test it like in setBootShapeAndRestart but just the testing part, then try many random more of them, until find one worth displaying,
then the button to generate a random one finishes...
"Just type random combos of these into the a=>[ ... , ... ] / % * + - ( ) Math.abs Math.acos Math.acosh Math.asin Math.asinh Math.atan Math.atan2 Math.atanh Math.cbrt Math.ceil Math.clz32 Math.cos Math.cosh Math.exp Math.expm1 Math.floor Math.fround Math.hypot Math.imul Math.log Math.log1p Math.log2 Math.log10 Math.max Math.min Math.pow Math.round Math.sign Math.sin Math.sinh Math.sqrt Math.tan Math.tanh Math.trunc"
*/


var testBootShapeElseThrow = (code,maxRadius)=>{
	if(!maxRadius) maxRadius = 10;
	let func = eval(code);
	let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minR = Infinity, maxR = -Infinity;
	let isYX = false;
	for(let angle=0; angle<2*Math.PI; angle+=.01){
		let sh = func(angle);
		if(typeof(sh)=='number'){
			if(Math.abs(sh) > maxRadius || isNaN(sh)) throw 'Too big (or is NaN), when called on '+angle+' it returned '+sh+'. And you should try to keep it between 0 and 1 or sometimes up to 2.';
			minR = Math.min(minR, sh);
			maxR = Math.max(maxR, sh);
		}else{
			if(sh.length != 2) throw 'Not length 2 like [.3,.4], when called on '+angle+' it returned '+sh;
			for(let j=0; j<2; j++) if(Math.abs(sh[j]) > maxRadius || isNaN(sh[j])) throw 'Too big (or NaN), when called on '+angle+' then ['+j+'] it returned '+sh[j]+'. And you should try to keep it between 0 and 1 or sometimes up to 2.';
			minY = Math.min(minY, sh[0]);
			maxY = Math.max(maxY, sh[0]);
			minX = Math.min(minX, sh[1]);
			maxX = Math.max(maxX, sh[1]);
			isYX = true;
		}
	}
	if(isYX){ //[y,x]
		let s = 'y ranges '+minY+' to '+maxY+' and x ranges '+minX+' to '+maxX+', as in returning [y,x].';
		if(Math.abs(maxY-minY) < .05 || Math.abs(maxX-minX) < .05) throw 'Too small, '+s;
		if(minY < -maxRadius || maxRadius < maxY || minX < -maxRadius || maxRadius < maxX) throw 'Too far outside the main area, '+s;
	}else{ //radius
		if(maxR < .19) throw 'Too small, max radius is '+maxR;
	}
};


//Examples: 'a=>.2' Example: 'a=>[2+Math.sin(a*5),a*a]' Example: 'a=>{a*=2/Math.PI; if(a<1) return [a%1-.5,-.5]; if(a<2) return [a%1-.5,.5]; if(a<3) return [-.5,a%1-.5]; return [.5,a%1-.5];}'
var setBootShapeAndRestart = code=>{
	let worked = true;
	try{
		testBootShapeElseThrow(code);
		o.bootShape = oo.bootShape = code;
		restart();
		dom('bootShapeEditorErr').innerHTML = 'bootShape is probably OK, using it.';
	}catch(e){
		worked = false;
		dom('bootShapeEditorErr').innerHTML = 'Cant use that bootShape cuz: '+e;
	}
	dom('bootShapeEditorErr').disabled = !worked;
};

//var setBootShape














//////0000 nft maker/builder above, stuff that goes in nft below. move this line down as I move things around. the options var will be set externally when the above is gone.///////

//FIXME some of the stuff in this section (between //000 and //aaa) doesnt go into the nonminifiedJavascript var and should be moved to above the //000.
//bootShapePartsMap should not be here since its part of the builder, not part of the NFTs.

//in NFTs, this will be "var builder = false;".
var builder = true; //display the reef builder (sliders, checkboxes, buttons, etc). The NFTs are too small to include the builder.
//var builder = false;



//bigints (such as 0x5DEECE66Dn) dont work in uglifyjs minifier, so they go with the "builder = false" that doesnt get minified.

/* tiny piece of math in java.util.Random weak pseudorandomness generator
https://developer.classpath.org/doc/java/util/Random-source.html
let public synchronized void setSeed(long seed)
152:   {
153:     this.seed = (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1);
154:     haveNextNextGaussian = false;
155:   }
156: 
157:   /**
158:    * Generates the next pseudorandom number.  This returns
159:    * an int value whose <code>bits</code> low order bits are
160:    * independent chosen random bits (0 and 1 are equally likely).
161:    * The implementation for java.util.Random is:
162:    *
163: <pre>protected synchronized int next(int bits)
164: {
165:   seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L &lt;&lt; 48) - 1);
166:   return (int) (seed &gt;&gt;&gt; (48 - bits));
167: }</pre>
168:    *
169:    * @param bits the number of random bits to generate, in the range 1..32
170:    * @return the next pseudorandom value
171:    * @since 1.1
172:    *
173:   protected synchronized int next(int bits)
174:   {
175:     seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);
176:     return (int) (seed >>> (48 - bits));
177:   }
*/

var seed = BigInt64Array.of(0n); //replaced in restart() with oo.colorSeed

var getColorSeed = ()=>seed[0];

//sss is a double 0 to 2^48-1
var setColorSeed = sss=>{ //renamed from s to sss cuz uglifyjs created a var s and didnt rename that cuz setColorSeed func isnt minified cuz uglifyjs doesnt do bigints
	seed[0] = (BigInt(sss) ^ 0x5DEECE66Dn) & ((1n << 48n) - 1n);
};

//for repeatable pseudorandom colors as the neuralnet weights, NFT params, etc, but uses Math.random() (not repeatable) for addRandomness
//Without this, you wouldnt be able to generate a certain reef (genereef0001 to genereef8888) exactly the same json, if you compute it again later.
//It has generated the exact same json (TODO keep testing) the few times I looked, in different browsers,
//and it does seem the colors are usually repeatable, and the colorseed is always repeatable, but the same colorseed makes the same neuralnet weights
//and cuz of small differences of timing etc, the reef can differ over time, but its supposed to at least start the exact same way in the same reef.
var pseudorandomNext = bits1To32=>{
	seed[0] = (seed[0] * 0x5DEECE66Dn + 0xBn) & ((1n << 48n) - 1n);
	//let retLong = (seed[0] >>> (48n - bits1To32));
	let retLong = (seed[0] >> (48n - BigInt(bits1To32)));
	return Number(retLong)|0; //as int
};

var pseudorandomFraction = ()=>pseudorandomNext(31)/0x80000000;

/** with seed 42 (oo.colorSeed is 42).

tested it against javas Random.next(int) func...

https://www.tutorialspoint.com/compile_java_online.php

public class HelloWorld extends java.util.Random{
    
    public HelloWorld(){
        super(42L);
    }
    
    public int NEXT(int n){
        return super.next(n);
    }

     public static void main(String []args){
         HelloWorld h = new HelloWorld();
        System.out.println("Hello World "+h.next(10)+" "+h.next(10)+" "+h.next(10));
     }
}

$javac HelloWorld.java
$java -Xmx128M -Xms16M HelloWorld
Hello World 745 55 699

matches browser console

pseudorandomNext(10n)
745
pseudorandomNext(10n)
55
pseudorandomNext(10n)
699

*/

//use the letters Z Y X W V U T S (but not M cuz it occurs in Math) ... (this is bootShapePartVars), and they will be auto replaced.
//Use the first n of them, like Z Y X or Z Y, but not Y and U for example.
var bootShapePartsMap = {
	'100': 1,
	'10': 2,
	'3.5': 1,
	'3': 3,
	'2.5': 1,
	'2': 3,
	'1.5': 2,
	'1': 5,
	'0.7': 2,
	'0.5': 2,
	'0.4': 1,
	'0.3': 1,
	'0.2': 1,
	'0.1': 1,
	'1': 5,
	'-1': 1,
	'-2': 2,
	'-2.5': 1,
	'-3': 2,
	'-3.5': 1,
	'M.max(0,M.min(Z,1))': 30,
	'M.PI': 1,
	'M.E': 1,
	'-Z': 60,
	'(Z+Y)': 340,
	'(Z*Y)': 240,
	'(Z/Y)': 220,
	'(Z%Y)': 210,
	'(Z<0 ? Y : X)': 10,
	'(M.sin(Z))': 230,
	'M.cos(Z)': 30,
	'M.tanh(Z)': 160,
	'M.abs(Z)': 30,
	'(1+M.sin(Z))': 20,
	'(2+M.sin(Z))': 30,
	'(1/(1+Z))': 50,
	'Z*Z': 30,
	'M.sqrt(M.abs(Z))': 40,
	'M.cbrt(M.abs(Z))': 20,
	'M.cbrt(M.abs(Z))': 20,
	'M.exp(Z)': 10,
	'M.log(M.abs(Z))': 40,
	'M.min(Z,Y)': 40,
	'M.max(Z,Y)': 40,
	'M.hypot(Z,Y)': 50,
	'M.sign(Z)': 10,
	'M.floor(Z)': 10,
	'M.round(Z)': 10,
	'M.ceil(Z)': 10,
	'M.sign(Z*Y)*M.sqrt(M.abs(Z*Y))': 50,
	'M.cbrt(Z*Y*X)': 30,
};

var bootShapePartVars = 'ZYXWVUTS';

var numberOfVarsInBootShapePart = bootShapePart=>{
	let sum = 0;
	for(let varName of bootShapePartVars) if(bootShapePart.includes(varName)) sum++;
	for(let i=sum; i<bootShapePartVars.length; i++){
		let varName = bootShapePartVars[i];
		if(bootShapePart.includes(varName)) throw 'Must use earlier vars in '+bootShapePartVars+' before any later vars. In bootShapePart='+bootShapePart;
	}
	return sum;
};

//has duplicates to change the chances. how many duplicates is keys in bootShapePartsMap.
var bootShapeParts = [];
for(let code in bootShapePartsMap){
	for(let i=0; i<bootShapePartsMap[code]; i++) bootShapeParts.push(code);
}

var randIntByRealRand = n=>Math.floor(Math.random()*n);

var chooseByRealRand = list=>list[randIntByRealRand(list.length)];

//uses Math.random, not the colorSeed repeatable pseudorandomness
var randomBootShape = (numVars,isYXElseRadius)=>{
	if(isYXElseRadius === undefined) isYXElseRadius = true;
	let n = 'abcdefghijklmnopqrstuvwxyz'.split(''); //var names in generated code. replace the bootShapePartVars var names with these
	let minVars = 3, maxVars = n.length;
	if(numVars < minVars || numVars > maxVars) throw 'numVars must range '+minVars+' to '+maxVars;
	while(n.length > numVars) n.pop();
	let v = 0; //vars used
	let inVar = n[v++]; //var name of param of bootShape function. That param ranges 0 to 2*Math.PI. Returns a [yPosition,xPosition] for each, jumping ahead by a tiny angle at a time.
	let code = inVar+'=>{let M=Math;'+inVar+'/=(2*M.PI);';
	while(v < numVars){
		let tempVar = n[v++]; //such as m n o p or q
		let bootShapePart = chooseByRealRand(bootShapeParts);
		let partNumVars = numberOfVarsInBootShapePart(bootShapePart); //its vars are the first partNumVars of bootShapePartVars such as Z Y and X if it has 3 vars
		let modifiedBootShapePart = bootShapePart;
		for(let i=0; i<partNumVars; i++){
			let partVar = bootShapePartVars[i]; //such as Y
			let otherTempVar = n[randIntByRealRand(v-1)]; //v-1 to read any tempVar thats been written so far, such as c
			//its ok for otherTempVar to use the same var multiple times. Example: Z*Y becomes 'c*c', instead of 'c*somethingElse'.
			modifiedBootShapePart = modifiedBootShapePart.replaceAll(partVar,otherTempVar);
		}
		code += 'let '+tempVar+'='+modifiedBootShapePart+';'
	}
	let outVarForYPosition = n[numVars-2]; //return the last 2 vars in a []. Could also return 1 var to use as radius, of inVar is angle.
	let outVarForXPosition = n[numVars-1];
	let outVarForRadius = outVarForXPosition; //last var
	code += isYXElseRadius ? ('return ['+outVarForYPosition+','+outVarForXPosition+'];}') : ('return '+outVarForRadius+';}');
	return code;
};

randomBootShapeThatPassesTests = (numVars,isYXElseRadius)=>{
	let maxI = 1000;
	code = 'no code yet';
	for(let i=0; i<maxI; i++){
		code = 'no code yet';
		try{
			code = randomBootShape(numVars,isYXElseRadius);
			testBootShapeElseThrow(code,1);
			return code;
		}catch(e){
			console.log('Code didnt pass test. Code='+code+' Failed cuz: '+e);
		};
	}
	return '//Didnt find an ok bootShape in '+maxI+' tries.\r\n'+code;
};

var colorStr = (red,green,blue)=>{
	let r = asByte(red);
	let g = asByte(green);
	let b = asByte(blue);
	let s = '000000'+(r*65536+g*256+b).toString(16);
	return '#'+s.substring(s.length-6);
};


var buboot = ()=>{
	o = lossyCompressOptions(o);
	console.log(lossyCompressOptionsStr(o));
	bootUrlParams(); //can do filename.html?maxSpeed=.3&isSurface=true in builder html but not in NFTs, cuz we dont have space for it even though its very small code.
};

//Whatever this is at time of logging, it will concat this to the log line, for some things that occur often during
//the very long wait of making a batch of maxcompressed reefs. This is for logging the progress. Only in builder.
var sharedLogSuffix = " - sharedLogMessage_starts_as_this";


//////AAAA nft maker/builder above, stuff that goes in nft below. move this line down as I move things around. the options var will be set externally when the above is gone.///////



if(!window.o) throw 'opt';
if(!o.endist) throw 'endist';

var selectedOption = null;

//if(!o.computeSpeed) o.computeSpeed = 1;

var copyMap = map=>JSON.parse(JSON.stringify(map));

if(builder) buboot();


//oo is a number to scale some options by (not including strings or lists), or scale by 1 if its a checkbox.
//o is the options, such as o.timeSpeed and o.minPointsPerCurve. Dont modify o directly. Modify oo since o[option] is set to loops[option].sliderOrCheckboxValueNow() many times per second.
window.oo = {};
oo.endist = o.endist;
//if(!oo) throw 'No oo/loopOptions';

oo.loops = copyMap(o.loops || {});
eval('console.log(JSON.stringify(oo));');


//var maxLoopsAtOnce = 100; //FIXME remove this

var optionIsBit = {};
var optionIsInteger = {};
//var optionIsRecordGroovable = {};
//o contains true/false integer double/float64 and string and TODO also list of numbers for the Loops.
//oo contains true/false integer double/float64 but not the other things
//let numLoopsStartedWith = 0;
for(let option in o){
	let opt = o[option];
	optionIsBit[option] = (opt===false || opt===true);
	//FIXME it might be a double/float64 that happens to be an integer.
	//In that case it would get stuck being an integer, so TODO make sure options that can be smooth/double/float64 dont have integer values.
	//optionIsRecordGroovable[option] = optionIsBit[option] || (typeof(opt)=='number');
	optionIsInteger[option] = Number.isInteger(opt);
	
	
	//FIXME what about type 'bigint' such as 42n is a bigint
	//if((optionIsBit[option] || (typeof(opt)=='number')) && numLoopsStartedWith<maxLoopsAtOnce){
	if((optionIsBit[option] || (typeof(opt)=='number'))){
		oo[option] = o[option]; //else dont make Loop (like record grooves) for that option.
		//numLoopsStartedWith++;
	}
};









var rndc = ()=>56+200*pseudorandomFraction();

var newLoop = (option,size,copyFromOptions)=>{
	//If !o.loops[option] then there is no loop for that option. Normally a reef has 0-10 loops, but theres alot more options than that which are constant.
	//Why? Have to fit the loop radiuses in 16k of cardano, and cuz its confusing to have so many things changing andOr displayed at once.
	let red = rndc();
	let green = rndc();
	let blue = rndc();
	/*let red = epsilon+Math.random();
	let green = epsilon+Math.random();
	let blue = epsilon+Math.random();
	let sum = red+green+blue;
	red /= sum; //constant brightness, varying color
	green /= sum;
	blue /= sum;
	*/
	let data = oo.loops[option];
	//WARNING: size must not differ from o.loops[option].size if o.loops[option] exists AND copyFromOptions.
	//If !copyFromOptions it can be any positive integer (best if < 1000)
	let loop = new Loop(option, size, red, green, blue);
	if(copyFromOptions) for(let i=0; i<data.length; i++) loop.radius[i] = data[i]; //copy loop shape from options
	return loop;
};

var loopsUpdateSlidersAndChks = ()=>{
	for(let option in oo){
		if(o.loops[option]){
			if(!loops[option]){ //create Loop/recordGroove for that option if not exist and is a slider or checkbox option.
				loops[option] = newLoop(option,o.loops[option].length);
			}
			//update the option based on the turing record groove for that option.
			o[option] = loops[option].sliderOrCheckboxValueNow();
		}else{
			//cuz sliders change whats in oo. Whats in o is generated, either by just copying it or if a
			//Loop exists then by multiplying (or add 1, scale it somehow?) whats in oo by the current loop radius at loopAngle (loopAngle moves based on o.loopSeconds).
			o[option] = oo[option];
			
		}
	}
};

//replace the loops map with the loops in o.loops.
//var copyOptionsToLoops = ()=>{
//};

const ro = Math.round, mn = Math.min, mx = Math.max, sin = Math.sin, cos = Math.cos, wi = window, px = 'px', fl = Math.floor, ce = Math.ceil;

const nf64 = i=>new Float64Array(i);
const nf32 = i=>new Float32Array(i);




//range 0 to 2*pi
var loopAngle = 0;


/*
wi.onload = ()=>{
	//console.log('window.onload...');
	if(builder) bootBuilder();
	restart();
};*/


////MIT licensed opensource above, things more specific to reefs below (but some parts below are just general math)
// /script
// script

//if(!o.forceMaxResolution) throw 'TODO allow !forceMaxResolution';

var minX = 350; //FIXME this should stretch to whole screen instead of being stored here
var maxX = 850;
var minY = 100;
var maxY = 600;

//var takingPic = false;
//var snapshotH = 50;
//var snapshotW = 50;

var framesPerSecond = 60;

//FIXME make canvas size maxX-minX x maxY-minY.

/*TODO slider object type that reads/writes its value in o/options map,
and maybe that has a function to scale it nonlinearly.
use some of those to tune friction, attraction to center, etc,
to make it look like a reef. then copy/paste the options map json
so dont have to move the sliders again last time.
*/


/*
The canvas/ByteRect code are opensource MIT licensed by Ben F Rayfield
at various projects including https://github.com/benrayfield/augmentedballs
and https://github.com/benrayfield/jsutils/blob/master/src/arvox/arvox.html
and https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html
Some of those were GPL2+ but ben multilicensed this code to MIT later.
AugmentedBalls is the newest code as of 2021-12-2 but the various projects dont have all the functions
cuz trying to keep the code small.
*/

const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;//, COLORDIMS = 4;

var FullScreenCanvas = function(parentDom){
	console.log('the canvas/ByteRect code are opensource MIT licensed by Ben F Rayfield.');
	
	//TODO constant resolution and just stretch.
	
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = dom('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	let s=this.dom.style;
	this.dom.width = 10;
	this.dom.height = 10;
	s.position = 'absolute';
	s.left = '0px';
	s.top = '0px';
	s.zIndex = -1000000; //behind most things
	
	//If h and w arent given, its fullscreen
	this.resizeCanvas = function(minX, maxX, minY, maxY){
		//FIXME this might slow things down to call it every video frame?
	
		//console.log('resizeCanvas x '+minX+' '+maxX+' y '+minY+' '+maxY+' this.dom.width='+this.dom.width);
		/*let s=this.dom.style;
		let newH = (h || window.innerHeight);
		let newW = (w || window.innerWidth);
		if(this.dom.height != newH || s.height != newH){
			this.dom.height = newH;
			s.height = newH;
		}
		if(this.dom.width != newW || s.width != newW){
			this.dom.width = newW;
			s.width = newW;
		}*/
		
		/*if(minX === undefined) minX = 0;
		if(maxX === undefined) maxX = mx(10,wi.innerWidth);
		if(minY === undefined) minY = 0;
		if(maxY === undefined) maxY = mx(10,wi.innerHeight);
		*/
		if(!minX) minX = 0;
		if(!maxX) maxX = mx(10,wi.innerWidth);
		if(!minY) minY = 0;
		if(!maxY) maxY = mx(10,wi.innerHeight);
		let newW = maxX-minX, newH = maxY-minY;
		//if(newW <= 0 || newH <= 0) throw 'newW='+newW+' newH='+newH;
		//this.dom.height = newH+px;
		//this.dom.width = newW+px;
		let d = this.dom;
		let s = d.style;
		d.setAttribute('height', newH+px);
		d.setAttribute('width', newW+px);
		s.height = newH+px;
		s.width = newW+px;
		s.top = minY+px;
		s.left = minX+px;
		//if(s.height != newH) s.height = newH;
		//if(s.width != newW) s.width = newW;
		//if(s.top != minY) s.top = minY;
		//if(s.left != minX) s.left = minX;
		
	};
	
	//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	this.beforePaint = function(){
		//if(this.dom == N) throw 'No canvas';
		this.context = this.dom.getContext('2d');
		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, mx(10,this.dom.width), mx(10,this.dom.height));
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};
	
	//call this after modify byteRect.b which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		//if(this.dom == N) throw 'No canvas';
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.resizeCanvas(0,10,0,10);
	this.beforePaint();
};

var ByteRect = function(bytes, height, width){
	this.b = bytes;
	this.h = height;
	this.w = width;
};

var BR = ByteRect;

let brp = BR.prototype;

/*brp.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	let ind = (y*this.width+x)*4;
	this.b[ind+RED] = redByte;
	this.b[ind+GREEN] = greenByte;
	this.b[ind+BLUE] = blueByte;
};*/

brp.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(ro(y)*this.w+ro(x))*4,this.b.length-4);
	this.b[index+RED] = redByte;
	this.b[index+GREEN] = greenByte;
	this.b[index+BLUE] = blueByte;
	this.b[index+ALPHA] = optionalAlphaByte;
};

/*Theres 53 bits. how to spread them?
r g b takes 24 bits, so 29 left. y14 x14 r8 g8 b8 so max resolution is 16384x16384
(and must be much smaller cuz of speed and maybe memory).
*/


//This kind of undoable voxel is not very efficient compared to writing ByteRect.bytes directly,
//but if you're only writing maybe any 50k of a million pixels per video frame it will probably be fast enough.
const twoPow38 = Math.pow(2,38);
const twoPow14MinusOne = (1<<14)-1;
const twoPow24 = 1<<24;

//for single pixel voxels
BR.voxelY = voxel=>(fl(voxel/twoPow38)&twoPow14MinusOne);
BR.voxelX = voxel=>(fl(voxel/twoPow24)&twoPow14MinusOne);
BR.voxelXorRed = voxel=>((voxel>>16)&255);
BR.voxelXorGreen = voxel=>((voxel>>8)&255);
BR.voxelXorBlue = voxel=>(voxel&255);
BR.voxelYXXorsRGB = (y,x,redXorByte,greenXorByte,blueXorByte)=>(
	//must + instead of << | etc here cuz those are 32 bit ops that would drop the higher double bits,
	//but for efficiency use those int ops to make 2 ints before making the double (range 0 to Math.pow(2,52)-1).
	( ((y&twoPow14MinusOne)<<14) | (x&twoPow14MinusOne) ) * twoPow24 + (((redXorByte&255)<<16) | ((greenXorByte&255)<<8) | (blueXorByte&255))
);

/*
This is getting too big. Just use 6 numbers for each accelVoxel..

//for putHill voxels... //putHill(normY, normX, radius, repelForce, accelY, accelX);
//y10 x10 (1 pixel precision in 1024x1024x2 accelField) radius9(as 1/4 pixel precision) red8 green8 blue8, so the rgb is the same in both kinds of voxel.
const twoPow9Minus1 = (1<<9)-1;
const twoPow10Minus1 = (1<<10)-1;
BR.voxelY10 = voxel=>(fl(voxel/twoPow43)&twoPow10Minus1);
BR.voxelX10 = voxel=>(fl(voxel/twoPow33)&twoPow10Minus1);
BR.radius9 = voxel=>(fl(voxel/twoPow24)&twoPow9MinusOne);
//voxelYp etc is the same coordinates as curve.yp, where center is (0,0) and border/smallest circle is radius 1, and the accelField ranges -2 to 2 in x and y.
//green is horizontal accel. blue is vertical accel. red is attract/repel from voxel center. TODO choose a scale for these.
//The color view of attract/repel and accel direction doesnt have to match the background graphics exactly, but yp xp and r do.
BR.voxelYp = voxel=>(BR.voxelY10(voxel)-512)/256; //-2 to 2
BR.voxelXp = voxel=>(BR.voxelX10(voxel)-512)/256; //-2 to 2
BR.voxelR = voxel=>BR.radius9(voxel)/1024; //1/4 pixel precision but still on the scale of yp and xp (but cant get as big). FIXME verify that scale.
BR.voxelRepelForce = voxel=>(BR.voxelXorRed(voxel)-128)/32;
BR.voxelAccelY = voxel=>(BR.voxelXorBlue(voxel)-128)/32;
BR.voxelAccelX = voxel=>(BR.voxelXorGreen(voxel)-128)/32;

//inverse of BR.voxelYp BR.voxelXp BR.voxelR BR.voxelXorRed BR.voxelBlue voxelXorGreen. TODO reorder params various places to be red green blue?
BR.voxelHill = (normY, normX, radius, repelForce, accelY, accelX)=>{
	let y = betweenInt(0,512+256*normY,1023);
	let x = betweenInt(0,512+256*normX,1023);
	let r = betweenInt(0,radius*1024,511);
	let red = asByte(128+32*repelForce);
	let green = asByte(128+32*accelX);
	let blue = asByte(128+32*accelY);
	//must + instead of << | etc here cuz those are 32 bit ops that would drop the higher double bits,
	//but for efficiency use those int ops to make 2 ints before making the double (range 0 to Math.pow(2,52)-1).
	return ( ((y&twoPow10Minus1)<<19) | ((x&twoPow10Minus1)<<9) | r ) * twoPow24 + (((red&255)<<16) | ((green&255)<<8) | (blue&255));
};
*/

//Param is a double that could be made by ByteRect.undoable2dVoxel.
//uses xor to write or undo (is its own inverse) a double containing bits for y x xorRed xorGreen xorBlue.
//Calling this twice on the same param leaves it as it was
//even if other voxels have been written other places between that, aka undoable.
brp.writeSafeUndoable2dVoxel = function(voxel){
	let y = BR.voxelY(voxel);
	let x = BR.voxelX(voxel);
	let r = BR.voxelXorRed(voxel); //xor this with the byte in the pic
	let g = BR.voxelXorGreen(voxel);
	let b = BR.voxelXorBlue(voxel);
	this.writeSafeXorRGB(y,x,r,g,b);
};

//If theres no overlap of (y,x) positions in the param, then this does paint and undo.
//If there is, then the correct way is to reverse the array before calling this,
//and it will exactly undo.
brp.paintVoxels = function(voxels){
	for(let i=0; i<voxels.length; i++){
		this.writeSafeUndoable2dVoxel(voxels[i]);
	}
};

/*
//paints in reverse order of the voxels array.
//If theres no overlap of (y,x) position, this does the same thing as forward/paintVoxels.
brp.paintVoxelsReverse = function(voxels){
	for(let i=0; i<voxels.length; i++){
		this.writeSafeUndoable2dVoxel(voxels[i]);
	}
};*/

//returns a double that would paint the chosen colors in an undoable way.
//These are not xor colors, but the voxel reads whats there already and finds the xor that would paint this color.
brp.undoable2dVoxel = function(y, x, redByte, greenByte, blueByte){
	let i = between(0,(Math.floor(y)*this.w+Math.floor(x))*4,this.b.length-4);
	return BR.voxelYXXorsRGB(y, x, redByte^this.b[i+RED], greenByte^this.b[i+GREEN], blueByte^this.b[i+BLUE]);
};

/*
//voxel is a double in range 0 to Math.pow(2,52)-1 that can be any 24 bit color in up to 16384x16384 resolution.
//Calling this twice on the same param writes then undo it,
//even if theres other calls of this for other voxels between that.
brp.writeUndoable2dVoxel = function(voxel){
	THIS IS NAMED WRONG AND CONFUSING
	let i = between(0,(Math.floor(y)*this.w+Math.floor(x))*4,this.b.length-4);
	return ByteRect.voxelYXXorsRGB(y, x, redByte^this.b[i+RED], redByte^this.b[i+GREEN], redByte^this.b[i+BLUE]);
};*/

brp.writeSafeXorRGB = function(y, x, redXorByte, greenXorByte, blueXorByte){
	let index = between(0,(Math.floor(y)*this.w+Math.floor(x))*4,this.b.length-4);
	this.b[index+RED] ^= redXorByte;
	this.b[index+GREEN] ^= greenXorByte;
	this.b[index+BLUE] ^= blueXorByte;
	//this.b[index+ALPHA] = optionalAlphaByte;
	this.b[index+ALPHA] = 255; //visible
};

/*TODO how to make a set of undoable lines?
Use pixelIndex and int to xor there? or per byte?
Store it in double? would only need 48 bits, 24 for which pixel, and 24 for color to xor there,
	but double might be slower than 2 ints, even though in js each int is sometimes computed as a double.
Could use 1024x1024 resolution and 12 bit color, that fits in int.
Or could just use an XOR paintbrush to start with?
*/


//calls listener(voxel) once per voxel.
//Can use this instead of paintLineYXYXRGBSafe to paint in an undoable way
//(thats not fast enough to update all the pixels each video frame).
brp.streamUndoable2dVoxelsForLineYXYXRGBSafe = function(listener, fromY, fromX, toY, toX, redByte, greenByte, blueByte, lineThick){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	let prevY = -1, prevX = -1;
	let frY = fromY;
	let frX = fromX;
	//for(let j=-lineThick/2; j<lineThick/2; j++){ //FIXME off by 1 pixel?
	for(let j=0; j<lineThick; j++){ //FIXME off by 1 pixel?
	
		//TODO paint circle at ends
	
		for(let i=0; i<numPoints; i++){
			//TODO optimize
			let y = ro(frY+diffY*i/numPoints);
			let x = ro(frX+diffX*i/numPoints);
			if(y==prevY && x==prevX) continue;
			//this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
			//this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
			let voxel = this.undoable2dVoxel(y, x, redByte, greenByte, blueByte);
			listener(voxel);
			//avoid xoring the color at same (y,x) more than once in this call,
			//except between multiple calls, 2 lines that one starts where the other ends likely share that point
			//so would have the wrong color there? FIXME?
			prevY = y;
			prevX = x;
		}
		frY += diffX/len; //FIXME?
		frX += diffY/len;
	}
};

/*
//TODO merge code with streamUndoable2dVoxelsForLineYXYXRGBSafe ?
brp.paintLineYXYXRGBSafe = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte, lineThick){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let j=0; j<lineThick; j++){
		for(let i=0; i<numPoints; i++){
			//TODO optimize
			let y = ro(fromY+diffY*i/numPoints);
			let x = ro(fromX+diffX*i/numPoints);
			//this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
			this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
		}
		fromY += diffX/len; //FIXME?
		fromX += diffY/len;
	}
};
*/

/* ab.length == a*b.
bc.length == b*c.
returns ac where ac.length==a*c.
This would be hundreds of times faster using GPU.js.
This is MIT licensed code from https://github.com/benrayfield/jsutils/blob/master/src/arvox/arvox.html
but any way to write it would look very similar.
*/
const matmulCpu = (ab, bc, aSize, bSize, cSize)=>{
	//let ret = nf32(aSize*cSize);
	let ret = nf64(aSize*cSize);
	for(let a=0; a<aSize; a++){
		for(let c=0; c<cSize; c++){
			//TODO this will be most of the GPU code in matmulGpu:
			let sum = 0; //double*double then cast to float differs from [float*float which is intheory what you get in GPU.js. TODO align with lazycl]
			for(let b=0; b<bSize; b++){
				sum += ab[a*bSize+b]*bc[b*cSize+c];
			}
			ret[a*cSize+c] = sum;
		}
	}
	return ret;
};

var mulAll = nums=>{
	let i = nums[0];
	for(let j=1; j<nums.length; j++) i *= nums[j];
	return i;
};

//sizes is array dimension sizes such as [20,50] is a 2d matrix
//or [2,2,2,2,2,2,2,2] could be a bayesnode of 256 weights and 8 bayesvars.
//arrOrFillWithOrUndefined is function() to create numbers to fill Float32Array with,
//or is a Float32Array to use those numbers, or is undefined to create a Float32Array of (TODO verify) all 0s.
var Tensor = function(sizes, arrOrFillWithOrUndefined){
	this.sizes = sizes;
	if(arrOrFillWithOrUndefined){
		if(typeof(arrOrFillWithOrUndefined) == 'function'){
			this.arr = nf32(mulAll(sizes));
			for(let i=0; i<this.arr.length; i++) this.arr[i] = arrOrFillWithOrUndefined();
		}else{ //its type should be Float32Array. Use those numbers as they are.
			this.arr = arrOrFillWithOrUndefined;
		}
	}else{
		this.arr = nf32(mulAll(sizes)); //all 0s, FIXME verify its 0s instead of random or NaNs etc
	}
};

Tensor.prototype.matmul = function(t){
	//if(this.sizes[1] != t.sizes[0]) throw 'Sizes dont match for matmul: '+this.sizes[1]+' '+t.sizes[0];
	//if((this.sizes.length != 2) || (t.sizes.length != 2)) throw 'Not a matrix. A matrix is a 2d tensor';
	return new Tensor(
		[this.sizes[0],t.sizes[1]],
		matmulCpu(this.arr, t.arr, this.sizes[0], this.sizes[1], t.sizes[1])
	);
};

/*Tensor.prototype.verifySameSize = function(t){
	if(this.sizes.length != t.sizes.length) throw 'Diff num of dimensions';
	for(let d=0; d<t.sizes; d++) if(this.sizes[d] != t.sizes[d]) throw 'Diff size at dim='+d;
};*/

var copyList = list=>{
	let ret = [];
	ret.push(...list);
	return ret;
};

/*
//vararg
Tensor.prototype.get = function(){
	
};*/

/*Tensor.prototype.fill = function(numberMaker){
	for(let i=0; i<this.arr.length; i++) this.arr[i] = numberMaker();
};

Tensor.newRandBell = function(sizes, ave, dev){
	Tensor t = n
	this.fill(()=>(ave+dev*randBell()));
};*/

/*
//Tensor.weightedSum(tensorA, weightA, tensorB, weightB...)->Tensor. All must be same aTensor.sizes.
//Tensor.weightedSum(tensorA, 1) gives a copy of tensorA.
Tensor.weightedSum = function(){
	if(arguments.length < 2) throw 'Empty';
	 let ret = new Tensor(arguments[0].sizes.slice()); //copy this.sizes, and start with all 0s (TODO verify its not NaNs or random etc)
	 for(let i=0; i<arguments.length; i+=2){
		let tensor = arguments[i];
		let weight = arguments[i+1];
		ret.verifySameSize(tensor);
		for(let j=0; j<ret.arr.length; j++){
			ret.arr[j] += weight*tensor.arr[j];
		}
	 }
	 return ret;
};
*/

/*
//weights is list of 2d Tensors.
//Example: [60,100,43,5] has weights sizes 60*100, 100*43, and 43*5. 60 inputs. 5 outputs.
const FeedforwardTanhNeuralnet = function(weights){
	this.weights;
};*/


//inputTensor is for example a 1x60 tensor, and tensors[0] is for example a 60*100 tensor, and so on.
//A good neuralFunc is Math.tanh.
//tanh(x) = 2*sigmoid(2*x)-1 so those are just different views of the same kind of neuralnet.
//Tanh(x) equals approx x when x is near 0.
//Its recommended that the first node in each input and layer always be 1, to use as neural bias,
//which can be done by input always starts with a 1 and weights are high to the first node per layer.
var evalNeuralnet = (inputTensor, tensors, neuralFunc)=>{
	let neuralActivations = inputTensor;
	for(let i=0; i<tensors.length; i++){
		neuralActivations = neuralActivations.matmul(tensors[i]);
		for(let j=0; j<neuralActivations.arr.length; j++){
			neuralActivations.arr[j] = neuralFunc(neuralActivations.arr[j]);
		}
	}
	return neuralActivations;
};

//a sigmoid neuralnet, and a tanh neuralnet, can simulate eachother except for roundoff by a simple change of weights.
//Tanh seems the more natural function for physics since tanh(x) is near x when x is near 0,
//but sigmoid seems the more natural function when most neurons are 0 and some sparse few are on at once.
//Sigmoid is more natural for many combos of "x implies y" (and NOT_x doesnt imply anything).
//tanh(springLength-springRestLength)^2 + tanh(d(springLength)/dt)^2 = constant
//describes a spring or wave or pendulum when springLength-springRestLength is small.
const sigmoid = x=>(.5+.5*Math.tanh(.5*x));

//inverse tanh
//const atanh = x=>((Math.log(1+x)-Math.log(1-x))/2);

/** modifies tensor */
var makeLastNodeBeNeuralBias = tensor=>{
	//if(tensor.sizes.length != 2) throw 'Not a matrix';
	//FIXME is this the outer dim or inner dim?
	let aSize = tensor.sizes[0], bSize = tensor.sizes[1];
	let a = aSize-1;
	for(let b=0; b<bSize; b++){
		//https://www.wolframalpha.com/input/?i=tanh%28100%29 says tanh(100) is 0.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999972322069465265249387026370860418306291939...
		//big weight from last node in lower layer. 0 weight from all others in lower layer.
		tensor.arr[a*bSize+b] = ((b == bSize-1) ? 100 : 0);
		//FIXME are a and b reversed here?
	}
};


//returns a number on a bell curve of ave 0 stdDev 1.
//This is a fact of math which maps a circle of radius 1 to a 2d bellcurve average (0,0) stdDev 1.
//Like https://docs.oracle.com/javase/8/docs/api/java/util/Random.html#nextGaussian--
//"This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described
//by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms,
//section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at
//the cost of only one call to StrictMath.log and one call to StrictMath.sqrt."
//WARNING: openjdk has a very similar code and is GPL licensed, but any way to code this would look similar.
//
/*
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
100.88210186209895
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
137.9640381135098
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
30.27454763857819
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
72.49182700531551
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
75.01277347653968
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-143.14069239331027
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-34.33842686222431
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-106.61513694229491
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-60.95928728816138
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-8.390904458327132
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-4.325450511748599
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
27.13476782171233
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
16.18806856466041
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
226.97221409050343
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
118.86441773563894
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-155.12626128801787
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
-61.60088234862334
sum = 0; for(let i=0; i<10000; i++) sum += randBell(); sum;
28.953165698430386
randBell()
0.7530077542069135
randBell()
-0.9650011968100795
randBell()
-0.6851267164133018
randBell()
-0.2522358418857675
randBell()
-0.5247195864442755
randBell()
-0.32881969540141703
randBell()
-0.06715800916962683
randBell()
1.217755287897146
let bells = []; for(let i=0; i<10000; i++) bells.push(randBell());
10000
let ave = for(let i=0; i<10000; i++) ave += bells[i]/10000
Uncaught SyntaxError: expected expression, got keyword 'for'
debugger eval code:1:10
let ave = 0; for(let i=0; i<10000; i++) ave += bells[i]/10000
-0.003393677027600015
ave
-0.003393677027600015
let sumsq = 0; for(let i=0; i<10000; i++) sumsq += Math.pow(bells[i]-ave,2);
9823.69133352122
Math.sqrt(sumsq)
99.11453643901696
Math.sqrt(sumsq/10000)
0.9911453643901695
*/
const randBell = ()=>{
	haveNextRandBell = !haveNextRandBell;
	if(!haveNextRandBell){
		return nextRandBell;
	}else{ //make 2 more
		let x = 0, y = 0, radiusSquared = 0;
		do{
			x = 2*pseudorandomFraction()-1;
			y = 2*pseudorandomFraction()-1; //randomly sample from a 2x2 square
			radiusSquared = x*x + y*y;
		}while(radiusSquared >= 1 || radiusSquared == 0); //randomly sample from a radius 1 circle except its exact center or perimeter
		let mul = Math.sqrt(-2*Math.log(radiusSquared)/radiusSquared);
		nextRandBell = x*mul; //for next randBell()
		return y*mul;
	}
};

//const sqrt2Pi = Math.sqrt(2*pi);

//ave (0,0) stdDev 1 2d bellcurve height, where tallest part is height 1.
const unitBell2d = (y,x)=>Math.exp(-.5*(y*y+x*x));

//returns height (except roundoff) when x==ave.
const bell = (ave,dev,height,x)=>(height*Math.exp(-.5*sqr((x-ave)/dev)));

//const Ave = (x,y)=>((x+y)/2);

const randInt = max=>Math.floor(pseudorandomFraction()*max);

//2022-1 this has got mixed up, above and below, but in general some of the code was copied or variant
//of it retyped from various ben rayfield's opensource code.
//opensource MIT licensed above, things more specific to reefs (and some just general math tangled with that) below
// /script
// script

var neuralFunc = Math.tanh;

//var cellularAutomataRadius = 10;
var cellularAutomataRadius = 5;
//var cellularAutomataRadius = 20;
//var cellularAutomataRadius = 30;
var cellularAutomataInputPoints = 1+2*cellularAutomataRadius;
var cellularAutomataInputColors = 3;
//the +1 is for neural bias, value should always be near 1 there
var cellularAutomataInputs = cellularAutomataInputPoints*cellularAutomataInputColors+1;
var cellularAutomataOutputs = cellularAutomataInputColors;

//modifies
var normNeuralLayer = layer=>{
	makeLastNodeBeNeuralBias(layer);
	//TODO "L2 norm" or something like that. tanh gets normed a little different than sigmoid.
};

//modifies
var normNeuralWeights = neuralWeights=>{
	for(let i=0; i<neuralWeights.length; i++) normNeuralLayer(neuralWeights[i]);
};

//put the reds, greens, and blues of each point on Curve, plus minus cellularAutomataRadius points, into this cellmataIn,
//then evalNeuralnet(cellmataIn,neuralWeights)->[red,green,blue].
//For example, 63 numbers from 21 points colors generate the next color of the center point.
//TODO for varying size of dt (change in time),
//decay the color at a rate proportional to dt instead of instantly overwriting it.
//var cellmataIn = new Tensor([1,cellularAutomataInputs]);

//get next red, green, and blue here.
//var cellmataOut = new Tensor([1,cellularAutomataOutputs]);

//TODO optimize by using a batch size of number of points on the Curve, instead of 1 at a time.


//var neuralLayerSizes = [cellularAutomataInputs, cellularAutomataInputs*10, cellularAutomataInputs, cellularAutomataOutputs];
var neuralLayerSizes = [cellularAutomataInputs, Math.ceil(cellularAutomataInputs*1.5), cellularAutomataOutputs];
//var neuralLayerSizes = [cellularAutomataInputs, Math.ceil(cellularAutomataInputs*2.2), Math.ceil(cellularAutomataInputs*.5), cellularAutomataOutputs];
//var neuralLayerSizes = [cellularAutomataInputs, Math.ceil(cellularAutomataInputs/3)+1, Math.ceil(cellularAutomataInputs/5)+1, cellularAutomataOutputs+1];



var canv = null;

const twoPi = 2*Math.PI;

const timeOffset_ = eval('performance.timing.navigationStart'); //evaled to prevent uglifyjs from changing it to something like performance.V.Q but still have to put timing and navigationStart in reserved list

//utc seconds, with a little more precision than Date.now()*.001
const Now = ()=>((timeOffset_+performance.now())*.001);

const between = (min, val, max)=>mx(min, mn(val, max));

//its in theory faster to have this always be true/false and nextRandBell always be a double,
//than to store it as a double that can be null.
var haveNextRandBell = false;
var nextRandBell = 0;

/*var timeSpeed = ()=>{
	let d = dom('timeSpeed');
	if(!d) return 1; //before document.body loads
	let sliderFraction = d.valueAsNumber/1000000;
	return sliderFraction*4-2; //-2 to 2
};*/

const dom = id=>document.getElementById(id);

//y10 x10 pairOfFloats. This is a 1024x1024 pic with just green/horizontalAccel and blue/verticalAccel.
//The middle 512x512 touches the top bottom left and right edges of the innermost/border circle (that reef tends to stay inside).
//This generates a background pic there, before reef is drawn, but while editing it, the graphics will look wrong.
//This wont change after an NFT is loaded, but can differ in different NFTs.
var accelField = nf32(1<<21);
//for(let i=0; i<accelField.length; i++) accelField[i] = randBell(); //FIXME remove this and get it from o/options containing voxels with y10 x10 stdDev9 r8 g8 b8

//in coordinates where (0,0) is center and border/smallest circle is radius 1.
//accelField is 1024x1024, and the middle 512x512 of it is the square around that circle.
//TODO bilinear interpolation?
var accelFieldAt = (y,x)=>{
	let yIndex = between(0,512+y*256,1023.99);
	let xIndex = between(0,512+x*256,1023.99); //with fraction part. TODO bilinear interpolation?
	let lowY = fl(yIndex);
	let lowX = fl(xIndex);
	let i = (lowY<<11)|(lowX<<1);
	return {y: accelField[i], x: accelField[i+1]};
};

//putHill(normY, normX, radius, repelForce, accelY, accelX);
//var paintAccelVoxel = v=>putHill(BR.voxelYp(v),BR.voxelXp(v),BR.voxelR(v),BR.voxelRepelForce(v),BR.voxelAccelY(v),BR.voxelAccelX(v));

//array of 6*numHills numbers, repeating: normY, normX, radius, repelForce, accelY, accelX. That array is oo.accelVoxels
var putHills = a=>{
	for(let i=0; i<accelField.length; i++) accelField[i] = 0;
	for(let i=0; i<a.length; i+=6){
		putHill(a[i],a[i+1],a[i+2],a[i+3],a[i+4],a[i+5]);
	}
};

//a 2d bellcurve that attracts or repels from its center andOr accels in a direction.
//This is in coordinates of the border/smallest circle is centered at (0,0) and has radius 1. so put hill between -2 and 2 of x and y
//since the 1024x1024x2 accel pic (FIXME) should align there.
var putHill = (centerY,centerX,radius,repelForce,accelY,accelX)=>{
	const mask = (1<<21)-1;
	let radiusPixels = 256*radius; //FIXME what should max radius be?
	let siz = ce(radiusPixels*4); //let siz = ce(radius*4); //1 stddev is radius, so *4 is from -2 stddevs to 2 stddevs
	let centerYPixel = betweenInt(0, 512+256*centerY, 1023);
	let centerXPixel = betweenInt(0, 512+256*centerX, 1023);
	for(let y=centerYPixel-siz; y<centerYPixel+siz; y++){
		for(let x=centerXPixel-siz; x<centerXPixel+siz; x++){
			let accelIndexY = ((y<<11)|(x<<1))&mask; //wrap horizontally and down by 1 line, just to not break it. you should try not to put bellcurves near the edge cuz it wraps strange.
			let accelIndexX = accelIndexY+1;
			let pixDy = y-centerYPixel, pixDx = x-centerXPixel; //in units of pixels, unlike the params are in units of 1 is the border/smallest circle so -2 to 2.
			let dy = pixDy/256; //in units of border/smallest circle
			let dx = pixDx/256; //in units of border/smallest circle
			//let observedRadiusSquared = dy*dy+dx*dx; //in units of border/smallest circle
			//let observedRadius = Math.hypot(dy,dx);
			
			let scaledDy = dy/radius;
			let scaledDx = dx/radius;
			
			let bellHeight = unitBell2d(scaledDy,scaledDx);
			let slopeY = (unitBell2d(scaledDy+epsilon,scaledDx)-bellHeight)/epsilon;
			let slopeX = (unitBell2d(scaledDy,scaledDx+epsilon)-bellHeight)/epsilon;
			
			//let bellHeight = bell(0,radius,1,observedRadius); //ave dev height x
			//let accelYXForAttractRepel = bellHeight*repelForce; //FIXME this should be slope of the 2d bellcurve, not its height
			
			//let accelYForAttract = -dy; //FIXME this is not bellcurve math
			//let accelXForAttract = -dx; //FIXME
			
			let accelYForAttract = -repelForce*slopeY;
			let accelXForAttract = -repelForce*slopeX;
			
			//accelField[accelIndexY] = 5;
			//accelField[accelIndexX] = 5;
			//FIXME todo
			let scale = 2.5;
			accelField[accelIndexY] = Math.tanh(accelField[accelIndexY]/scale + bellHeight*accelY + accelYForAttract)*scale;
			accelField[accelIndexX] = Math.tanh(accelField[accelIndexX]/scale + bellHeight*accelX + accelXForAttract)*scale;
		}
	}
};

/*moving this into builder, since 2022-5-9 GeneReefer said to not display hills in the NFTs, even if they affect the reef movements,
and which the sliders can do, but that means we have this space for metadata and to allow more combos of bootshape+otherOptions,
since some bootShapes are bigger than others.

//copies accelField onto part of byteRect. accelField must be size 1<<21, but byteRect can be any size, and window may resize causing byteRect (from canvas) resizing.
//Params include rectangle in accelField and rectangle in byteRect
var paintAccelField = (brightAddRed, brightAddGreen, brightAddBlue, brightMult, accelField, aYFrom, aYTo, aXFrom, aXTo, byteRect, bYFrom, bYTo, bXFrom, bXTo)=>{
	let arr = byteRect.b;
	let aHeight = aYTo-aYFrom;
	let aWidth = aXTo-aXFrom;
	let bHeight = bYTo-bYFrom;
	let bWidth = bXTo-bXFrom;
	for(let bY = bYFrom; bY<bYTo; bY++){
		let byteIndex = (bY*byteRect.w+bXFrom)*4;
		let bYFraction = (bY-bYFrom)/bHeight;
		let accelIndexY = aYFrom+fl(aHeight*bYFraction);
		for(let bX = bXFrom; bX<bXTo; bX++){
			let bXFraction = (bX-bXFrom)/bWidth;
			let accelIndexX = aXFrom+fl(aWidth*bXFraction);
			let accelIndex = (accelIndexY<<11) | (accelIndexX<<1); //1024x1024x2
			let accelY = accelField[accelIndex];
			let accelX = accelField[accelIndex+1];
			//arr[byteIndex+RED] = asByte(Math.random()*256); //FIXME should be 0
			arr[byteIndex+RED] = asByte(brightAddRed);
			arr[byteIndex+GREEN] = asByte(brightAddGreen+brightMult*accelX);
			arr[byteIndex+BLUE] = asByte(brightAddBlue+brightMult*accelY);
			arr[byteIndex+ALPHA] = 255; //visible
			byteIndex += 4;
		}
	}
};
*/

/*
//such as 'friction' for o.friction. Might not need to do anything for some options, as they're read in a loop.
var onChangeOption = key=>{
	console.log('onChangeOption '+key+' '+options[key]);
};
*/

//UPDATE: use distance not distanceSquared. Renaming it to forceFunc. OLD...
//a distanceSquaredToForce(perimeterDistance,distance*distance) defines the attract/repel amount between pairs of points.
//distanceSquaredToForce is only used within maxDistanceToAffectEachother.
//perimeterDistance is along the 1d curved loop (TODO in what units?). distance is 2d distance.
//curveFunc(distance)->force.
//sqrt(dt)*addRandomness is 2d stdDev to add to each point's velocity.
//TODO include other things like normed distance along the perimeter of the curve?
//TODO colorFunc, or merge multiple funcs into one?
//let Curve = function(dt, time, forceFunc, maxDistanceToAffectEachother, addRandomness, maxSpeed, friction, numPoints, neuralWeights, neuralFunc, optionalPrevCurve){
//
//WARNING: numPoints is replaced in balanceSparsityBoot (called in this constructor) unless param keepNumpoints
let Curve = function(optionalPrevCurve, dt, potentialEnergyFunc, maxDistanceToAffectEachother, addRandomness, maxSpeed, friction, numPoints, neuralWeights, neuralFunc, keepNumpoints){
	//if(isGetRecordedBootShape) numPoints = o.bootShapeYp.length; //FIXME its confusing for params to have numPoints thats ignored when isGetRecordedBootShape. caller should set numPoints to oo.bootShapeYp.length?
	if(!numPoints){
		throw 'no points';
	}
	let p = optionalPrevCurve;
	/*if(isJustCopyPrevCurve){
		throw 'removed code';
		/*this.dt = p.dt;
		this.numPoints = p.numPoints;
		this.yp = nf64(p.yp);
		this.xp = nf64(p.xp);
		this.yv = nf64(p.yv);
		this.xv = nf64(p.xv);
		this.red = nf32(p.red);
		this.green = nf32(p.green);
		this.blue = nf32(p.blue);
		this.undoableVoxels = copyList(p.undoableVoxels);
		*
	}else{
	*/
	
		let accelFieldMul = o.accelFieldMul;

		this.dt = dt;

		let displayCirc = circleToDisplayIn;
		let displayCenterY = displayCirc.centerY;
		let displayCenterX = displayCirc.centerX;
		let displayCenterRadius = displayCirc.radius;
		let circleBorderBounceRadius = displayCenterRadius*o.borderRadiusMul;
		
		//TODO optimize: store these in a Float64Array, but would need to resize it. For now use list [] which is probably slower.
		this.undoableVoxels = [];

		this.numPoints = numPoints;
			
		/*TODO cellularAutomata function as param of Curve, that chooses red, green, blue, and isBranch numbers, for
		some of the reefs have such tiny branches it might be more efficient to do the outer curve as usual but the 2d surface it paints as a cellular automata
		At first I was planning to make the curve so long that it goes around the edges of every tiny branch,
		which would be a distance of maybe 50000 pixels long. Instead, 1000 pixels long around just the tips
		of the branches.
		cellular automata would be, given red green and blue at each poing along maybe 20 pixels
		of the curve (centered at each point on the curve), choose next red, green, and blue at that
		one point for the next curve dt time ahead. This task could be done in parallel by another person
		andOr me, separate from the task of making interesting curves.
		If the curve is concave vs convex (how much it curves) would affect if it splits a branch or not
		The automata design task could be tested on circles of different radius, on both sides toward
		the center and outside the circle, from the perimeter, and on sine waves and other curvy things
		you can make in https://wolframalpha.com/ so will know how it looks before hook it into reef curves.
		Im unsure if wolframalpha can do the automata but it can at least help finding a variety
		of curvy equations fast, that can be moved to javascript.
		Some of the people involved in the wolfram physics project (which is a kind of infinite dimensional
		cellular automata) might be able to come up with ultra realistic plant sims.
		https://www.wolframphysics.org/visual-summary/dark/#&gid=1&pid=1
		*/

		//FIXME it should either pull between the midpoints of lines
		//or use mass proportional to the 2 adjacent lines of each point.

		let maxDistanceSquaredToAffectEachother = Math.pow(o.maxDistanceToAffectEachother,2);
		//dt = mx(-.2,mn(dt,.2)); //FIXME do this in caller so dont lose track of time
		dt = mx(-.9,mn(dt,.9)); //FIXME do this in caller so dont lose track of time
		//this.time = time;
		//dt *= timeSpeed();
		//dt *= o.timeSpeed;
		
		//console.log('Curve dt='+dt);
		
		//x and y positions and velocities. TODO or just positions?
		this.yp = nf64(numPoints);
		this.xp = nf64(numPoints);
		this.yv = nf64(numPoints);
		this.xv = nf64(numPoints);
		
		this.red = nf32(numPoints);
		this.green = nf32(numPoints);
		this.blue = nf32(numPoints);

		/*
		//a 1d cellular automata, from a Curve to the next Curve dt time ahead,
		//that starts a branch where theres no near branches, or continues a branch already here,
		//or continues not being a branch here, or ends a branch here.
		this.isBranch = nf32(numPoints);
		*/
		
		//TODO color
		if(p){ //continue existing curve
			let cellmataIn = new Tensor([1,cellularAutomataInputs]);
			
			//compute forces from either optionalPrevCurve as it is or linear interpolation along it,
			//so it can grow more like https://github.com/inconvergent/differential-line
			let viewP = p;
			//use the I (instead of J) shape for counting perimeter distance, for both curves.
			//J is balanceSparsity of I which slightly modifies perimeter, so count before that happens.
			let perim = p.perimeter(); //before balanceSparsity slightly changes it. Use this to find perimeterDistance.
			/*if(o.linearInterpolateSparsity){
				//TODO optimize?: also check for !o.balanceSparsity since p might already be linear interpolated?
				viewP = viewP.copy();
				viewP.balanceSparsity(); //use forces from viewP, then throw viewP away, leaving the new Curve sparse.
			}*/
			
			let cacheDys = nf32(numPoints);
			let cacheDxs = nf32(numPoints);
			for(let i=0; i<numPoints; i++){
				let j = (i+1)%numPoints;
				let diffY = this.yp[j]-this.yp[i];
				let diffX = this.xp[j]-this.xp[i];
				let distance = Math.hypot(diffY,diffX);
				//default is down direction (+y) in the rare case that 2 points are exact same position. Must be vector length 1.
				cacheDys[i] = (distance == 0) ? 1 : diffY/distance;
				cacheDxs[i] = (distance == 0) ? 0 : diffX/distance;
			}
			
			//let dt = this.time-p.time; //allowed to be negative since can undo or go forward
			let howFarOnICurveIsI = 0;
			
			/*
			for(let i=0; i<numPoints; i++){
			if(o.setSpeedsToZeroAfterEveryDtMove){
				for(let i=0; i<this.numPoints; i++){
					this.xv[i] = this.yv[i] = 0;
				}
			}
			this.yp[i] = p.yp[i]+p.yv[i]*dt;
			this.xp[i] = p.xp[i]+p.xv[i]*dt;
			*/
			for(let i=0; i<numPoints; i++){
				//this.yp[i] = p.yp[i]+p.yv[i]*dt;
				//this.xp[i] = p.xp[i]+p.xv[i]*dt;
				this.yp[i] = p.yp[i]; //add velocity*dt farther below so setSpeedsToZeroAfterEveryDtMove works
				this.xp[i] = p.xp[i];
				if(i>0){
					howFarOnICurveIsI += Math.hypot(p.yp[i]-p.yp[i-1], p.xp[i]-p.xp[i-1]); //add distance of line segment i-1 to i
				}
				//if(isNaN(this.yp[i]) || isNaN(p.yp[i]) || isNaN(p.yv[i])){ //FIXME optimize by removing isNaN check. checking for is very slow in general.
				//	throw 'NaN';
				//}
				
				//copy near points colors (from p, the prev Curve dt behind) into neuralnet
				for(let j=0; j<cellularAutomataInputPoints; j++){
					//i (each point) plus/minus cellularAutomataRadius wrapped around numPoints.
					let w = (j+i-cellularAutomataRadius+numPoints)%numPoints;
					cellmataIn.arr[j*3+RED] = p.red[w]/127.5-1; //range -1 to 1
					cellmataIn.arr[j*3+GREEN] = p.green[w]/127.5-1;
					cellmataIn.arr[j*3+BLUE] = p.blue[w]/127.5-1;
				}
				//constant used instead of neural bias.
				//last in each nodelayer (Tensor is between 2 nodelayers) should be approx 1.
				//That should be caused by setting neural weights very high so that node's tanh(weightedSum) is near 1.
				cellmataIn[cellmataIn.length-1] = 1; //cuz makeLastNodeBeNeuralBias
				let cellmataOut = evalNeuralnet(cellmataIn,neuralWeights,neuralFunc);
				
				let nextRed = asByte(127.5+127.5*cellmataOut.arr[RED]); //convert from range -1..1 to range 0 to 255
				let nextGreen = asByte(127.5+127.5*cellmataOut.arr[GREEN]);
				let nextBlue = asByte(127.5+127.5*cellmataOut.arr[BLUE]);
				//cellmataOut.arr[BLUE+1 aka 3] should always be near 1, a constant used as neural bias
				
				//let colorDecayPerSec = 3;
				//if(o.autoMoveTimeSpeedSlider){
				//	//cuz it looks mostly gray otherwise, not having enough time accumulated
				//	//to change color cuz goes back and forth in time.
				//	colorDecayPerSec *= 10;
				//}
				let colorDecay = mx(0,mn(o.colorDecayPerSec*dt,1));
				//colorDecay = 1; //instant //fixme
				
				
				
				//FIXME, instead of just copying color here, copy then change it by dt
				//amount of 1d cellular automata of about 10 points outward in both directions.
				/*this.red[i] = p.red[i];
				this.green[i] = p.green[i];
				this.blue[i] = p.blue[i];
				*/
				this.red[i] = p.red[i]*(1-colorDecay) + colorDecay*nextRed;
				this.green[i] = p.green[i]*(1-colorDecay) + colorDecay*nextGreen;
				this.blue[i] = p.blue[i]*(1-colorDecay) + colorDecay*nextBlue;
				
				
				//add to point's velocity. dt is already multiplied into this sum
				//for accel being derivative of velocity, and velocity is derivative of position. FIXME divide by 2?
				let dy = 0;
				let dx = 0;
				
				//var potentialEnergyFunc = (ay, ax, by, bx,borderCenterY,borderCenterX,borderRadius,perimeterDistance)=>{
				
				let accelMul = dt*o.scalePotentialEnergyForce;
				
				let acc = accelFieldAt(this.yp[i],this.xp[i]); //in coordinates where (0,0) is center and border/smallest circle is radius 1.
				
				dy += o.accelFieldMul*accelMul*acc.y; //can returna n object here without slowing it down cuz its in 1 loop instead of double loop.
				dx += o.accelFieldMul*accelMul*acc.x;
				
				//dy += 4444444444444;
				
				//for(let j=0; j<numPoints; j++){
				for(let j=0; j<viewP.numPoints; j++){
					//TODO or just have the force be 0? FIXME what if 2 points ever
					//get to be the exact same position? Randomness would fix it probably.
					
					
					//if(i != j){ //FIXME i and j dont always have same numPoints
						
						let diffY = this.yp[i]-p.yp[j]; //2d vector from p to this
						let diffX = this.xp[i]-p.xp[j];
						//let manhattanDistance = Math.abs(diffY)+Math.abs(diffX);
						let distanceSquared = diffY*diffY + diffX*diffX;
						if(distanceSquared != 0 && distanceSquared <= maxDistanceSquaredToAffectEachother){
							
							//FIXME perimeterDistance was designed for i and j to be the same Curve but when viewP is balanceSparsity of the other, numPoints differs between them
							//let perimeterDistance = mn(Math.abs(i-j),Math.abs(i-j+numPoints)); //FIXME what units?
							//
							let howFarOnICurveIsJ = j/viewP.numPoints*perim; //j/viewP has its points spread evenly around the I curve
							//range 0 to perim/2 (except roundoff). on a scale of its displayed in a circle of radius 1.
							let perimeterDistance = mn(
								Math.abs(howFarOnICurveIsJ-howFarOnICurveIsI), //shorter without crossing point index 0
								Math.abs(howFarOnICurveIsJ+perim-howFarOnICurveIsI) //shorter to cross point index 0
							);
							
							
							
							//var potentialEnergyFunc = (ay, ax, by, bx, ady, adx, bdy, bdx, borderCenterY,borderCenterX,borderRadius,perimeterDistance)=>{
							//cacheDys[i] = (distance == 0) ? 1 : diffY/distance;
							//cacheDyx[i] = (distance == 0) ? 0 : diffX/distance;
							let ady = cacheDys[i];
							let adx = cacheDxs[i];
							let bdy = cacheDys[j];
							let bdx = cacheDxs[j];
							let distance = Math.sqrt(distanceSquared);
							//taper off how much points affect eachother instead of sharp change at maxDistanceToAffectEachother.
							//1 at distance 0, 0 at distance maxDistanceToAffectEachother, and gradually between.
							let distanceFraction = 1-distance/maxDistanceToAffectEachother;
							let potEnHere = potentialEnergyFunc(
								this.yp[i],
								this.xp[i],
								viewP.yp[j], //p.yp[j],
								viewP.xp[j], //p.xp[j],
								ady, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								adx, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								bdy, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								bdx, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								displayCenterY,
								displayCenterX,
								circleBorderBounceRadius,
								perimeterDistance
							)*distanceFraction;
							
							let potEnEpsilonMovedInY = potentialEnergyFunc(
								this.yp[i]-epsilon/2,
								this.xp[i],
								viewP.yp[j]+epsilon/2, //p.yp[j]+epsilon/2,
								viewP.xp[j], //p.xp[j],
								ady, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								adx, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								bdy, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								bdx, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								displayCenterY,
								displayCenterX,
								circleBorderBounceRadius,
								perimeterDistance
							)*distanceFraction;
							
							let potEnEpsilonMovedInX = potentialEnergyFunc(
								this.yp[i],
								this.xp[i]-epsilon/2,
								viewP.yp[j], //p.yp[j],
								viewP.xp[j]+epsilon/2, //p.xp[j]+epsilon/2,
								ady, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								adx, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								bdy, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								bdx, //FIXME are ady adx bdy bdx from the correct one of this, p, or viewP?
								displayCenterY,
								displayCenterX,
								circleBorderBounceRadius,
								perimeterDistance
							)*distanceFraction;
							
							let yAccel = (potEnEpsilonMovedInY-potEnHere)/epsilon;
							let xAccel = (potEnEpsilonMovedInX-potEnHere)/epsilon;
							
							dy += yAccel*accelMul;
							dx += xAccel*accelMul;
							//if(isNaN(dy)){
							//	throw 'NaN dy';
							//}
						}
						
						/*let diffY = this.yp[i]-p.yp[j]; //2d vector from p to this
						let diffX = this.xp[i]-p.xp[j];
						let distanceSquared = diffY*diffY + diffX*diffX;
						if(distanceSquared != 0 && distanceSquared <= maxDistanceSquaredToAffectEachother){
							//TODO optimize using square buckets to find whats near eachother
							
							//let isAdjacentPoint = (Math.abs(i-j)==1);
							//let force = distanceSquaredToForce(isAdjacentPoint,distanceSquared);
							
							let perimeterDistance = mn(Math.abs(i-j),Math.abs(i-j+numPoints)); //FIXME what units?
							let distance = Math.sqrt(distanceSquared);
							let distanceFromDisplayCenter = Math.hypot(displayCenterY-this.yp[i], displayCenterX-this.xp[i]);
							let force = forceFunc(distanceFromDisplayCenter,perimeterDistance,distance);
							
							//TODO optimize by only computing dy and dx once (instead of twice) per pair
							let normY = diffY/distance; //Math.hypot(normY,normX) is 1 except roundoff
							let normX = diffX/distance;
							
							let accelY = dt*normY*force;
							let accelX = dt*normX*force;
							
							dy += accelY;
							dx += accelY;
						}*/
					//}
				}
				
				/*
				for(let j=0; j<numPoints; j++){
					//TODO or just have the force be 0? FIXME what if 2 points ever
					//get to be the exact same position? Randomness would fix it probably.
					if(i != j){
						let diffY = this.yp[i]-p.yp[j]; //2d vector from p to this
						let diffX = this.xp[i]-p.xp[j];
						let distanceSquared = diffY*diffY + diffX*diffX;
						if(distanceSquared != 0 && distanceSquared <= maxDistanceSquaredToAffectEachother){
							//TODO optimize using square buckets to find whats near eachother
							
							//let isAdjacentPoint = (Math.abs(i-j)==1);
							//let force = distanceSquaredToForce(isAdjacentPoint,distanceSquared);
							
							let perimeterDistance = mn(Math.abs(i-j),Math.abs(i-j+numPoints)); //FIXME what units?
							let distance = Math.sqrt(distanceSquared);
							let distanceFromDisplayCenter = Math.hypot(displayCenterY-this.yp[i], displayCenterX-this.xp[i]);
							let force = forceFunc(distanceFromDisplayCenter,perimeterDistance,distance);
							
							//TODO optimize by only computing dy and dx once (instead of twice) per pair
							let normY = diffY/distance; //Math.hypot(normY,normX) is 1 except roundoff
							let normX = diffX/distance;
							
							let accelY = dt*normY*force;
							let accelX = dt*normX*force;
							
							dy += accelY;
							dx += accelY;
						}
					}
				}*/
				
				
				
				
				
				//START explanation of https://en.wikipedia.org/wiki/Central_limit_theorem
				//(actually the binomial variant of it) for sums of coin flips.
				//cuz average ((heads-tails)^2)/(heads+tails), is exactly 1,
				//if count all 2^(heads+tails) possible ways they could land each exactly once.
				//I (ben rayfield) verified that by brute force up to 30 coins years ago.
				//For example, theres 8 ways 3 coins can land,
				//and that gives the 1 3 3 1 row of https://en.wikipedia.org/wiki/Pascal%27s_triangle
				//[tails tails tails] happens once. [heads heads heads] happens once.
				//You get 1 heads and 2 tails, 3 times.
				//You get 1 tails and 2 heads, 3 times. Total 8 ways that 3 coins can land.
				//((-1 + -1 + -1)^2 + 3*(-1 + -1 + 1)^2 + 3*(-1 + 1 + 1)^2 + (1 + 1 + 1)^2)/(3 * 2^3) = 1.
				//And similar for 4 coins, 5 coins,
				//or I've brute force verified it up to 30 coins, but... any number of coins.
				//(randBell()*a)^2 + (randBell()*b)^2 approxEquals (randBell()*c)^2, where a^2 + b^2 = c^2,
				//and exactly, ((headsA-tailsA+headsB-tailsB)^2)/(headsA+tailsA+headsB+tailsB) = 1 on average,
				//but WARNING TODO verify I didnt write that down wrong
				//by writing testcases of the bellcurves and how it might be used,
				//depending on if its just depth 1 into that math, or recursively into that math,
				//the code might make use of (see uses of randBell etc).
				//Aka the 3 sides of any right-triangle have a bellcurve from center to stdDev 1 along them.
				//An n dimensional bellcurve has a (n-1) dimensional hypersphere surface
				//(such as a 2d surface of a 3d ball) of constant density at each radius,
				//and a tangent n-1 dimensional flat surface intersects a n-1 dimensional bellcurve,
				//and a n-1 dimensional bellcurve (by recursion, nothing different...)
				//has a n-2 dimensional hypersphere at each constant radius, and so on down to sphere surface,
				//circle surface, and the one below that is the set of -1 and 1 (the ends of a line).
				//To imagine n dimensions, start with a point in the center of a 2d screen or piece of paper,
				//and each dimension is an arrow outward from that in any 2d direction and length,
				//and each point that is at position 1 in dimensions a b c d y j is at the starting point
				//moved in the directions of the a b c d y j arrows. Or if point is at position .5 in j dimension,
				//then just half the length of j in same direction as j. += bellcurve*sqrt(dt).
				//This explanation of the central limit theorem by ben rayfield is released to the public domain
				//and is not specific to any software. Nobody owns nor can take credit for the facts of math.
				//END explanation of https://en.wikipedia.org/wiki/Central_limit_theorem
				//
				//This is why to multiply by sqrt(dt) instead of by dt.
				//If you change dt (such as running faster or slower depending on computer speed),
				//it gets same amount of randomness summed over time.
				//FIXME Might need to multiply or divide by sqrt(2) for it being 2d?
				//TODO test this.
				//let mulRand = addRandomness*Math.sqrt(dt); //sqrt of negative number https://en.wikipedia.org/wiki/Imaginary_time
				let mulRand = addRandomness*Math.sqrt(Math.abs(dt)); //dont do https://en.wikipedia.org/wiki/Imaginary_time
				if(addRandomness != 0){
					//for(let i=0; i<numPoints; i++){
						//let j = (i+1)%numPoints; //i and j are 2 adjacent points
						//if(o.isOnlyMoveRandomlyPerpendicularToSurface){
							let nextI = (i+1)%numPoints; //2 adjacent points, but not linear interpolated cuz thats only done in the double loop
							//let diffY = this.yp[j]-this.yp[i];
							//let diffX = this.xp[j]-this.xp[i];
							let diffY = this.yp[nextI]-this.yp[i];
							let diffX = this.xp[nextI]-this.xp[i];
							let len = Math.hypot(diffY,diffX);
							if(len != 0){
								let normDyParallel = diffY/len;
								let normDxParallel = diffX/len;
								//a length 1 vector from i to j
								let normDyPerpendicular = normDxParallel;
								let normDxPerpendicular = -normDyParallel; //FIXME mirror this?
								let rnd = mulRand*randBell();
								
								dy += normDyPerpendicular*rnd;
								dx += normDxPerpendicular*rnd;
								
								/*
								//this.yv[i] += normDyParallel*rnd;
								//this.xv[i] += normDxParallel*rnd;
								this.yv[i] += normDyPerpendicular*rnd;
								this.xv[i] += normDxPerpendicular*rnd;
								//if(isNaN(this.yv[i])){
								//	throw 'NaN yv in addRandomness';
								//}
								*/
								
							}
						//}else{
						//	//this.yv[i] += mulRand*randBell();
						//	//this.xv[i] += mulRand*randBell();
						//	dy += mulRand*randBell();
						//	dx += mulRand*randBell();
						//}
					//}
				}
				
				
				
				
				
				
				this.yv[i] = p.yv[i]+dy; //FIXME should change velocity
				this.xv[i] = p.xv[i]+dx; //FIXME should change velocity
				//if(isNaN(this.yv[i]) || isNaN(p.yv[i]) || isNaN(dy)){
				//	throw 'isNaN asfafdsg';
				//}
				
				
				let speed = Math.hypot(this.yv[i], this.xv[i]);
				/*let speedSquared = this.yv[i]*this.yv[i] + this.xv[i]*this.xv[i];
				if(speedSquared > maxSpeed*maxSpeed){
					let speed = Math.sqrt(speedSquared);
					let speedMul = maxSpeed/speed; //change to maxSpeed
					this.yv[i] *= speedMul;
					this.xv[i] *= speedMul;
				}*/
				
				if(speed != 0){
					let nextSpeed = mx(0,mn(speed-friction*dt,o.maxSpeed));
					let speedMul = nextSpeed/speed; //change to maxSpeed
					this.yv[i] *= speedMul;
					this.xv[i] *= speedMul;
				}
				
				this.yp[i] += this.yv[i]*dt;
				this.xp[i] += this.xv[i]*dt;
				
				if(o.setSpeedsToZeroAfterEveryDtMove){
					this.xv[i] = this.yv[i] = 0;
				}
				
				//if(isNaN(this.yv[i])){
				//	throw 'NaN yv after speedMul';
				//}
			}
			/*for(let i=0; i<this.numPoints; i++){
				
				
				////FIXME: moving this down here made Reef_1640103440.8470001 more jagged.
				//this.yp[i] += p.yv[i]*dt;
				//this.xp[i] += p.xv[i]*dt;
				
				this.yp[i] += this.yv[i]*dt;
				this.xp[i] += this.xv[i]*dt;
			}
			if(o.setSpeedsToZeroAfterEveryDtMove){
				for(let i=0; i<this.numPoints; i++){
					this.xv[i] = this.yv[i] = 0;
				}
			}*/
		}else{ //start new curve
			//let centerY = 200, centerX = 200;
			let centerY = 0, centerX = 0; //cuz coordinates are circle of radius 1 (may go slightly outside but slides back in)
			let randStddev = dt*addRandomness;
			//let velocityFromCircleCenter = 10; //FIXME smaller cuz coordinates are circle of radius 1
			let velocityFromCircleCenter = 0;
			let bootShape = eval(o.bootShapeYX || o.bootShape); //bootShapeYX is in an old version, before bootShapeYX and bootShape were merged. Use only bootShape, going forward.
			//let bootShapeYX = o.bootShapeYX ? eval(o.bootShapeYX) : null;
			//FIXME? copy oo.bootShapeY to o.bootShapeYp? or just use them in oo (and same for oo.bootShape)?
			//let bY = o.bootShapeYp, bX = o.bootShapeXp;
			//if(bY && numPoints != bY.length) throw 'bY'+bY.length+' != numPoints'+numPoints; //bX.length==bY.length, but dont want to spend code size checking it
			for(let i=0; i<numPoints; i++){
				let angle = i/numPoints*twoPi;
				
				
				//let radius = 50+10*sin(angle*7)+8*sin(angle*11);
				
				let cosi = cos(angle);
				let sine = sin(angle);
				
				
				//TODO? could save a little space by removing bootShape and always using bootShapeY and bootShapeX
				
				
				//let radius = 90+10*sin(angle*7);
				//let radius = 50+4*sin(angle*7)+5*sin(angle*5)+3*sin(angle*11);
				
				//let radius = .3+.07*sin(angle*7)+.1*sin(angle*5)+.08*sin(angle*11);
				let sh = bootShape(angle); //returns [y,x] or radius
				if(typeof(sh)=='number'){
					//let radius = o.bootShapeScale*sh;
					//this.yp[i] = centerY+o.bootShapeY+radius*cosi;
					//this.xp[i] = centerX+o.bootShapeX+radius*sine;
					this.yp[i] = sh*cosi;
					this.xp[i] = sh*sine;
					//this.yp[i] = isGetRecordedBootShape ? bY[i] : centerY+o.bootShapeY+radius*cosi;
					//this.xp[i] = isGetRecordedBootShape ? bX[i] : centerX+o.bootShapeX+radius*sine;
				}else{
					this.yp[i] = sh[0];
					this.xp[i] = sh[1];
				}
				this.yp[i] = centerY+o.bootShapeY+o.bootShapeScale*this.yp[i];
				this.xp[i] = centerX+o.bootShapeX+o.bootShapeScale*this.xp[i];
				this.yv[i] = velocityFromCircleCenter*cosi;
				this.xv[i] = velocityFromCircleCenter*sine;
				this.red[i] = this.green[i] = this.blue[i] = randInt(256);
				
				/*let radius = 80;
				this.yp[i] = centerY+radius*Math.cos(angle);
				this.xp[i] = centerX+radius*sin(angle);
				this.yv[i] = 0;
				this.xv[i] = 0;
				this.red[i] = this.green[i] = this.blue[i] = randInt(256);
				*/
				
				/*
				let radius = 70+20*sin(angle*7)+15*sin(angle*11);
				this.yp[i] = centerY+radius*Math.cos(angle);
				this.xp[i] = centerX+radius*sin(angle);
				this.yv[i] = 0;
				this.xv[i] = 0;
				this.red[i] = 127.5+127.5*sin(angle*7);
				this.green[i] = 127.5+127.5*sin(angle*11)
				this.blue[i] = 127.5+127.5*sin(angle*23)
				*/
				
				//this.yv[i] = startRandomSpeed*randBell();
				//this.xv[i] = startRandomSpeed*randBell();
				//this.yv[i] = startRandomSpeed*(2*Math.random()-1); //FIXME should be randGaussian
				//this.xv[i] = startRandomSpeed*(2*Math.random()-1); //FIXME should be randGaussian
			}
			if(!keepNumpoints) this.balanceSparsityBoot(); //change numPoints based on perimeter distance
			numPoints = this.numPoints;
		}

		//for(let i=0; i<this.numPoints; i++){ //TODO remove this
		//	if(isNaN(this.yv[i])){
		//		throw 'NaN yv before addRandomness';
		//	}
		//}

		//for(let i=0; i<this.numPoints; i++){ //TODO remove this
		//	if(isNaN(this.yv[i])){
		//		throw 'NaN yv at end';
		//	}
		//}
	//}
};

/*Curve.prototype.copy = function(){
	return idn(true, this);
};*/

//instead of randomly any 2d direction.
//var isOnlyMoveRandomlyPerpendicularToSurface = true;

const betweenInt = (lo, val, hi)=>ro(mx(lo,mn(val,hi)));

//let lineWidth = 1;

var asByte = val=>ro(mx(0,mn(val,255)));


/*
//like '#aab87f'
Curve.prototype.colorStrAtPointIndex = function(i){
	let r = betweenInt(0,this.red[i],255);
	let g = betweenInt(0,this.green[i],255);
	let b = betweenInt(0,this.blue[i],255);
	let s = '000000'+(r*65536+g*256+b).toString(16);
	return '#'+s.substring(s.length-6);
};
*/

/*Curve.prototype.rememberVoxel = function(voxel){
	this.undoableVoxels.push(voxel);
};*/




/*
Curve.prototype.boundingCircle = function(){
	let sumX = 0, sumY = 0;
	for(let i=0; i<this.numPoints; i++){
		sumY += this.yp[i];
		sumX += this.xp[i];
	}
	let centerY = sumY/this.numPoints;
	let centerX = sumX/this.numPoints;
	let maxRadiusSquared = 0;
	for(let i=0; i<this.numPoints; i++){
		let dy = this.yp[i]-centerY;
		let dx = this.xp[i]-centerX;
		maxRadiusSquared = mx(maxRadiusSquared, dy*dy+dx*dx);
	}
	return {centerX: centerX, centerY: centerY, radius: Math.sqrt(maxRadiusSquared)};
};

//{centerX: ?, centerY: ?, radius: ?}. Modifies this Curve's yp xp yv xv.
Curve.prototype.moveIntoBoundingCircle = function(toCirc){
	let fromCirc = this.boundingCircle();
	let addToY = toCirc.centerY-fromCirc.centerY; //dont change velocity for this
	let addToX = toCirc.centerX-fromCirc.centerX;
	let radiusMult = toCirc.radius/fromCirc.radius; //but do multiply velocities by radius fraction change
	//FIXME can radiusMult be Infinity, NaN, etc?
	for(let i=0; i<this.numPoints; i++){
		//this.yp[i] += addToY;
		//this.xp[i] += addToX;
		let normY = (this.yp[i]-fromCirc.centerY)/fromCirc.radius;
		let normX = (this.xp[i]-fromCirc.centerX)/fromCirc.radius;
		//normY*normY+normX*normX<=1 except roundoff.
		this.yp[i] = toCirc.centerY+normY*toCirc.radius;
		this.xp[i] = toCirc.centerX+normX*toCirc.radius;
		//TODO optimize using a radiusMult var
		
		//this.yp[i] = addToY+(this.yp[i]-fromCirc.centerY)*radiusMult;
		//this.xp[i] = addToX+(this.xp[i]-fromCirc.centerX)*radiusMult;
		
		//FIXME TODO
		//this.yv[i] *= radiusMult;
		//this.xv[i] *= radiusMult;
	}
};
*/





/* balanceSparsity uses linear interpolation to spread points along the same Curve. modifies Curve.
But FIXME maybe should use bezier curve interpolation instead of linear interpolation? might be hard to compute perimeter/length.


FIXME is this code a derivative work or translation or what kind of variant of my (bens) smartblob0.3 code
which balances sparsity in the webcam code that uses a loop of orange wire as a game controller
to bend a similar shape on screen? Its just specialized here in a specific tensor size,
one dimension being in=[yp xp] and out=[yp xp yv xv red green blue]
and the other side being which point (numPoints).
Its just a chain of same-length poles (line-segments) along any curve of near the same total length.
This seems like it should be grouped with the opensource MIT code its a variant of.
But also, some would see it as, anything that could appear in a math book,
is math and is only a derivative work of simpler math recursively.
Like the similarity of the randBell function to existing softwares out there,
efficient ways to code the facts of math
tend to be similar to eachother or a few possible clusters of similarity.
I (ben) wouldnt want anyone telling others they cant slide a 1d curved loop over manifolds in general,
(which manifold?: sum of potentialEnergyFunc(...) for pairs of points on the curve, and most of
the artistic work is in the choice of different many-(thousands to low millions)-dimensional manifolds
(in this case, approx numColors*(numPointsPerCurve^2)/2
(except those too far apart, so fewer) dimensions of potential energy manifold)
coded or evolved inside potentialEnergyFunc), and neuralnets are as basic a part of math
as AND OR NOT NAND XOR 3SAT etc which are all things you can do exactly using a neuralnet
and it is obvious, though very slow in theory to run,
how to code RSA or common hash algorithms using a neuralnet on their bits
and similarly is obvious how to literally play a neuralnet as a stringed musical instrument in realtime
due to the fact that tanh(x) nearly equals x when x is near 0 and tanh(x)^2+gradient(tanh(x))^2
is like the way a spring vibrates in a circle of (length-restLength)^2 + gradient(length-restLength)^2 = constant
is a circle a spring vibrates around.


or maybe putting sparse points in the middle of longer line segments is better cuz distorts position less?
instead of...

//Instead of creating and removing points, spread the points. Returns previous perimeterDistance (slightly changes).
//I (ben rayfield) did that or something like that in
//the normPositions andOr spreadByLinearInterpolateAndRotateAlongPerimeter functions in
//https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html
//as seen in this video https://www.youtube.com/watch?v=rZFbIdeLBWQ
//"SmartblobWebcam 0.3.0 experimental, works in Firefox with Java server".
//The difference here is this curve has no thickness and does not bounce on things, so its easier here.
//Its simply to view a loop of line segments by path length and spread the points evenly,
//and maybe some norming since that tends to shrink it a little.
Curve.prototype.balanceSparsity = function(){
	TODO
};*/
Curve.prototype.balanceSparsity = function(){
	/*let prevYp = this.yp;
	let prevXp = this.xp;
	let prevYv = this.yv;
	let prevXv = this.xv;
	let prevRed = this.red;
	let prevGreen = this.green;
	let prevBlue = this.blue;
	*/
	let prevs = [this.yp, this.xp, this.yv, this.xv, this.red, this.green, this.blue];
	let prevNumPoints = this.numPoints;
	
	/*let sumDistances = nf32(prevNumPoints+1);
	sumDistances[0] = 0;
	for(let i=0; i<prevNumPoints; i++){
		let j = (i+1)%prevNumPoints;
		let lineSegmentLength = Math.hypot(prevYp[j]-prevYp[i], prevXp[j]-prevXp[i]);
		sumDistances[i+1] = sumDistances[i]+lineSegmentLength;
	}
	*/
	let sumDistances = this.perimeterDistances();
	let perimeter = sumDistances[prevNumPoints];
	
	//if((perimeter <= 0) || isNaN(perimeter)){
	//	throw 'perimeter='+perimeter;
	//}
	let prevPerimeterDistanceEach = perimeter/prevNumPoints;
	
	let nextNumPoints = between(
		mx(o.minPointsPerCurve,prevNumPoints-o.maxNumPointsPerCurveChangeAtOnce),
		//mx(minPointsPerCurve,prevNumPoints-maxNumPointsPerCurveChangeAtOnce), //FIXME
		Math.ceil(perimeter/o.targetDistanceBetweenAdjacentCurvePoints), //
		mn(prevNumPoints+o.maxNumPointsPerCurveChangeAtOnce, o.maxPointsPerCurve)
	);
	//let nextNumPoints = prevNumPoints+(Math.random()<.03 ? 1 : 0); //FIXME
	
	let nextPerimeterDistanceEach = perimeter/nextNumPoints;
	//if(nextNumPoints != prevNumPoints) console.log('Changing numPoints from '+prevNumPoints+' to '+nextNumPoints);
	this.yp = nf64(nextNumPoints);
	this.xp = nf64(nextNumPoints);
	this.yv = nf64(nextNumPoints);
	this.xv = nf64(nextNumPoints);
	this.red = nf32(nextNumPoints);
	this.green = nf32(nextNumPoints);
	this.blue = nf32(nextNumPoints);
	let nexts = [this.yp, this.xp, this.yv, this.xv, this.red, this.green, this.blue];
	this.numPoints = nextNumPoints;

	
	//leave point [0] where it is (just copy it by its targetPerimeter==0). Move the others.
	//FIXME use random starting value of perimeter (and wrap) so point [0] not moving doesnt
	//create a sharp point on the curve.
	let whichLineSegment = 0;
	//let randomPerimeterAlignment = pseudorandomFraction()*perimeter;
	for(let i=0; i<nextNumPoints; i++){
		
		/*
		//move point [i] this far from point [0] along prev perimeter,
		//which is cumulative distance along a series of line segments in prevYp and prevXp.
		let targetPerimeter = i*nextPerimeterDistanceEach;
		*
		let targetPerimeterNonwrapped = (randomPerimeterAlignment+i*nextPerimeterDistanceEach)%perimeter;
		let targetPerimeter = targetPerimeterNonwrapped%perimeter;
		
		
		while(sumDistances[(whichLineSegment+1)%prevNumPoints] < targetPerimeterNonwrapped){
			whichLineSegment = (whichLineSegment+1)%prevNumPoints;
		}
		*/
		
		//move point [i] this far from point [0] along prev perimeter,
		//which is cumulative distance along a series of line segments in prevYp and prevXp.
		let targetPerimeter = i*nextPerimeterDistanceEach;
		while(sumDistances[whichLineSegment+1] < targetPerimeter) whichLineSegment++;
		
		let nextLineSegment = (whichLineSegment+1)%prevNumPoints; //wrap around to point [0].
		let lineSegmentLength = sumDistances[whichLineSegment+1]-sumDistances[whichLineSegment];
		let fraction = (targetPerimeter-sumDistances[whichLineSegment])/lineSegmentLength;
		
		/*
		//fraction is 0 to put point [i] at prev point [whichLineSegment],
		//and fraction is 1 to put it at prev point [nextLineSegment], and gradually between.
		//Set these as weightedSum of 2 points along prev lineSegment:
		this.yp[i] = prevYp[whichLineSegment]*(1-fraction) + fraction*prevYp[nextLineSegment];
		this.xp[i] = prevXp[whichLineSegment]*(1-fraction) + fraction*prevXp[nextLineSegment];
		this.yv[i] = prevYv[whichLineSegment]*(1-fraction) + fraction*prevYv[nextLineSegment];
		this.xv[i] = prevXv[whichLineSegment]*(1-fraction) + fraction*prevXv[nextLineSegment];
		this.red[i] = prevRed[whichLineSegment]*(1-fraction) + fraction*prevRed[nextLineSegment];
		this.green[i] = prevGreen[whichLineSegment]*(1-fraction) + fraction*prevGreen[nextLineSegment];
		this.blue[i] = prevBlue[whichLineSegment]*(1-fraction) + fraction*prevBlue[nextLineSegment];
		*/
		for(let a=0; a<prevs.length; a++){
			nexts[a][i] = prevs[a][whichLineSegment]*(1-fraction) + fraction*prevs[a][nextLineSegment];
		}
	}
	if(builder) displayText(this);
	return perimeter; //reefs[0].curves[reefs[0].curves.length-1].balanceSparsity()/numPoints was approx 2.2 for example
};

/* removed cuz linearInterpolateSparsity is being removed 2022-1-17
//funcYXYXYX gets 3 points positions and chooses to keep a point (true) vs remove (false) the point in the middle or not,
//but if it does it wont remove the next point even if funcYXYXYX would say to.
Curve.prototype.removePoints = function(funcYXYXYX){
	let n = this.numPoints;
	let keep = [];
	let newNumPoints = 0;
	for(let i=0; i<n; i++){
		let h = (i-1+n)%n;
		let j = (i+1)%n;
		//i>0 cuz keep[h] hasnt been filled when i==0, and thats needed to be able to remove the first point.
		keep[i] = (i>0 && !keep[h]) || funcYXYXYX(this.yp[h], this.xp[h], this.yp[i], this.xp[i], this.yp[j], this.xp[j]);
		if(keep[i]) newNumPoints++;
	}
	let i = 0;
	let c = this.copy();
	c.numPoints = newNumPoints;
	c.yp = nf64(newNumPoints);
	c.xp = nf64(newNumPoints);
	c.yv = nf64(newNumPoints);
	c.xv = nf64(newNumPoints);
	c.red = nf32(newNumPoints);
	c.green = nf32(newNumPoints);
	c.blue = nf32(newNumPoints);
	for(let k=0; k<newNumPoints; k++){
		while(!keep[i]) i++;
		//copy point
		c.yp[k] = this.yp[i];
		c.xp[k] = this.xp[i];
		c.yv[k] = this.yv[i];
		c.xv[k] = this.xv[i];
		c.red[k] = this.red[i];
		c.green[k] = this.green[i];
		c.blue[k] = this.blue[i];
		i++;
	}
	return c;
};
*/


/*var containsNaN = arr=>{
	for(let i=0; i<arr.length; i++) if(isNaN(arr[i])) return true;
	return false;
};*/

var sqr = x=>(x*x);

/* removed cuz linearInterpolateSparsity is being removed 2022-1-17
//returns a new Curve, often with a different numPoints.
Curve.prototype.insertPointsIfDistanceAtLeast = function(minDistance){
	let n = this.numPoints;
	let minDistSq = minDistance*minDistance;
	let newNumPoints = n;
	for(let i=0; i<n; i++){
		let j = (i+1)%n;
		let dy = this.yp[j]-this.yp[i], dx = this.xp[j]-this.xp[i];
		if(dy*dy+dx*dx >= minDistSq) newNumPoints++;
	}
	let c = this.copy();
	c.numPoints = newNumPoints;
	c.yp = nf64(newNumPoints);
	c.xp = nf64(newNumPoints);
	c.yv = nf64(newNumPoints);
	c.xv = nf64(newNumPoints);
	c.red = nf32(newNumPoints);
	c.green = nf32(newNumPoints);
	c.blue = nf32(newNumPoints);
	let k = 0; //0 to newNumPoints-1
	for(let i=0; i<n; i++){
		let j = (i+1)%n;
		let dy = this.yp[j]-this.yp[i], dx = this.xp[j]-this.xp[i];
		
		//copy point i
		c.yp[k] = this.yp[i];
		c.xp[k] = this.xp[i];
		c.yv[k] = this.yv[i];
		c.xv[k] = this.xv[i];
		c.red[k] = this.red[i];
		c.green[k] = this.green[i];
		c.blue[k] = this.blue[i];
		if(isNaN(c.yp[k]) || isNaN(c.xp[k]) || isNaN(c.yv[k]) || isNaN(c.xv[k]) || isNaN(c.red[k]) || isNaN(c.green[k]) || isNaN(c.blue[k])){
			//TODO remove this slow check for NaN
			throw 'NaN';
		}
		k++;
		
		if(dy*dy+dx*dx >= minDistSq){ //insert point at midpoint of points i and j
			c.yp[k] = (this.yp[i]+this.yp[j])/2;
			c.xp[k] = (this.xp[i]+this.xp[j])/2;
			c.yv[k] = (this.yv[i]+this.yv[j])/2;
			c.xv[k] = (this.xv[i]+this.xv[j])/2;
			c.red[k] = ro((this.red[i]+this.red[j])/2);
			c.green[k] = ro((this.green[i]+this.green[j])/2);
			c.blue[k] = ro((this.blue[i]+this.blue[j])/2);
			k++;
		}
	}
	//if(containsNaN(c.yp)) throw 'yp has NaN';
	//if(containsNaN(c.xp)) throw 'xp has NaN';
	//if(containsNaN(c.yv)) throw 'yv has NaN';
	//if(containsNaN(c.xv)) throw 'xv has NaN';
	//if(k != newNumPoints) throw 'k='+k+' newNumPoints='+newNumPoints+' prevNumPoints='+n; //FIXME could happen cuz of roundoff?
	return c;
};*/

//ignores o.maxNumPointsPerCurveChangeAtOnce
Curve.prototype.balanceSparsityBoot = function(){
	//console.log('A numPoints='+this.numPoints+' perimeter='+this.perimeter());
	let prev = o.maxNumPointsPerCurveChangeAtOnce;
	o.maxNumPointsPerCurveChangeAtOnce = 1000000;
	this.balanceSparsity();
	o.maxNumPointsPerCurveChangeAtOnce = prev;
	//console.log('B numPoints='+this.numPoints+' perimeter='+this.perimeter());
};

Curve.prototype.perimeter = function(){
	let d = this.perimeterDistances();
	return d[d.length-1];
};

//returns this.numPoints+1 cumulative distances around the perimeter.
Curve.prototype.perimeterDistances = function(){
	let n = this.numPoints;
	let sumDistances = nf64(n+1);
	sumDistances[0] = 0;
	for(let i=0; i<n; i++){
		let j = (i+1)%n;
		let lineSegmentLength = Math.hypot(this.yp[j]-this.yp[i], this.xp[j]-this.xp[i]);
		sumDistances[i+1] = sumDistances[i]+lineSegmentLength;
	}
	return sumDistances;
};

/*
//range 0 to about 1.03 but could go much higher if reef is farther outside the border circle depending on physics.
//The border circle is not a hard limit. Reef rolls down a hill smoothly to keep it mostly in border circle.
Curve.prototype.maxDistanceFromCenter = function(){
	let maxSq = 0;
	for(let i=0; i<this.numPoints; i++){
		let dx = this.xp[i], dy = this.yp[i];
		maxSq = mx(maxSq, dx*dx+dy*dy);
	}
	return Math.sqrt(maxSq);
};
*/

//use code like this in browser console...
//let c = newestCurve(); let maxDist = 0; for(let i=0; i<c.numPoints; i++) maxDist = mx(maxDist,Math.hypot(c.xp[i]-c.xp[(i+1)%c.numPoints],c.yp[i]-c.yp[(i+1)%c.numPoints])); maxDist;
//
//renamed to targetDistanceBetweenAdjacentCurvePoints cuz coordinates are circle of radius 1 instead of pixels
//var targetDistanceBetweenAdjacentCurvePointsInPixels = 2.34;
//var targetDistanceBetweenAdjacentCurvePointsInPixels = 10;
//var targetDistanceBetweenAdjacentCurvePointsInPixels = 5;
//var targetDistanceBetweenAdjacentCurvePointsInPixels = .005; //coordinates are in circle of radius 1 (may go slightly outside)

//var maxNumPointsPerCurveChangeAtOnce = 1; //FIXME do this as a percent, cuz maxPointsPerCurve may be hard to reach if this is 1

//var minPointsPerCurve = 10;
//var maxPointsPerCurve = 400;
//var maxPointsPerCurve = 1000;
//var maxPointsPerCurve = 3000;
//var maxPointsPerCurve = 5000; //FIXME less cuz could get slow

Curve.prototype.holdInRect = function(minX, maxX, minY, maxY){
	for(let i=0; i<this.numPoints; i++){
		this.yp[i] = between(minY, this.yp[i], maxY);
		this.xp[i] = between(minX, this.xp[i], maxX);
	}
};

var copyByJson = map=>JSON.parse(JSON.stringify(map));

/** like a record or circular cam, that varies a slider (anything in o/options) per time.
Theres 3 kinds: smooth (slider), integer (slider), and bit (checkbox).
TODO min and max value? Or just range -1 to 1? Or 0 to 1?
TODO scaled by the current slider position.
There can be 1 of these for each slider, but shouldnt display too many at once cuz it will look confusing and cuz it might slow things down to display 40 of them.
*/
var Loop = function(name, angles, red, green, blue){
	this.clicks = []; //[[y,x],[y2,x2],[y3,x3]]. its emptied the next time its painted. clicks edit the loop shape. its easier to do it while painting cuz it already knows the positions on screen.
	this.name = name;
	this.radius = new Float32Array(angles);
	let rand = .7+.6*pseudorandomFraction();
	for(let i=0; i<angles; i++){
		let angle = 2*Math.PI*i/angles;
		this.radius[i] = 1+.3*(Math.sin(angle*5*rand)+Math.sin(7*angle*rand+.3)); //FIXME this is just a test. Let caller set radiuses.
	}
	this.red = red;
	this.green = green;
	this.blue = blue;
	
	//TODO Loop is displayed using a Curve, but changes to the Curve arent copied back to the Loop.
	//TODO Each display cycle, all Curves are unpainted (using Curve.undoableVoxels), those Curves are modified using new Loop.radius[], then painted again.
	this.curve = null;
	
	this.domLabel = null;
	
	//this.becomeRandomSumOfSineWaves();
	//this.becomeRandom();
	//this.becomeStraightHill();
};

//var isPowOf2 = i=>((i&(i-1))==0);

//returns a double/float64 if its a smooth or integer slider (or if its smooth but just happens to be an integer, it cant tell the difference). Returns true or false if its a checkbox.
Loop.prototype.sliderOrCheckboxValueNow = function(){
	let r = oo[this.name]*this.radiusAtAngle(loopAngle);
	if(optionIsBit[this.name]) return 0<r;
	if(optionIsInteger[this.name]) return Math.round(r) || 1; //cant be 0 cuz that breaks things
	return r || epsilon; //cant be 0 cuz that breaks things
};

Loop.prototype.radiusAtAngle = function(angle){
	let i = angle/twoPi*this.radius.length;
	i %= this.radius.length;
	if(i < 0) i += this.radius.length;
	let lowIndex = Math.floor(i);
	let highIndex = (lowIndex+1)%this.radius.length;
	let fractionHigh = i-lowIndex; //weightedAverage between 2 adjacent indexes (wrapped)
	return this.radius[Math.floor(lowIndex)]*(1-fractionHigh) + fractionHigh*this.radius[highIndex]; //linear interpolate
};

/*
//displays it rotated by loopAngle and with the radiuses of this.radius.
//loopAngle is changed based on o.loopSeconds slider over time and can move forward or backward and any speed.
Loop.prototype.changeRadiusArray = function(){
	let siz = this.radius.length;
	let now = Now();
	for(let i=0; i<siz; i++){
		let angle = 2*Math.PI*i/siz+loopAngle;
		//let ang = angle*11+now*.7
		//this.radius[i] = 1+.1*(Math.sin(ang)+Math.sin(ang*3)); //FIXME
		//this.radius[i] = 1+.1*Math.sin(ang); //FIXME
		//this.radius[i] = 1+.1*Math.sin(angle*11); //FIXME
		this.radius[i] = Math.sin(angle*11); //FIXME
		//this.radius[i] = 1+now%1;
	}
};*/

//TODO save space by moving this to the builder code.
Loop.prototype.copyRadiusArrayToCurve = function(){
	let siz = this.radius.length;
	if(!this.curve) this.curve = newCurve(siz);
	for(let i=0; i<siz; i++){
		let angle = 2*Math.PI*i/siz-loopAngle;
		//let radius = this.radius[i]; //TODO rename Loop.radius to Loop.multiplySliderBy.
		let radius = loopRadiusOfZeroOption+loopRadiusMul*this.radius[i]; //TODO rename Loop.radius to Loop.multiplySliderBy.
		//TODO? let radius = loop.radiusForDisplay();
		//radius += o.timeSpeed*.5;
		this.curve.xp[i] = Math.sin(angle)*radius;
		this.curve.yp[i] = Math.cos(angle)*radius;
		this.curve.red[i] = this.red;
		this.curve.green[i] = this.green;
		this.curve.blue[i] = this.blue;
	}
};

//TODO save space by moving this to the builder code.
//paint grooves, the curvy loops around the reef that turn.
var paintLoops = (centerY, centerX, scaleY, scaleX, isOnlyDisplaySelectedLoop)=>{
	//unpaint
	for(let option in loops){
		let loop = loops[option];
		if(loop.countPaints){
			loop.paintOrUnpaint(centerY, centerX, scaleY, scaleX);
		}
		loop.countPaints = (loop.countPaints || 0)+1;
	}
	//update and paint
	for(let option in loops){
		if(!isOnlyDisplaySelectedLoop || option==selectedOption){
			let loop = loops[option];
			//loop.changeRadiusArray();
			loop.copyRadiusArrayToCurve();
			loop.curve.undoableVoxels = []; //clear cache of voxels so will compute different pixels
			loop.paintOrUnpaint(centerY, centerX, scaleY, scaleX);
		}
	}
};

//FIXME Use as mutable vs immutable in what ways? Is neuralWeights used as immutable? potentialEnergyFunc is immutable?
//evoStats (evolution statistics) is {} and todo put stuff in it (if do much evolution, undecided if thats the best way).
//curves is list of Curve.
//potentialEnergyFunc, todo maybe should be a neuralnet or maybe code evolution or maybe manually designed few params differ?
//neuralWeights is a list of 2d Tensor,
//a feedforward tanh neuralnet that chooses color per point on the 1d curve
//based on near points colors on that curve and decays color by someNumber*dt amount there.
var Reef = function(curves,potentialEnergyFunc,neuralWeights,neuralFunc,addRandomness){
	//if(!evoStats || !curves || !potentialEnergyFunc || !neuralWeights || !neuralFunc) throw 'Something is missing';
	this.curves = curves;
	this.potentialEnergyFunc = potentialEnergyFunc;
	this.neuralWeights = neuralWeights;
	this.neuralFunc = neuralFunc;
	this.addRandomness = null;//addRandomness; //FIXME use o.addRandomness instead
};

//sum Curve.dt
Reef.prototype.timePosition = function(){
	let sum = 0;
	for(let i=0; i<this.curves.length; i++) sum += this.curves[i].dt;
	return sum;
};


/*
Reef.prototype.breedByAverageNeuralnet = function(reef){
	let retNeuralWeights = [];
	for(let i=0; i<reef.neuralWeights.length; i++){
		retNeuralWeights.push(Tensor.weightedSum(this.neuralWeights[i],.5, reef.neuralWeights[i],.5));
	}
	return this.withNeuralWeights(retNeuralWeights);
};
*/


//var targetDistanceOfAdjacentPoints = 2;

//For example, a spring's potentialEnergy is ((length-restLength)*someConstant)^2.
//perimeterDistance is in integer units of points, as in numPoints.
//distance is in units of 2d distance in pixels (or css scaled?)
//(TODO some other coordinate system? that doesnt depend on screen size andOr width/height ratio)

//border circle [REMOVED: and smaller circle]
var bigCirclePotentialEnergy = (circRadius,distanceFromCenter)=>{
	let ret = 0;
	let g = distanceFromCenter-circRadius;
	//let j = distanceFromCenter-circRadius*o.smallerCircleRadius;
	
	if(g > 0){
		//past the perimeter of circle, its shaped as parabola upward,
		//which causes things to smoothly bounce on or slide around it by least-squares, same as a spring.
		ret += g*g*o.stayInsideBorderCircleForce;
	}else{
		//is inside circle. curve down so things are attracted to center,
		//which a reef can grow outward from.
		
		let radiusFraction = distanceFromCenter/circRadius;
		//FIXME how smooth is this at perimeter?
		//let innerMul = o.circPotEnInnerMul;
		//ret += o.circPotEnOuterMul*(sigmoid(radiusFraction*innerMul)-sigmoid(innerMul));
		ret += 10*(sigmoid(radiusFraction*.001)-sigmoid(.001));
	}
	
	//this tends to either attract strongly to exactly the smaller circle or very weakly. its not useful.
	//ret += Math.pow(Math.abs(j),o.attractToSmallerCircleExponent)*o.attractToSmallerCircle;
	//FIXME remove attractToSmallerCircleExponent cuz replaced by bellcurve Math.exp(-stdDev*stdDev)
	
	//let jj = Math.abs(j);
	
	//let stdDev = j/o.smallerCircleThick;
	//ret += -Math.exp(-stdDev*stdDev)*o.attractToSmallerCircle;
	
	return ret;
};

/*var anglePotEn = (ay,ax,ady,adx,pushTowardRadialAngles,hypotAyAx,exponentOfFraction)=>{
	let normAy = hypotAyAx==0 ? 1 : ay/hypotAyAx;
	let normAx = hypotAyAx==0 ? 0 : ax/hypotAyAx;
	let dotProd = normAy*ady+normAx*adx; //range -1 to 1, cosine of angle on surface minus angle from center
	let fraction = Math.abs(dotProd); //its a line, not an arrow. 2 opposite directions get same number.
	//return pushTowardRadialAngles*fraction;
	return pushTowardRadialAngles*Math.pow(fraction,exponentOfFraction);
};*/

//at end of potentialEnergyFunc this can ignore potentialEnergyFunc or scale it or change it in any way
//based on that and distance in nearly a circle of radius 1 so normally distance can be at most about 2.05,
//or exactly 2 if strongly enough is repelled by the circle border.
//This replaces what potentialEnergyFunc was about to return, instead of is added to it,
//so make sure to add the en param to whatever you do with dist if you want to keep what potentialEnergyFunc does.
//var endist = (en,dist,pdist)=>en;
var endist = eval(o.endist);
if(!endist) throw 'endist='+endist;

//2 points x and y. and a constant perimeterDistance
//and (borderCenterY,borderCenterX,borderRadius) bounding circle to try to stay in.
//Use this with ay+epsilon/2 and by-epsilon/2, and ax+epsilon/2 and bx-epsilon/2,
//to get y and x derivatives (2d gradient).
//ady, adx, bdy, bdx, are length 1 vector of the 1d curve surface direction.
var potentialEnergyFunc = (ay, ax, by, bx, ady, adx, bdy, bdx, borderCenterY,borderCenterX,borderRadius,perimeterDistance)=>{
	//if(perimeterDistance < 10) return 0;
	let realDist = Math.hypot(by-ay,bx-ax);
	
	let en = 0;
	if(!o.onlyEndist){ //also use other sliders such as circPotEnOuterMul and repelSelfDistance
	
		let distance = realDist*o.distanceScale; //FIXME, trying to adjust this to the new coordinate system of circle of radius 1
		//let d = distance-o.repelSelfDistance;
		//let dEnergy = ((d<0) ? (d*d) : 0)*o.repelSelf; //use repelSelfExponent is always 2 instead of Math.pow
		//let dEnergy = ((d<0) ? Math.pow(-d,o.repelSelfExponent) : 0)*o.repelSelf; //Math.pow is slow
		let distanceOfAFromDisplayCenter = Math.hypot(ay-borderCenterY,ax-borderCenterX);
		let distanceOfBFromDisplayCenter = Math.hypot(by-borderCenterY,bx-borderCenterX);
		
		/*let ag = distanceOfAFromDisplayCenter-borderRadius;
		let bg = distanceOfBFromDisplayCenter-borderRadius;
		let agEnergy = ((ag>0) ? (ag*ag) : 0)*.1;
		let bgEnergy = ((bg>0) ? (bg*bg) : 0)*.1;
		*/
		let agEnergy = bigCirclePotentialEnergy(borderRadius,distanceOfAFromDisplayCenter);
		let bgEnergy = bigCirclePotentialEnergy(borderRadius,distanceOfAFromDisplayCenter);
		//let angleAPotEn = anglePotEn(ay,ax,ady,adx,o.pushTowardRadialAngles,distanceOfAFromDisplayCenter,o.pushTowardRadialAnglesFracExpon);
		//let angleBPotEn = anglePotEn(by,bx,bdy,bdx,o.pushTowardRadialAngles,distanceOfBFromDisplayCenter,o.pushTowardRadialAnglesFracExpon);
		
		//en = dEnergy+agEnergy+bgEnergy+angleAPotEn+angleBPotEn;
		//en = dEnergy+agEnergy+bgEnergy;
		en = agEnergy+bgEnergy;
	} //else en is 0
	
	//extra potential energy at distance, since its having a problem keeping a good distance from itself.
	//To make sure this cant be overpowered by other potentialEnergy, the existing potentialEnergy is computed first
	//and this is called at the end of that.
	//en += endist(en,distance); //FIXME use distance vs realDist?
	//if(!endist) throw 'no endist, its '+endist;
	en = endist(en,realDist,perimeterDistance); //FIXME use distance vs realDist?
	return en;

};

//cuz double has 52 bits of precision, and .000001 takes 20 of those, leaving 32 minus a few for roundoff.
//If you used Float32Array instead, which has 22 bits, a better epsilon might be .003.
var epsilon = .000001;

//cuz coordinats are circle of radius 1 and
//sometimes a little outside it see o.borderFraction minX maxX minY maxY.
//var scalePotentialEnergyForce = .0005;

//var scalePotentialEnergyForce = 3;
//var scalePotentialEnergyForce = 1;
//var scalePotentialEnergyForce = 12;
//var scalePotentialEnergyForce = 0; //FIXME

//If true, use only position but not velocity.
//moving this to o.setSpeedsToZeroAfterEveryDtMove
//var setSpeedsToZeroAfterEveryDtMove = false;
//var setSpeedsToZeroAfterEveryDtMove = true; //FIXME


/*
//FIXME use aReef.potentialEnergyFunc instead of the global var potentialEnergyFunc
var aForceFunc = (distanceFromDisplayCenter,perimeterDistance,distance)=>{
	
	let potentialEnergyGradient = (
		//FIXME need to compute potentialenergy differently if having 2 distances varying
		//but this seems to work some, hangs off the edge of display circle a little.
		potentialEnergyFunc(distanceFromDisplayCenter+epsilon,perimeterDistance,distance+epsilon)
		-potentialEnergyFunc(distanceFromDisplayCenter,perimeterDistance,distance)
	)/epsilon;

	
	////FIXME
	//let other = -11.3*(1/(.001+distance*distance)-.5);
	//other += 111.3*sin(distance*.2);
	//other += -711.3*sin(distance*.3);
	//other += -761.3*sin(distance*.5);
	
	let other = 0;

	return -scalePotentialEnergyForce*potentialEnergyGradient+other;
	//return 0; //FIXME
	
	//FIXME this just attracts or is it repels,
	//so can see it moving in a simpler shape to test neuralnet/cellularautomata
	//return -.5;
	//return 112.3*(Math.sqrt(perimeterDistance)/(.1+distance*distance));
	//return distance*distance*.01+20*distance;
};*/

/*var aDistanceSquaredToForceFunc = (isAdjacentPoint,distanceSquared)=>{
	let mul = 1;
	if(isAdjacentPoint){
		let distance = Math.sqrt(distanceSquared);
		return mul*1.8*(targetDistanceOfAdjacentPoints-distance); //FIXME is this backward?
	}else{
		//return 0; //FIXME
		return mul*.3*(1/(.001+distanceSquared)-.5 + 1.3*sin(Math.sqrt(distanceSquared)*.2)); //FIXME
		//return mul*.3*(1/(.001+distanceSquared)-.5); //FIXME
		//return .3*(1/(.001+distanceSquared)-.5); //FIXME
		//return .3*(1/(.001+distanceSquared)-.5); //FIXME
		//return .1*(1/(.1+distanceSquared)-.3); //FIXME
		//return 0;
	}
};*/

//var throwAfterPaintLineLongerThanThis = 40;

//var defaultMaxDistanceToAffectEachother = 50;
//var defaultMaxDistanceToAffectEachother = 70;
//var defaultMaxDistanceToAffectEachother = 100000; //FIXME use coordinates of circle of radius 1

//let defaultFriction = 6;
//let defaultFriction = .85;
//let defaultFriction = .3;
//var defaultFriction = .1;
//var defaultFriction = 0;
//var defaultFriction = 30;


//<nobr><input type=range id="dontCrossSelf" min="0" max="1000000" value="300000" oninput="dontCrossSelf = Math.exp(2*this.valueAsNumber/1000000); while(reefs[0].curves.length>1) reefs[0].curves.pop();"></input>dontCrossSelf</nobr><br>
//var dontCrossSelf = 30;
//var dontCrossSelf = 1.590876305583804;
//var dontCrossSelf = 4.5;


var circleToDisplayIn = {centerY: 0, centerX: 0, radius: 1};
/*
//hold all points in this rectangle:
//var minX = 200, maxX = 800, minY = 0, maxY = 600;
var circleToDisplayIn = ()=>{
	return {
		centerY: 0, //relative to coordinates -1 to 1 for x and y
		centerX: 0,
		//radius: 1-o.borderFraction
		radius: 1
	};
	/*return {
		centerY: (o.maxY+o.minY)/2,
		centerX: (o.maxX+o.minX)/2,
		radius: mn(o.maxY-o.minY, o.maxX-o.minX)*.3
	};*
};*/

//let maxSpeed = 3.5; //FIXME
//let maxSpeed = 10; //FIXME
//var maxSpeed = 100; //FIXME
//var maxSpeed = 30; //FIXME
//let maxSpeed = 111.1; //FIXME
//var maxSpeed = 30; //FIXME


//var newEvoStats = ()=>({});

//var mainWeightMaker = ()=>(-.03+.5*randBell());
//var mainWeightMaker = ()=>(-1111.3+1114.5*randBell()); //FIXME these weights are too big
var mainWeightMaker = ()=>(-.1+randBell());

/*
//type in browser console things like...
//dpOuterAdd = 0; dpOuterMul = .02; dpInnerMul = 1.2; while(reefs[0].curves.length > 1) reefs[0].curves.pop(); clearCanvOnce=false; reefs[0].neuralWeights = newManuallyDesignedNeuralWeightsForSimpleReefBranches();
//var dpOuterAdd = 0;
//var dpOuterMul = .05;
//var dpInnerMul = Math.PI;
var dpOuterAdd = .002;
var dpOuterMul = .03;
var dpInnerMul = Math.PI*1.97;
*/

/*
var newManuallyDesignedNeuralWeightsForSimpleReefBranches = ()=>{
	let ins = neuralLayerSizes[0];
	let outs = neuralLayerSizes[neuralLayerSizes.length-1];
	//dont use all the layers neuralLayerSizes says in the middle. trying something simpler.
	let layer = new Tensor([ins,outs]);
	for(let i=0; i<layer.arr.length-1; i++){
		let pointIndex = Math.floor(i/3);
		//range dp==-cellularAutomataRadius to dp==cellularAutomataRadius, as inputs that compute the point dp==0.
		//3 color dims each (possibly also other vars per point later).
		let dp = pointIndex-cellularAutomataRadius;
		//1 at this point. 0 at plus/minus cellularAutomataRadius. gradually between.
		let dpAsBifraction = dp/cellularAutomataRadius; //-1 to 1. 0 is this point.
		let dpAsFractionHill = 1-Math.abs(dp)/cellularAutomataRadius;
		
		layer.arr[i] = dpOuterAdd+dpOuterMul*Math.pow(Math.cos(dpAsBifraction*dpInnerMul),3);
		
		//layer.arr[i] = dpOuterAdd+dpOuterMul*Math.cos(dp*dpInnerMul)*dpAsFractionHill;
		//layer.arr[i] = dpOuterAdd+dpOuterMul*Math.cos(dpAsBifraction*dpInnerMul)*dpAsFractionHill;
		//layer.arr[i] = dpOuterAdd+dpOuterMul*Math.pow(Math.cos(dpAsBifraction*dpInnerMul),3);
		//layer.arr[i] = dpOuterAdd+dpOuterMul*Math.pow(Math.cos(dpAsBifraction*dpInnerMul),3);
		//layer.arr[i] = -11.1+dpOuterMul*Math.cos(dp*dpInnerMul)/(10+Math.abs(dp));
		//layer.arr[i] = -.1;
		//layer.arr[i] = .000001;
		//layer.arr[i] = 0;
		//layer.arr[i] = ((dp==-1) ? 100 : 0);
		//layer.arr[i] = ((i<3) ? 100 : 0);
	}
	//normNeuralLayer(layer); //last index computes value 1 by tanh(100)
	return [layer];
};*/

var newRandomNeuralWeights = ()=>{
	let tensors = [];
	for(let i=0; i<neuralLayerSizes.length-1; i++){
		tensors.push(new Tensor([neuralLayerSizes[i], neuralLayerSizes[i+1]], mainWeightMaker));
	}
	normNeuralWeights(tensors);
	return tensors;
};

//var newCurve = ()=>(new Curve(0, Now(), aForceFunc, defaultMaxDistanceToAffectEachother, 0, maxSpeed, o.friction, numPoints, newRandomNeuralWeights(), neuralFunc, undefined));
//var newCurve = ()=>(new Curve(0, Now(), potentialEnergyFunc, o.maxDistanceToAffectEachother, 0, o.maxSpeed, o.friction, numPoints, newRandomNeuralWeights(), neuralFunc, undefined));
//var newCurve = numPoint=>(new Curve(false, undefined, epsilon, potentialEnergyFunc, o.maxDistanceToAffectEachother, 0, o.maxSpeed, o.friction, numPoint, newRandomNeuralWeights(), neuralFunc, true));
var newCurve = numPoint=>(new Curve(undefined, epsilon, potentialEnergyFunc, o.maxDistanceToAffectEachother, 0, o.maxSpeed, o.friction, numPoint, newRandomNeuralWeights(), neuralFunc, true));

/*
//a sequence of Curves (each is a curvy loop of line segments that paints canvas).
//If this gets too big, remove from low index in this list. These are big.
//FIXME 1 of these goes in reefs[num].curves. this one should be removed. is it being used?
var curves = [newCurve(o.minPointsPerCurve)];
*/

//var defaultAddRandomness = 0; //FIXME
//var defaultAddRandomness = 101; //FIXME
//var defaultAddRandomness = 301; //FIXME
//var defaultAddRandomness = 31; //FIXME
//var defaultAddRandomness = 10; //FIXME
//var defaultAddRandomness = 131; //FIXME
//var defaultAddRandomness = 0; //FIXME

//const startFirstReefWithManuallyChosenWeights = false;

//not random if o.bootShapeYp exists. also, things are only pseudorandom now that theres seed.
var newRandomReef = ()=>{
	let weights = newRandomNeuralWeights(); //use repeatable pseudorandom first
	//return new Reef([newCurve(o.minPointsPerCurve,o.bootShapeYp?true:false)], potentialEnergyFunc, weights, neuralFunc, null);
	return new Reef([newCurve(o.minPointsPerCurve)], potentialEnergyFunc, weights, neuralFunc, null);
};

var clearCanvas = ()=>{
	clearCanvOnce = true;
	doPaintAccelFieldOnce = true;
	if(builder) clearLoops();
};

//var loopAngles = 60;
//var loopAngles = 200;
//var loopAngles = 20; //FIXME should be 200

var loops = {};

var adjustBordersOfThisOptions = ()=>{
	console.log('adjustBordersOfThisOptions');
	adjustBordersOfOptions(oo);
};

var restart = ()=>{
	if(builder){
		putInDefaults(oo);
		o = copyMap(oo);
	}
	if(!o.endist) throw 'no endist';
	setColorSeed(oo.colorSeed);
	loopAngle = 0;
	clearCanvas();
	reefs = [newRandomReef()]; //use repeatable pseudorandom first, before loops or anything else.
	
	
	
	//loops = {
	//	timeSpeed: new Loop('timeSpeed', loopAngles, 200, 0, 40),
	//	maxSpeed: new Loop('maxSpeed', loopAngles, 20, 200, 20),
	//	addRandomness: new Loop('addRandomness', loopAngles, 111, 111, 111),
	//};
	for(let option in oo.loops){ //copy from oo.loops (the lists of numbers, each a loop, for some of the options/oo) to loops map of option to Loop object.
		loops[option] = newLoop(option, oo.loops[option].length, true);
	}
	
	//reefs = [];
	//for(let i=0; i<10; i++) reefs.push(newRandomReef());
	//if(startFirstReefWithManuallyChosenWeights){
	//	reefs[0] = reefs[0].withNeuralWeights(newManuallyDesignedNeuralWeightsForSimpleReefBranches());
	//}
	
	//updateSliders();
	
	if(o.accelVoxels) putHills(o.accelVoxels);
	
	if(builder){
		selectedOption = loops.timePosition ? 'timePosition' : null; //auto select timePosition groove if its there
		dom('bootShapeEditor').value = o.bootShape;
		//setBootShapeAndRestart(o.bootShape)
	}
};

//do undo paint of the most recent this many Curves, except always leave at least 1 Curve.
//This then becomes 0 again, so its a way to schedule removing Curves.
var numberOfCurvesToUndoAsap = 0;

var reefs = []; //display reefs[0]. Others are there to evolve. Can switch places, breed, add, or remove them.

var mainReef = ()=>reefs[0];

//restart();

var prevTime = Now();

/*
//set slider to range -1 to 1. returns true/false did the slider exist.
var trySetSliderBifraction = (optionName,bifraction)=>{
	bifraction = between(-1,bifraction,1);
	let d = dom(domIdOfOption[optionName]);
	if(d){
		d.setAttribute('value',''+ro(500000+500000*bifraction));
		d.dispatchEvent(new Event("input"));
		return true;
	}else{
		return false;
	}
};*/

//var timeSliderVelocity = 0;
//var timeSliderPosition = 0;

//var constantDt = 1/30; //cuz without this, it becomes a different shape 

var nextState = ()=>{

	let reef = mainReef();
	//let prevCurve = reef.curves[reef.curves.length-1];
	let time = Now();
	//let dt = between(0,time-prevCurve.time,.1);
	//let dt = between(-.1,time-prevCurve.time,.1);
	let physicalDt = between(0,time-prevTime,.1);
	//if(constantDt) physicalDt = constantDt;
	
	loopAngle += physicalDt*2*Math.PI/o.loopSeconds;
	loopAngle = (loopAngle%twoPi);
	if(loopAngle < 0) loopAngle += twoPi;
	//0 <= loopAngle < twoPi.
	
	loopsUpdateSlidersAndChks();
	
	//physicalDt /= o.physicsCyclesPerDisplay;
	//for(let i=0; i<o.physicsCyclesPerDisplay; i++){
		//FIXME does this work with numberOfCurvesToUndoAsap and painting and display(...) removing from reefs[0].curves etc?
	
		//autoMoveSliders(physicalDt); //FIXME
		//physicalDt = 1/60; //FIXME
		
		let simDt = 0;
		if(o.useTimePosition){
			let wantToBeTime = o.timePosition;
			let isTime = reef.timePosition();
			let wantToAddTime = wantToBeTime-isTime;
			let decay = between(0,o.timePositionDecay,1)*physicalDt;
			simDt = decay*wantToAddTime;
			
			//FIXME dont let it change too fast.... its already limited to -.9 to .9 in Curve
			//simDt = between(-.5,simDt,.5);
		}else{
			simDt = physicalDt*o.timeSpeed;
		}
		simDt *= between(0,oo.computeSpeed,1); //slow it down if its skipping video/sim frames.
		
		
		prevTime = time;
		framesPerSecond = framesPerSecond*(1-physicalDt) + 1; //TODO adjustable decay rate?
		
		/*if(o.adjust_targetDistanceBetweenAdjacentCurvePoints_byFramesPerSecond){
			let targetFramesPerSecond = 50; //60 would be better but canvas seems to have a limit of 60
			o.targetDistanceBetweenAdjacentCurvePoints *= 1+dt*Math.exp(framesPerSecond/targetFramesPerSecond-1);
			o.targetDistanceBetweenAdjacentCurvePoints = between(.001, o.targetDistanceBetweenAdjacentCurvePoints, .3);
		}*/
		
		//let fakeTime = prevCurve.time+.03;
		//let dt = fakeTime-prevCurve.time;
		
		//dt, time, distanceToForce, addRandomness, optionalPrevCurve
		
		
		
		
		//if(o.negTimeDoesUndo) simDt -= physicalDt; //FIXME?
		
		let simDtWasNegative = simDt<0;
		
		//while((reef.curves.length > (1+numberOfCurvesToUndoAsap)) && o.negTimeDoesUndo && (simDt < 0)){
		let prevPrevSimDt = simDt; //FIXME?
		let prevSimDt = simDt; //FIXME?
		//while(numberOfCurvesToUndoAsap<reef.curves.length-3 && o.negTimeDoesUndo && ((simDt < 0) || (prevSimDt < 0))){
		if(o.negTimeDoesUndo && simDtWasNegative) numberOfCurvesToUndoAsap = 0; //else might set from browser console for testing
		while(numberOfCurvesToUndoAsap<reef.curves.length-3 && o.negTimeDoesUndo && (simDt < 0)){
			//checking prevSimDt is so it either removes no curves or removes at least 2, so number of curves decreases when doing undo
			numberOfCurvesToUndoAsap++;
			prevPrevSimDt = prevSimDt;
			prevSimDt = simDt;
			simDt += Math.abs(reef.curves[reef.curves.length-numberOfCurvesToUndoAsap].dt);
		}
		let prevCurve = reef.curves[reef.curves.length-1-numberOfCurvesToUndoAsap];
		if(o.negTimeDoesUndo){
			//simDt -= prevSimDt; //FIXME
			//simDt = prevSimDt; //FIXME
			//simDt = prevPrevSimDt; //FIXME
			//if(simDtWasNegative){
			//	simDt -= physicalDt; //FIXME
			//}
			simDt = mx(0,simDt); //in case theres not enuf curves to undo
			//if(simDtWasNegative) physicalDt = epsilon;
		}
		
		if(!prevCurve){
			console.log('NOT_prevCurve so end nextState early');
			return;
		}
		
		
		//let addRandomness = .08;
		//let addRandomness = 33.08;
		//let addRandomness = 1.08;
		//let addRandomness = 3;
		//let addRandomness = 10;
		//let addRandomness = 10;
		//let addRandomness = .3;
		let numPoints = prevCurve.numPoints; //FIXME let this vary between consecutive Curves.
		//let c = new Curve(dt, time, aForceFunc, defaultMaxDistanceToAffectEachother, reef.addRandomness, maxSpeed, o.friction, numPoints, reef.neuralWeights, reef.neuralFunc, prevCurve);
		
		
		//if(!simDtWasNegative){ //FIXME still do this but remove from those before it
		if(simDt != 0){
			//let c = new Curve(false, prevCurve, simDt, reef.potentialEnergyFunc, o.maxDistanceToAffectEachother, o.addRandomness, o.maxSpeed, o.friction, numPoints, reef.neuralWeights, reef.neuralFunc);
			let c = new Curve(prevCurve, simDt, reef.potentialEnergyFunc, o.maxDistanceToAffectEachother, o.addRandomness, o.maxSpeed, o.friction, numPoints, reef.neuralWeights, reef.neuralFunc);
			if(o.balanceSparsity){
				c.balanceSparsity(); //modifies c
			}
			/*if(o.linearInterpolateSparsity){
				if(o.minDistanceToInsertPoint < 1000000){
					c = c.insertPointsIfDistanceAtLeast(o.minDistanceToInsertPoint);
				}
				if(o.maxDistanceToRemovePoint > 0){
					//FIXME make the (ay,ax,by,bx,cy,cx) func check all 3 distances (not too sharp an angle, and distance(s))
					//That func returns true to keep the point, false to remove it but only removes if didnt remove the prev point,
					//and never removes point 0.
					c = c.removePoints((ay,ax,by,bx,cy,cx)=>(Math.hypot(ay-by,ax-bx)>o.maxDistanceToRemovePoint));
				}
			}*/
			//c.holdInRect(o.minX, o.maxX, o.minY, o.maxY);
			let borderMul = 1/(1-between(0,o.borderFraction,.95));
			c.holdInRect(-borderMul, borderMul, -borderMul, borderMul);
			/*if(holdInCircle_once){
				holdInCircle_once = false;
				let circ = circleToDisplayIn;
				circ.radius *= holdInCircle_once_sizeFraction;
				c.moveIntoBoundingCircle(circ);
			}else if(holdInCircle){
				c.moveIntoBoundingCircle(circleToDisplayIn);
			}*/
			reef.curves.push(c);
		}
		
		
		if(reef.curves.length > o.maxCurvesPerReef) reef.curves = reef.curves.slice(-o.maxCurvesPerReef); //remove oldest curves
		//TODO remove oldest if curves.length is too big. else run out of memory.
	//}
};

//var holdInCircle = false;
//var holdInCircle_once = true;
//var holdInCircle_once_sizeFraction = .3;

//for(let i=0; i<10; i++){
//	nextState();
//}




//var displayMode = 'displayAsManySvgs';
//var displayMode = 'displayNewestSvgOnly';
//var displayMode = 'canvas';

//var maxLineLenPaintedSoFar = 0;

/** normally the ByteRect of the canvas. Also fills curve.undoableVoxels if isUndoable,
so if you call this again it will undo that.
Does not change the scale if voxels already exist, only when they're first created,
so if you make a voxel, then change canvas size, then undo that voxel,
it will xor it in its original position on canvas
so you will see 2 of them and the new one isnt the right color. FIXME? Or just clear canvas
when resize it (which it would probably already do?)?
*/
var paintCurveOntoByterect = (isUndoable, curve, byteRect, centerY, centerX, scaleY, scaleX, lineThick)=>{
	let voxelsExist = curve.undoableVoxels.length>0;
	let makeVoxels = (isUndoable && !voxelsExist);
	let paintVoxels = isUndoable;
	//let paintTheWayOtherThanVoxels = !paintVoxels;
	let siz = curve.numPoints;
	//let colors = '#ff0000 #00cc00 #0000ff #888888 #22abab'.split(' ');
	//let throwAfterPaintLineLongerThanThis_squared = throwAfterPaintLineLongerThanThis*throwAfterPaintLineLongerThanThis;
	let maxDistSq = 0;
	let putVoxelIntoCurve = voxel=>curve.undoableVoxels.push(voxel);
	for(let lo=0; lo<siz; lo++){
		let hi = (lo+1)%siz;
		let x1 = ro(centerX+scaleX*curve.xp[lo]);
		let y1 = ro(centerY+scaleY*curve.yp[lo]);
		let x2 = ro(centerX+scaleX*curve.xp[hi]);
		let y2 = ro(centerY+scaleY*curve.yp[hi]);
		let dx = x2-x1, dy = y2-y1;
		let distSq = dy*dy+dx*dx;
		/*if(isNaN(distSq)){ //TODO optimize by removing these tests
			throw 'distSq is NaN';
		}
		if(distSq > throwAfterPaintLineLongerThanThis){ //TODO optimize by removing these tests
			throw 'painting too long a line (physics shouldnt do that) '+Math.sqrt(distSq);
		}*/
		maxDistSq = mx(maxDistSq, distSq);
		
		//let color = (i&1) ? '#00cc00' : '#0000ff'; //alternate color per line segment
		//let color = colors[lo%colors.length];
		//svg += '<line x1="'+x1+'" y1="'+y1+'" x2="'+x2+'" y2="'+y2+'" stroke="'+color+'" />';
		
		//TODO optimize using curve.red .green and .blue which are each a Float32Array.
		
		//let red = parseInt(color.substring(1,3),16); //0 to 255
		//let green = parseInt(color.substring(3,5),16);
		//let blue = parseInt(color.substring(5,7),16);
		
		//FIXME should this be (curve.red[lo]+curve.red[hi])/2?
		//If it slides colors around the loop, then do that.
		
		let mix = o.sameColorness; //+mix means +mix*1 cuz its mixing between neuralnet and 255. 255 means all that same color.
		let add = o.paintBrightAdd;
		let red = (curve.red[lo]*(1-mix)+mix*255)*o.paintBrightMult*o.brightMultRed+add;
		let green = (curve.green[lo]*(1-mix)+mix*255)*o.paintBrightMult*o.brightMultGreen+add;
		let blue = (curve.blue[lo]*(1-mix)+mix*255)*o.paintBrightMult*o.brightMultBlue+add;
		
		/*let red = curve.red[lo]*o.paintBrightMult*o.brightMultRed;
		let green = curve.green[lo]*o.paintBrightMult*o.brightMultGreen;
		let blue = curve.blue[lo]*o.paintBrightMult*o.brightMultBlue;
		*/
		if(!o.wrapPaintBrightMult){
			red = asByte(red);
			green = asByte(green);
			blue = asByte(blue);
		}
		
		
		//red = 0;
		//green = 255;
		//blue = 0;
		//let alpha = 255; //255 is visible. 0 is transparent.
		
		//byteRect.paintLineYXYXRGBSafe(y1, x1, y2, x2, red, green, blue);
		
		if(makeVoxels){
			byteRect.streamUndoable2dVoxelsForLineYXYXRGBSafe(
				putVoxelIntoCurve, y1, x1, y2, x2, red, green, blue, lineThick);
		}
		/*if(!paintVoxels){ //paint the other way
			throw '!paintVoxels'; //removing paintLineYXYXRGBSafe 2022-3-3 to save space since streamUndoable2dVoxelsForLineYXYXRGBSafe has similar code to paintLineYXYXRGBSafe
			//byteRect.paintLineYXYXRGBSafe(y1, x1, y2, x2, red, green, blue, lineThick);
		}//else wait until loop ends to paint all lines of the curve at once
		*/
	}
	if(paintVoxels){
		//all lines of this curve at once,
		//that were added by putVoxelIntoCurve(voxel) for the multiple voxels per line
		byteRect.paintVoxels(curve.undoableVoxels);
		//FIXME like streamUndoable2dVoxelsForLineYXYXRGBSafe checks prevX and prevY to not repeat points,
		//do the same here at the endpoints...
		//There will be a little overlap, which interferes with painting and undo.
		//DONE todo test... change streamUndoable2dVoxelsForLineYXYXRGBSafe to not repeat the same (y,x) it just used.	
	}
	//maxLineLenPaintedSoFar = mx(maxLineLenPaintedSoFar, Math.sqrt(maxDistSq));
};

//If !o.isSurface then it always clears
var clearCanvOnce = true;

var doPaintAccelFieldOnce = true;

var detectResize = null;

//var removeLast100Curves = ()=>{numberOfCurvesToUndoAsap += 100;};

//does display of newest curve or and removes from mainReef().curves based on numberOfCurvesToUndoAsap
//and displays by undo painting those.
//FIXME its confusing to call this display since it also modifieds reefs[0].curves by removing from it sometimes.
//Moving some of that code to nextState.
var display = ()=>{
	
	let reef = mainReef();
	var aDiv = dom('aDiv');
	let newestCurve = reef.curves[reef.curves.length-1];
	/*let displayMode = dom('displayModeIsCanvasElseSvg').checked ? 'canvas' : 'displayNewestSvgOnly';
	if(displayMode == 'displayAsManySvgs'){
		let svgHtml = newestCurve.toSvgImageHtmlString();
		let newDiv = document.createElement('div');
		newDiv.innerHTML = svgHtml;
		newDiv.style.position = 'absolute';
		newDiv.style.left = 0;
		newDiv.style.top = 0;
		

		//dom('aDiv').innerHTML = svgHtml;
		//dom('aDiv').appendChild(newDiv);
		aDiv.appendChild(newDiv);
	}else if(displayMode == 'displayNewestSvgOnly'){
	*/
	
	
	//if(o.stretchToWindow){
		minY = 0;
		minX = 0;
		//FIXME if magnify canvas divide by how much its magnified and Math.floor ceil or round.
		//maxY = takingPic ? snapshotH : wi.innerHeight;
		//maxX = takingPic ? snapshotW : wi.innerWidth;
		maxY = wi.innerHeight;
		maxX = wi.innerWidth;
	//}
	
	let centerY = (maxY+minY)/2;
	let centerX = (maxX+minX)/2;
	let scaleY = Math.abs((1-o.borderFraction)*mn(maxY-minY,maxX-minX)/2); //abs cuz if borderFraction > 1 then it turns the display inside out and scaleY would be negative so the loops end instantly cuz max < min
	let scaleX = scaleY;
	let nextDetectResize = centerY+'_'+centerX+'_'+scaleY+'_'+scaleX;
	if(detectResize != nextDetectResize){
		setTimeout(()=>{doPaintAccelFieldOnce = clearCanvOnce = true;}, 200);
	}
	detectResize = nextDetectResize;
	
	//2022-1-5 about to change canvasElseSvg to mean canvas both ways, except 
	
	/* ALWAYS CANVAS, as of 2021-1-11+.
	
	if(!o.canvasElseSvg){ //svg
	
		//TODO merge duplicate code
		//This makes svg display mode able to rewind time, like canvas can, except you only see the newest.
		let newestCurve = reef.curves.pop();
		while(reef.curves.length > 2 && numberOfCurvesToUndoAsap > 0){
			let curveToUndoPaint = reef.curves.pop();
			//paintCurveOntoByterect(rememberHowToUndo, curveToUndoPaint, canv.byteRect, centerY, centerX, scaleY, scaleX);
			numberOfCurvesToUndoAsap--;
		}
		reef.curves.push(newestCurve); //in case removed some starting at second newest
		
	
		let svgHtml = newestCurve.toSvgImageHtmlString(centerY, centerX, scaleY, scaleX);
		aDiv.style.position = 'absolute';
		aDiv.style.left = minX;
		aDiv.style.top = minY;
		aDiv.style.zIndex = -100; //behind the sliders and button etc
		aDiv.innerHTML = svgHtml;
	}
	if(o.canvasElseSvg || clearCanvOnce){ //canvas
	*/
	
		if(builder && aDiv.innerHTML != '') aDiv.innerHTML = '';
		
		let onlyClear = clearCanvOnce;
	
		//TODO optimize by not creating svg
		
		
		//if(!o.scr){
			//in NFTs (!o.scr) it resizes when window size changes.
			//When making screenshots, you only get 2 sizes, the thumbnail size, then whatever size the window starts at.
			if(minX+10 < maxX && minY+10 < maxY){ //dont let sliders make it negative size etc
				canv.resizeCanvas(minX, maxX, minY, maxY);
			}
		//}
		
		let by = canv.byteRect;
		
		if(clearCanvOnce || !o.isSurface){
			clearCanvOnce = false;
			canv.beforePaint();
			by = canv.byteRect; //cuz beforePaint might replace the ByteRect
			
			/*
			if(!window.paintAccelField){ //just paint background, which paintAccelField also did
				let r = asByte(o.brightAddRed), g = asByte(o.brightAddGreen), b = asByte(o.brightAddBlue);
				for(let i=0; i<by.length; i+=4){
					by[i+RED] = randInt(256);
					by[i+GREEN] = randInt(256);
					by[i+BLUE] = randInt(256);
					by[i+ALPHA] = 255;
				}
			}*/
		}
		//for(let i=ALPHA; i<canv.byteRect.length; i+=4) canv.byteRect[i] = 255; //make everything visible
		for(let i=ALPHA; i<canv.byteRect.length; i+=4){
			//by[i+RED] = o.brightAddRed; //FIXME why wont this background painting work?
			//by[i+GREEN] = o.brightAddGreen;
			//by[i+BLUE] = o.brightAddBlue;
			by[i] = 255; //make everything visible
		}
		
		
		if(!onlyClear){
		
			//let paintAcc = doPaintAccelFieldOnce || (!o.isSurface && dom('paintBackground').checked);
			let paintAcc = doPaintAccelFieldOnce || !o.isSurface;
			//added (!o.isSurface && dom('paintBackground').checked) cuz the accelField (blue and green hills) wasnt displaying while !isSurface except when clicking to paint it
			doPaintAccelFieldOnce = false;
			
			/*if(doPaintAccelFieldOnce){  //FIXME why wont this background painting work?
				let by = canv.byteRect.b;
				for(let i=0; i<by.length; i++){
					//paint whole canvas the background color, before painting the scaledToMinOfScreenHeightOrWidth 1024x1024 accel field inside it,
					//in case the screen isnt square. Since paintAcc only happens once per viewing the reef (or when using the builder more often)
					//this wont slow things down except an extra paint cycle when it starts.
					by[i+RED] = o.brightAddRed;
					by[i+GREEN] = o.brightAddGreen;
					by[i+BLUE] = o.brightAddBlue;
					//by[i+ALPHA] = 255;
				}
			}*/
		
			//check window.paintAccelField instead of just paintAccelField, cuz builder might create the var or not.
			if(paintAcc){
				//if(window.paintAccelField){ //paintAccelField is a function moved into builder 2022-5-9. before that, both NFTs and builder could display hills. now only builder.
				if(!window.paintAccelField){
					//this fills whole canvas with background color, unlike the bigger paintAccelField func in the builder which is just a square where accelField is, thats a 1024x1024 accelField scaled into a square depending on canvas size.
					//window.paintAccelField = (brightAddRed, brightAddGreen, brightAddBlue, brightMult, accelField, aYFrom, aYTo, aXFrom, aXTo, byteRect, bYFrom, bYTo, bXFrom, bXTo)=>{
						//let by = byteRect.b;
						let ar = by.b;
						let r = asByte(o.brightAddRed), g = asByte(o.brightAddGreen), b = asByte(o.brightAddBlue);
						for(let i=0; i<ar.length; i+=4){
							ar[i+RED] = r;
							ar[i+GREEN] = g;
							ar[i+BLUE] = b;
							ar[i+ALPHA] = 255;
						}
					//};
				}else{
					//let brightAdd = 127, brightMult = 50;
					paintAccelField(o.brightAddRed, o.brightAddGreen, o.brightAddBlue, o.brightMult,
						accelField, 0, 1024, 0, 1024, //aYFrom, aYTo, aXFrom, aXTo,
						canv.byteRect, fl(centerY-scaleX*2), fl(centerY+scaleY*2), fl(centerX-scaleX*2), fl(centerX+scaleX*2) //bYFrom, bYTo, bXFrom, bXTo
					);
				}
				/*}/*else{ //just paint background, which paintAccelField also did
					let r = asByte(o.brightAddRed), g = asByte(o.brightAddGreen), b = asByte(o.brightAddBlue);
					for(let i=0; i<by.length; i+=4){
						by[i+RED] = randInt(256);
						by[i+GREEN] = randInt(256);
						by[i+BLUE] = randInt(256);
						by[i+ALPHA] = 255;
					}
				}*/
			}
		
			//Remove starting with second newest. Newest was just put in to adjust for removing that, in nextState.
			//let rememberHowToUndo = o.canvasElseSvg && o.ifCanvasUseUndoGraphics;
			let rememberHowToUndo = o.ifCanvasUseUndoGraphics; //always canvas
			let newestCurve = reef.curves.pop();
			if(rememberHowToUndo && numberOfCurvesToUndoAsap > 0){ //undo paint
				//FIXME??? dont remove newest Curve, start removing just before that one?
				
				//dont undo newest cuz it hasnt been painted yet
				//and undoing would paint it (cuz it is its own inverse).
				//let isNewest = true;
				
				while(reef.curves.length > 2 && numberOfCurvesToUndoAsap > 0){
					//let newestCurve = reef.curves.pop();
					let curveToUndoPaint = reef.curves.pop();
					//reef.curves.push(newestCurve);
					//if(!isNewest){ //undo paint
						paintCurveOntoByterect(rememberHowToUndo, curveToUndoPaint, canv.byteRect, centerY, centerX, scaleY, scaleX, mx(1,o.lineThick));
					//}
					numberOfCurvesToUndoAsap--;
					//isNewest = false;
				}
				numberOfCurvesToUndoAsap = 0;
			}
			//normal paint
			reef.curves.push(newestCurve); //in case removed some starting at second newest
			paintCurveOntoByterect(rememberHowToUndo, newestCurve, canv.byteRect, centerY, centerX, scaleY, scaleX, mx(1,o.lineThick));
			/*
			let rememberHowToUndo = o.canvasElseSvg && o.ifCanvasUseUndoGraphics;
			if(rememberHowToUndo && numberOfCurvesToUndoAsap > 0){ //undo paint
				//FIXME??? dont remove newest Curve, start removing just before that one?
				
				//dont undo newest cuz it hasnt been painted yet
				//and undoing would paint it (cuz it is its own inverse).
				let isNewest = true;
				
				while(reef.curves.length > 1 && numberOfCurvesToUndoAsap > 1){
					let curveToUndoPaint = reef.curves.pop();
					if(!isNewest){ //undo paint
						paintCurveOntoByterect(rememberHowToUndo, curveToUndoPaint, canv.byteRect, centerY, centerX, scaleY, scaleX);
					}
					numberOfCurvesToUndoAsap--;
					isNewest = false;
				}
				numberOfCurvesToUndoAsap = 0;
			}else{ //normal paint
				paintCurveOntoByterect(rememberHowToUndo, newestCurve, canv.byteRect, centerY, centerX, scaleY, scaleX);
			}
			*/
			
			if(builder && chkBuilder()){
				tryDispOutCirc(centerY, centerX, scaleY, scaleX); //hide circles and Loops if the top left checkbox "display reef builder (uncheck for emptier screen)" is unchecked.
			}
		}

		/*moving this into builder. making new func bldDisp.
		if(builder){
			let isOnlyDisplaySelectedLoop = dom('chkOnlyPaintSelectedLoop').checked;
			if(chkBuilder() && o.displayOuterCircle){
				paintLoops(centerY, centerX, scaleY, scaleX, isOnlyDisplaySelectedLoop); //paint grooves
			}
			//This removes the loop labels such as "maxSpeed = 0.13819509427765803", which otherwise would remain while the loop isnt displayed.
			for(let option in loops){
				let displayLoopLabel = o.displayOuterCircle && (!isOnlyDisplaySelectedLoop || option == selectedOption);
				if(!displayLoopLabel && loops[option].domLabel){
					loops[option].domLabel.remove();
					delete loops[option].domLabel;
				}
			};
		
			if(chkBuilder() && o.graphEndist) graphEndist();
		}
		*/
		if(builder) bldDisp(centerY, centerX, scaleY, scaleX);
		
		canv.afterPaint();
		
	//} cuz always canvas.
};

//console.log(svg);

var booted = false;

//range 0 (paused) to 1 (use as much compute power as is available), or between.
//Turn this down if its slowing your computer or if you want to display a bunch of nfts (not just this one) at once (TODO 
//TODO use this.
//var computeSpeed = 1;

var count_loopNextStateAsync = 0;

var loopNextStateAsync = ()=>{
	count_loopNextStateAsync++;
	
	var doSomething =  true;
	if(o.pause || (o.computeSpeed <= 0)){
		doSomething = false;
	}else{
		let skipInterval = Math.ceil(1/o.computeSpeed); //TODO smoother instead of integers. use Math.random() to choose between 2 adjacent integers?
		doSomething = (count_loopNextStateAsync%skipInterval)==0;
	}
	
	if(doSomething){
		nextState();
		display();
	}
	requestAnimationFrame(loopNextStateAsync);
};

var bo = null;

//let prevOnload = wi.onload===undefined ? undefined : wi.onload;

/*wi.onload = ()=>{
	//console.log('window.onload...');
	if(builder) bootBuilder();
};*/


//let evv = null;

wi.onload = ()=>{
	booted = true;
	
	//if(prevOnload) prevOnload();
	if(builder) bootBuilder();

	bo = dom('divabxy');
	
	if(!canv){
		canv = new FullScreenCanvas(bo);
		//if(o.scr) canv.resizeCanvas(300,450); //generate thumbnail this size
		
		/*if(builder){
			//requestAnimationFrame(()=>{
				let d = document.body;
				//if(!canv.dom) throw 'No canvas';
				//let d = canv.dom;
				d.addEventListener('mousemove', function(event){
					mouseY = event.clientY;
					mouseX = event.clientX;
					doMouse(event);
				});
				d.addEventListener('mouseup', function(event){
					delete mouseButtonDown[event.button];
					doMouse(event);
				});
				d.addEventListener('mousedown', function(event){
					mouseButtonDown[event.button] = true;
					doMouse(event);
				});
			//});
		}*/
	}
	
	restart();
	
	//display();
	loopNextStateAsync();
};

/*
//range -1 to 1. center is 0.
var evoSliderVal = i=>(dom('evoSlider'+i).valueAsNumber/500000-1);

var onChangeEvoSlider = ()=>{
	var params = [];
	//ignore first slider, cuz thats mainReef() and its neuralnet gets replaced by weightedSum of the others.
	//The weight is slider position, (FIXME except scaled). Center slider position is weight 0. Range -1 to 1.
	let weightSumOfSquares = 0;
	for(let i=1; i<10; i++){
		let weight = evoSliderVal(i);
		weightSumOfSquares += weight*weight;
		params.push(null, weight);
		//params.push(reefs[i], weight);
	}
	if(weightSumOfSquares != 0){
		//let weightMul = Math.pow(weightSumOfSquares,-.5); //FIXME?
		let weightMul = 1; //FIXME
		for(let i=1; i<params.length; i+=2){
			params[i] *= weightMul;
		}
		let numLayers = reefs[0].neuralWeights.length;
		let newLayers = [];
		for(let layer=0; layer<numLayers; layer++){
			for(let i=1; i<10; i++){
				params[(i-1)*2] = reefs[i].neuralWeights[layer];
			}
			//newLayers.push(Tensor.weightedSum.call(params)); //call vararg using array
			newLayers.push(Tensor.weightedSum(...params)); //call vararg using array
		}
		normNeuralWeights(newLayers);
		reefs[0] = reefs[0].withNeuralWeights(newLayers);
		clearCanvOnce = true;
	}
};
*/


/*
minifier options

TODO get mangle eval working since it saves a few kB thats very much needed.

https://skalman.github.io/UglifyJS-online/

var savedWrappedOptions = [{"timeSaved":1643652271.3149,"options":{"bootShapeY":0.01,"bootShapeX":0.01,"bootShapeScale":1,"nearPdist":0.0058257498138787394,"friction":0.00014589646991245935,"loopSeconds":30,"useTimePosition":true,"timePosition":12.76733546574334,"timePositionDecay":0.2904555222925532,"timeSpeed":0.2569757262572446,"minPointsPerCurve":68,"maxPointsPerCurve":700,"maxNumPointsPerCurveChangeAtOnce":398,"borderFraction":0.6635766113710528,"maxSpeed":0.07039752659057333,"targetDistanceBetweenAdjacentCurvePoints":0.012859076499517052,"maxCurvesPerReef":10000,"scalePotentialEnergyForce":2.1043132057258638,"ampStraightIfNear":1421,"maxDistanceToAffectEachother":0.08338258688913296,"addRandomness":303.43506872413053,"stayInsideBorderCircleForce":34187599.622608334,"distanceScale":0.023617218953926614,"pause":false,"attractIfFartherThan":.4,"ampAttractIfFartherThan":1144,"graphEndist":true,"graphEndistBright":"Math.sqrt","isSurface":false,"displayOuterCircle":true,"isOnlyMoveRandomlyPerpendicularToSurface":true,"ifCanvasUseUndoGraphics":true,"negTimeDoesUndo":true,"autoMoveTimeSpeedSlider":false,"balanceSparsity":true,"minDistanceToInsertPoint":0.010664523535001256,"maxDistanceToRemovePoint":0.003289959052145843,"onlyEndist":false,"setSpeedsToZeroAfterEveryDtMove":false,"bootShape":"a=>.2","endist":



"(en,dist,pdist)=>{\n\tlet x = 0;\n\tlet p = o;\n\tlet nd = p.nearPdist;\n\tlet near = sigmoid(-5*(dist-nd));\n\tif(dist > o.attractIfFartherThan) x += o.ampAttractIfFartherThan*sqr(dist-o.attractIfFartherThan);\n\tx += o.ampStraightIfNear*near*sqr(dist-pdist);\n    let midDist = p.midDist;\n    x += bell(midDist*p.bellAAveMul,midDist*p.bellADevMul,p.bellAHeight,dist);\n    x += bell(midDist*p.bellBAveMul,midDist*p.bellBDevMul,p.bellBHeight,dist);\n    x += bell(midDist*p.bellCAveMul,midDist*p.bellCDevMul,p.bellCHeight,dist);\n\t\n\tlet m=dist*twoPi;\n\tx += sin(m*p.freqA)*p.ampA;\n    x += sin(m*p.freqB)*p.ampB;\n    x += sin(m*p.freqC)*p.ampC;\n    //if(dist > midDist) x += Math.pow(dist-midDist,1.3)*100;\n\tx += en; return x;\n}","freqA":7.95,"ampA":2.3593818090090117,"freqB":95.13673141063948,"ampB":75.02119251272455,"freqC":4.61,"ampC":0.3152110989852881,"midDist":0.05743052557643339,"bellAAveMul":1.4236555842764598,"bellADevMul":0.4,"bellAHeight":-368.8544521684587,"bellBAveMul":2,"bellBDevMul":1,"bellBHeight":-16,"bellCAveMul":5.686535881934632,"bellCDevMul":8.173385235692217,"bellCHeight":-13.157573945992816,"forceMaxResolution":true,"stretchToWindow":true,"canvasElseSvg":true,"isEraseCanvasEachFrame":true,"repelSelf":49280.617331884896,"repelSelfDistance":40.16219796816537,"name":"extraCurvy2_timepos8","loops":{"timePosition":[0.9115578532218933,1.1167867183685303,1.079515814781189,1.0371800661087036,0.27542948722839355,0.3950403332710266,0.643233060836792,0.9389271140098572,1.209054708480835,1.2687549591064453,1.2641907930374146,1.1229578256607056,0.9052594304084778,0.6844800114631653,0.580111026763916,0.6779861450195312,1.2666280269622803,2.00852632522583,2.6107709407806396,2.9665963649749756,2.4056434631347656,2.668116807937622,2.3045735359191895,1.8647334575653076,1.1883808374404907,0.9318413734436035,0.7176463603973389,0.6515563726425171,0.7804340720176697,0.7567130327224731,0.635796308517456,0.4083050787448883,0.18943065404891968,-0.11937591433525085,-0.2639542520046234,-0.39527446031570435,-0.3468655049800873,-0.26979905366897583,-0.1669379323720932,0.01796189695596695,0.2617584764957428,0.5872296690940857,0.7925310134887695,0.8962916731834412,1.0982377529144287,1.1954227685928345,1.2084693908691406,1.0287593603134155,0.9007567167282104,0.7418981194496155,0.604279637336731,0.3184124231338501,0.2507975995540619,0.36510419845581055,1.0884661674499512,1.7389754056930542,1.8401141166687012,1.6199041604995728,1.2144371271133423,0.7653419375419617,0.5436934232711792,0.43576082587242126,0.4521099925041199,0.7595627903938293]},"computeSpeed":1.2919135203825218,"colorSeed":42}}];

// Documentation of the options is available at https://github.com/mishoo/UglifyJS2
let uglifyjsOptions =
{
  parse: {
	bare_returns     : false,
	ecma             : 8,
	expression       : false,
	filename         : null,
	html5_comments   : true,
	shebang          : true,
	strict           : false,
	toplevel         : null
  },
  compress: {
	arrows           : true,
	booleans         : true,
	collapse_vars    : true,
	comparisons      : true,
	computed_props   : true,
	conditionals     : true,
	dead_code        : true,
	drop_console     : true,
	drop_debugger    : true,
	ecma             : 5,
	evaluate         : true,
	expression       : false,
	global_defs      : {},
	hoist_funs       : false,
	hoist_props      : true,
	hoist_vars       : false,
	ie8              : false,
	if_return        : true,
	inline           : true,
	join_vars        : true,
	keep_classnames  : false,
	keep_fargs       : true,
	keep_fnames      : false,
	keep_infinity    : false,
	loops            : true,
	negate_iife      : true,
	passes           : 1,
	properties       : true,
	pure_getters     : "strict",
	pure_funcs       : [],
	reduce_funcs     : true,
	reduce_vars      : true,
	sequences        : true,
	side_effects     : true,
	switches         : true,
	top_retain       : null,
	toplevel         : false,
	typeofs          : true,
	unsafe           : false,
	unsafe_arrows    : false,
	unsafe_comps     : false,
	unsafe_Function  : false,
	unsafe_math      : false,
	unsafe_methods   : false,
	unsafe_proto     : false,
	unsafe_regexp    : false,
	unsafe_undefined : false,
	unused           : true,
	warnings         : false
  },
  mangle: {
	eval             : true,
	ie8              : false,
	keep_classnames  : false,
	keep_fnames      : false,
	properties       : false,
	reserved         : ['onload','body','createElement','appendChild','sigmoid','sqr','bell','twoPi','Math','sin','o','oo','optionIsBit','optionIsInteger','builder','buboot','window','timing','navigationStart','setColorSeed','seed','pseudorandomNext','pseudorandomFraction','loops','timePosition','bootShapeY','bootShapeX','bootShapeScale','bootShape','nearPdist','friction','loopSeconds','useTimePosition','timePosition','timePositionDecay','timeSpeed','minPointsPerCurve','maxPointsPerCurve','maxNumPointsPerCurveChangeAtOnce','borderFraction','maxSpeed','targetDistanceBetweenAdjacentCurvePoints','maxCurvesPerReef','scalePotentialEnergyForce','ampStraightIfNear','maxDistanceToAffectEachother','addRandomness','stayInsideBorderCircleForce','distanceScale','pause','attractIfFartherThan','ampAttractIfFartherThan','graphEndist','graphEndistBright','isSurface','displayOuterCircle','isOnlyMoveRandomlyPerpendicularToSurface','ifCanvasUseUndoGraphics','negTimeDoesUndo','autoMoveTimeSpeedSlider','balanceSparsity','minDistanceToInsertPoint','maxDistanceToRemovePoint','onlyEndist','setSpeedsToZeroAfterEveryDtMove','freqA','ampA','freqB','ampB','freqC','ampC','midDist','bellAAveMul','bellADevMul','bellAHeight','bellBAveMul','bellBDevMul','bellBHeight','bellCAveMul','bellCDevMul','bellCHeight','forceMaxResolution','stretchToWindow','canvasElseSvg','isEraseCanvasEachFrame','repelSelf','repelSelfDistance','computeSpeed','colorSeed','endist','en','dist','pdist','nearPdist','name','putHills','accelVoxels','useAsBoot','ro','mn','mx','sin','cos','wi','px','fl','ce','lt','gt','amp','nbsp'],
	
	safari10         : false,
	toplevel         : true
  },
  output: {
	ascii_only       : false,
	beautify         : false,
	bracketize       : false,
	comments         : false,
	ecma             : 5,
	ie8              : false,
	indent_level     : 4,
	indent_start     : 0,
	inline_script    : true,
	keep_quoted_props: false,
	max_line_len     : false,
	preamble         : null,
	preserve_line    : false,
	quote_keys       : false,
	quote_style      : 1, //0 is doublequote. 1 is singlequote.
	safari10         : false,
	semicolons       : true,
	shebang          : true,
	source_map       : null,
	webkit           : false,
	width            : 80,
	wrap_iife        : false
  },
  wrap: false
}



Some names in o/options map:
loops
timePosition
bootShapeY
bootShapeX
bootShapeScale
bootShape
nearPdist
friction
loopSeconds
useTimePosition
timePosition
timePositionDecay
timeSpeed
minPointsPerCurve
maxPointsPerCurve
maxNumPointsPerCurveChangeAtOnce
borderFraction
maxSpeed
targetDistanceBetweenAdjacentCurvePoints
maxCurvesPerReef
scalePotentialEnergyForce
ampStraightIfNear
maxDistanceToAffectEachother
addRandomness
stayInsideBorderCircleForce
distanceScale
pause
attractIfFartherThan
ampAttractIfFartherThan
graphEndist
graphEndistBright
isSurface
displayOuterCircle
isOnlyMoveRandomlyPerpendicularToSurface
ifCanvasUseUndoGraphics
negTimeDoesUndo
autoMoveTimeSpeedSlider
balanceSparsity
minDistanceToInsertPoint
maxDistanceToRemovePoint
onlyEndist
setSpeedsToZeroAfterEveryDtMove
freqA
ampA
freqB
ampB
freqC
ampC
midDist
bellAAveMul
bellADevMul
bellAHeight
bellBAveMul
bellBDevMul
bellBHeight
bellCAveMul
bellCDevMul
bellCHeight
forceMaxResolution
stretchToWindow
canvasElseSvg
isEraseCanvasEachFrame
repelSelf
repelSelfDistance
computeSpeed
colorSeed
endist
en
dist
pdist
nearPdist
name


*/



/*
The "record grooves" are scaled correctly now. They multiply the sliders by a number. Theres 5 circles marking where its multiplied by -2 -1 0 1 or 2, and gradually anywhere on that scale. The innermost circle is the border the reef is supposed to stay in. Watch as it rewinds time making the reef smaller then expands again. You still cant edit the "record grooves" or save them, but I'll get that working soon. Its reading them from the options map, the same as it reads slider positions and  checkboxes.<br>
*/



/////bbbbb
</script>
<script>

//this jszip script was added 2022-3-27 and is not needed for making individual reefs or cardanojson/NFT.
//Its only needed for saving many at a time, such as a zip of 8888 jsons,
//since you wouldnt want to download 8888 files from browser at once,
//and if I gave it as 1 bit json, that would make it harder to drag them in to view them each.

/*
https://cdnjs.cloudflare.com/ajax/libs/jszip/3.5.0/jszip.min.js

zip.js is an open-source library (BSD-3-Clause license) for zipping and unzipping files in the browser and Deno.

See here for more info: https://gildas-lormeau.github.io/zip.js/

/*!

JSZip v3.5.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

{
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).JSZip=t()}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e="function"==typeof require&&require;if(!t&&e)return e(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/DataLengthProbe"),a=t("./stream/Crc32Probe");s=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new a).pipe(new s("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new s("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.5.0",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=(i=t("./utils"),t("./zipEntries")),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)this.files.hasOwnProperty(e)&&(i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i))},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});
}
</script>
<script>

//this goes with the jszip script.

//Example: {"dirA/dirB/file.txt": aUint8Array_or_string, "anotherFile.xyz": aUint8Array_or_string_2} -> Uint8Array
var mapToZipThen = (map,then)=>{
	sharedLogSuffix = ' - mapToZipThen';
	let zip = new JSZip();
	for(let path in map){
		let dir = zip;
		let dirsThenFilename = path.split('/');
		if(dirsThenFilename.length == 0) throw 'Empty';
		for(let i=0; i<dirsThenFilename.length-1; i++) dir = dir.folder(dirsThenFilename[i]); //FIXME does duplicate dir cause problem or get the same dir?
		let filename = dirsThenFilename[dirsThenFilename.length-1];
		console.log('zipping filename='+filename);
		let val = map[path];
		if(typeof(val) == 'string'){
			dir.file(filename, val);
		}else throw 'TODO type other than string (such as Uint8Array): '+typeof(val);
	}
	let progressListener = function(metadata){
		console.log('Zip percent done: '+metadata.percent+sharedLogSuffix);
		//window.title = 'zip '+metadata.percent+'%';
		//element.style.width = metadata.percent + '%';
	};
	/*https://github.com/Stuk/jszip/issues/373
	zip.generateAsync({type: "blob", streamFiles: true}, function updateCallback(metadata) {
		element.style.width = metadata.percent + '%';
	})
	*/
	zip.generateAsync({type: 'uint8array'},progressListener).then(then);
};

/*
mapToZipThen(
	{hi: 'hello'},
	zip=>{
		console.log('zip='+zip);
	}
);*/

</script>
<script>

//The NFT maker functions are being redesigned - here they are".
//
//QUOTE FROM TOP OF THIS FILE:
//The NFT maker functions are being redesigned.
//dataUrlForNFTNumber1To8888 jsonForNFTNumber1To8888 dataUrlForNFTNumber1To8888 and saveNFT only ever worked for 1 reef at a time.
//I'm moving these to a script near the bottom of this file, after the 2 jszip scripts.
//Search for "The NFT maker functions are being redesigned - here they are".

//you can drag in 2 or more json files, the kind that are 5kB or less (or if bigger they probably wont fit in cardano but may still be used)
//(not the kind near 16kB), and they will be in manyEvolvableOptions var.



//??? TODO maybe these makeOptions* funcs should be in the first script,
//since these are for the builder, not specific to making batches of reefs.

var exists = x=>(x !== null && x!== undefined);

//These makeOptions* funcs are for the "dragging in json file changes" checkboxes...
//Dont forget to putInDefaults (which modifies its param options.

//takes 2 options/{} and makes 1 options, with everything from prototypeOptions except the color stuff from colorOptions.
//Strangely, makeOptionsSlidersAndCheckboxes includes colorDecayPerSec instead of makeOptionsColor including it, cuz the sliders affect time speeds etc.
var makeOptionsColor = (prototypeOptions, colorOptions)=>{
	let ret = copyMap(prototypeOptions);
	ret.colorSeed = colorOptions.colorSeed;
	ret.brightMultRed = colorOptions.brightMultRed;
	ret.brightMultGreen = colorOptions.brightMultGreen;
	ret.brightMultBlue = colorOptions.brightMultBlue;
	ret.brightAddRed = colorOptions.brightAddRed;
	ret.brightAddGreen = colorOptions.brightAddGreen;
	ret.brightAddBlue = colorOptions.brightAddBlue;
	ret.sameColorness = colorOptions.sameColorness;
	return ret;
};

//takes 2 options/{} and makes 1 options, with everything from prototypeOptions except the bootShape* stuff from bootShapeOptions.
var makeOptionsBootShape = (prototypeOptions, bootShapeOptions)=>{
	let ret = copyMap(prototypeOptions);
	ret.bootShape = bootShapeOptions.bootShape;
	ret.bootShapeY = bootShapeOptions.bootShapeY;
	ret.bootShapeX = bootShapeOptions.bootShapeX;
	ret.bootShapeScale = bootShapeOptions.bootShapeScale;
	return ret;
};

//takes 2 options/{} and makes 1 options, with everything from prototypeOptions except the isSurface stuff from surfaceOptions.
var makeOptionsSurface = (prototypeOptions, surfaceOptions)=>{
	let ret = copyMap(prototypeOptions);
	ret.isSurface = surfaceOptions.isSurface;
	return ret;
};

//takes 2 options/{} and makes 1 options, with everything from prototypeOptions except the loops/grooves stuff from groovesOptions.
var makeOptionsGrooves = (prototypeOptions, groovesOptions)=>{
	let ret = copyMap(prototypeOptions);
	ret.loops = exists(groovesOptions.loops) ? copyMap(groovesOptions.loops) : {};
	return ret;
};

//takes 2 options/{} and makes 1 options, with everything from prototypeOptions except the sliders/curves/checkboxes stuff from slidersOptions.
//Strangely, makeOptionsSlidersAndCheckboxes includes colorDecayPerSec instead of makeOptionsColor including it, cuz the sliders affect time speeds etc.
var makeOptionsSlidersAndCheckboxes = (prototypeOptions, slidersOptions)=>{
	//WARNING: this needs to be updated to not include anything in the other makeOptions* funcs.
	let ret = copyMap(prototypeOptions);
	for(let option in slidersOptions){
		if(is_makeOptionsSlidersAndCheckboxes_option(option)){
			ret[option] = slidersOptions[option];
		}
	}
	return ret;
};

var makeOptionsDir = (prototypeOptions, dirOptions)=>{
	let ret = copyMap(prototypeOptions);
	ret.dir = dirOptions.dir;
	return ret;
};

var makeOptionsHills = (prototypeOptions, hillsOptions)=>{
	//WARNING: this needs to be updated to not include anything in the other makeOptions* funcs.
	let ret = copyMap(prototypeOptions);
	ret.accelVoxels = exists(hillsOptions.accelVoxels) ? copyMap(hillsOptions.accelVoxels) : [];
	ret.accelFieldMul = hillsOptions.accelFieldMul;
	ret.brightMult = hillsOptions.brightMult; //only about displaying hills.
	return ret;
};

//These normally dont change, but just in case...
var makeOptionsFuncs = (prototypeOptions, funcsOptions)=>{
	let ret = copyMap(prototypeOptions);
	ret.endist = funcsOptions.endist;
	ret.graphEndistBright  = funcsOptions.graphEndistBright ;
	return ret;
};

var is_makeOptionsSlidersAndCheckboxes_option = option=>{
	return exists(option) && !(/^(bootShape.*|isSurface|loops|accelVoxels|colorSeed|endist|endist|graphEndist|accelFieldMul|brightMultRed|brightMultGreen|brightMultBlue|brightAddRed|brightAddGreen|brightAddBlue|sameColorness|brightMult|graphEndistBright)$/.test(option));
};



//3 options/{} to 1
var makeOptions = (sliderAndGroove, colorsReef, bootShape)=>{
	let ret = copyMapAndPutInDefaultsIfAbsent(sliderAndGroove);
	colorsReef = copyMapAndPutInDefaultsIfAbsent(colorsReef);
	bootShape - copyMapAndPutInDefaultsIfAbsent(bootShape);
	ret.colorSeed = colorsReef.colorSeed;
	ret.bootShape = bootShape.bootShape;
	ret.bootShapeY = bootShape.bootShapeY;
	ret.bootShapeX = bootShape.bootShapeX;
	ret.bootShapeScale = bootShape.bootShapeScale;
	return ret;
};

//UPDATE: use makeSpecies instead of makeNOptions.
//
//Returns a list/[] of size n, of combined options/{}.
//This is repeatable since it uses a specific pseudorandom seed.
//slidersAndGroovesReefs is a list/[] of options/{} that chooses the shape and grooves that change the shape over time,
//and maybe also the name to describe where it got the color from.
//colorsReefs is list/[] of options/{} that it only uses colorSeed in that, and maybe also the name to describe where it got the color from.
//bootShapesReefs is list/[] of options/{} that it only uses bootShape* parts, and maybe also the name to describe where it got the color from.
//If fractionToChangeBootShapes is .7 it will use bootShapesReefs approx .7 fraction of the time
//and use what it already was bootShapesReefs approx .3 fraction of the time,
//since slidersAndGroovesReefs were manually designed or [evolved and hand picked],
//vs changing its bootShape might not look as good to start from a different shape (that may not overlap its hills well, if it has hills).
//but gives it more variety.
var makeNOptions = (n, slidersAndGroovesReefs, colorsReefs, bootShapesReefs, fractionToChangeBootShapes)=>{
	//FIXME fractionToChangeBootShapes isnt used as of 2022-3-28.
	return repeatable(()=>{
		let ret = [];
		let sIndex = 0;
		while(ret.length < n){
			let s = slidersAndGroovesReefs[(sIndex++)%slidersAndGroovesReefs.length];
			let c = colorsReefs[randInt(colorsReefs.length)];
			let b = bootShapesReefs[randInt(bootShapesReefs.length)];
			let opt = makeOptions(s, c, b);
			opt.name = 'testReef'+(ret.length+1)+'of'+n+'_'+opt.name;
			ret.push(opt);
			if(ret.length && ret.length%100==0) console.log('makeNOptions '+ret.length+'/'+n);
		}
		return ret;
	});
};

//you drag in up to 300 options jsons/reefs before calling this.
var reefIndexToNumReefs = reefIndex=>{
	if(manyEvolvableOptions.length < 50) throw 'drag in at least 50 (best if 300) json files (the kind 1k-5k, not the cardano kind thats 13k-16k) first, you dragged in '+manyEvolvableOptions.length;
	if(reefIndex >= manyEvolvableOptions.length || reefIndex >= rarities.length) return 0;
	return rarities[reefIndex]; //FIXME shouldnt rarity be 1/numReefs?
};

var partialRandomizeReefBackgroundColor = opt=>{
	//opt.brightAddRed = asByte(255*Math.pow(pseudorandomFraction(),3));
	
	
	/*
	opt.brightAddRed = asByte(255*sigmoid(randBell()-2.7));
	opt.brightAddGreen = asByte(255*sigmoid(randBell()-2.3));
	opt.brightAddBlue = asByte(255*sigmoid(randBell()-2));
	*/
	let red = .01+pseudorandomFraction()*.6;
	let green = .01+pseudorandomFraction()*.8;
	let blue = .01+pseudorandomFraction();
	let black = .01+pseudorandomFraction()*3;
	//red = blue = green = 1;
	let sum = red+green+blue+black;
	//let mul = (pseudorandomFraction()*pseudorandomFraction())/sum;
	//let mul = pseudorandomFraction()/sum;
	let mul = 1/sum;
	red *= mul;
	green *= mul;
	blue *= mul;
	//red = green = blue = .333;
	/*let bright = Math.pow(pseudorandomFraction(),1.5);
	red *= bright*3;
	green *= bright*3;
	blue *= bright*3;
	//now its that brightness but red andOr green andOr blue might be bigger than 1.
	while(red > 1 || green > 1 || blue > 1){
		let dt = .01;
		if(red > 1){
			red -= dt;
			blue += dt/2;
			green += dt/2;
		}
		if(green > 1){
			green -= dt;
			red += dt/2;
			blue += dt/2;
		}
		if(blue > 1){
			blue -= dt;
			red += dt/2;
			green += dt/2;
		}
	}*/
	opt.brightAddRed = asByte(red*255);
	opt.brightAddGreen = asByte(green*255);
	opt.brightAddBlue = asByte(blue*255);
	
	//opt.brightAddGreen = asByte(255*(1-Math.pow(1-pseudorandomFraction(),2.2)));
	//opt.brightAddBlue = asByte(255*(1-Math.pow(1-pseudorandomFraction(),1.8)));
};

let reefIndexToName = reefIndex=>{
	let s = '000'+(reefIndex+1);
	//return 'GeneReef'+s.substring(s.length-4);
	return dom('reefNamePrefix').value+s.substring(s.length-4);
};

var allReefsStayInsideBorderCircleIn_makeSpecies = true;

//A replacement for makeNOptions. Returns a list of reef options, given which species (speciesIndex+1 is speciesNum.
//speciesIndex ranges 0 to manyEvolvableOptions.length-1, and you add 1 to get speciesNum (1 to 300).
//Returns a list of reefIndexToNumReefs(reefIndex) number of options/reefs, or returns [] if the reefIndex is bigger than that (rarity is theres 0 of them).
//nftStuff is like {colorsReefs: [...], bootShapesReefs: [...], ...}.
var makeSpecies = (speciesIndex,nftStuff)=>{
	//FIXME shouldnt rarity be 1/numReefs?
	//let rarity =
	let numReefs = reefIndexToNumReefs(speciesIndex);
	let firstReefIndexOfSpecies = speciesIndexToFirstReefIndex(speciesIndex);
	let reefs = [];
	//arbitrary number up to 2^48-1, per speciesIndex, but since the pseudorandomness generator (pseudorandomNext)
	//doesnt work well with small numbers (these are around 0-299), put in some extra pseudorandomness here.
	let seed = (174554271169753+179225285996734*speciesIndex*speciesIndex)%Math.pow(2,48);
	//let skipsLeft = 100;
	let skipsLeft = 300;
	repeatable(
		()=>{
			while(reefs.length < numReefs){
				//throw 'TODO';
				
				let reefIndex = firstReefIndexOfSpecies+reefs.length; //only if estimateFitsInCardano
				
				//let s = nftStuff.slidersAndGroovesReefs[(sIndex++)%slidersAndGroovesReefs.length];
				let s = manyEvolvableOptions[speciesIndex]; //1 of the (for example) 300 species, range 0 to 299 in that case.
				let cIndex = randInt(nftStuff.colorsReefs.length);
				let c = nftStuff.colorsReefs[cIndex]; //repeatable pseudorandom
				let bIndex = randInt(nftStuff.bootShapeReefs.length);
				let b = nftStuff.bootShapeReefs[bIndex]; //repeatable pseudorandom
				let opt = makeOptions(s, c, b);
				
				/*
				if(Math.random() < .5){
					if(Math.random() < .1) opt.paintBrightAdd = Math.pow(pseudorandomFraction()*.5,2);
					if(Math.random() < .5){
						opt.wrapPaintBrightMult = true; //wrap around 0 to 1 when color exceeds 1 in red green or blue individually.
						let mul = 1+pseudorandomFraction()*4;
						opt.brightMultRed = pseudorandomFraction()*mul;
						opt.brightMultGreen = pseudorandomFraction()*mul;
						opt.brightMultBlue = pseudorandomFraction()*mul;
					}else{
						if(Math.random() < .5) opt.sameColorness = pseudorandomFraction()*.6;
						opt.brightMultRed = pseudorandomFraction();
						opt.brightMultGreen = pseudorandomFraction();
						opt.brightMultBlue = pseudorandomFraction();
					}
				}//else leave brightMultRed *Green *Blue and wrapPaintBrightMult as they are.
				*/
				opt.brightMult = .00001; //make hills/accelVoxels invisible
				let growInward = opt.bootShape.includes('growInward');
				if(allReefsStayInsideBorderCircleIn_makeSpecies || growInward){ //like in growInwardFromCircle.json but any species can do it, in theory.
					//"stayInsideBorderCircleForce":5361433391626.719 //from growInwardFromCircle.json
					//border circle repels at least as much as growInwardFromCircle.json, except if other optinos interfere with that it might not.
					//opt.stayInsideBorderCircleForce = Math.max(5361433391626,opt.stayInsideBorderCircleForce);
					//opt.scalePotentialEnergyForce/7.883 cuz growInwardFromCircle.json's scalePotentialEnergyForce is 7.883.
					opt.stayInsideBorderCircleForce = Math.max(5361433391626.719 * opt.scalePotentialEnergyForce/7.883, opt.stayInsideBorderCircleForce);
				}
				
				partialRandomizeReefBackgroundColor(opt);
				
				
				opt.name = 'GeneReef_S'+(speciesIndex+1)+'E'+(reefs.length+1)+'_'+opt.name;
				 
				let soo = sizeOfOptions(opt);
				//let estimateFitsInCardano = soo <= estimated_sizeOfOptions_limit;
				//allow a little bigger than estimated_sizeOfOptions_limit cuz changing bootShape sometimes increases size, depending on which bootShape.
				let estimateFitsInCardano = soo <= estimated_sizeOfOptions_limit_afterChangeBootShape;
				
				/*moved this code down...
				if(!estimateFitsInCardano){
					console.log('Skipping reef cuz sizeOfOptions='+soo+' name would be: '+opt.name);
					continue;
				}*/
				
				opt.meta = { //this goes into cardano metadata but (TODO) is removed from options. Problem is, when to remove it from options, since its read from options before putting it in metadata.
					geneReefId: ''+(reefIndex+1), //geneReefId: reefIndexToName(reefIndex),
					startingShape: ''+(bIndex+1),
					//foregroundColorPattern: ''+(cIndex+1), //aka colorSeed
					colorSeed: ''+nftStuff.colorsReefs[cIndex].colorSeed,
					//viewForegroundThroughColoredGlass: ''+colorStr(256*opt.brightMultRed+opt.paintBrightAdd,256*opt.brightMultGreen+opt.paintBrightAdd,256*opt.brightMultBlue+opt.paintBrightAdd),
					//foregroundSingleColorness: Math.ceil(opt.sameColorness*100)+'%',
					species: ''+(speciesIndex+1),
					//reefsInSpecies: ''+numReefs,
					backgroundColor: colorStr(opt.brightAddRed,opt.brightAddGreen,opt.brightAddBlue),
				};
				if(estimateFitsInCardano){
					reefs.push(opt);
					console.log('makeSpecies '+opt.name);
					if(growInward) console.log('^ growInward: '+opt.name);
				}else{
				
					console.log('Skipping reef cuz sizeOfOptions='+soo+' name would be: '+opt.name);
				
					skipsLeft--;
					if(!skipsLeft){
						let err = 'Didnt fit too many times for speciesIndex='+speciesIndex+' sizeOfOptions='+soo+' name='+opt.name;
						//console.log(err); //FIXME throw instead
						throw err;
						
						//throw err;
					}
					
					
					//reefs.push(opt); //FIXME throw instead. this isnt a skip.
				}
			}
		},
		seed
	);
	return reefs;
};

//default sort in js is convert to string first.
var compareNumbers = (a,b)=>{
	if(a<b) return -1;
	if(a>b) return 1;
	return 0;
};

//Returns a list of numbers that sum to 8888.
//FIXME shouldnt rarity be 1/numReefs?
var makeRaritiesList = ()=>{
	let rarities = [];
	for(let i=0; i<300; i++) rarities[i] = Math.ceil((i+1)/5);
	let sum;
	let targetSum = 8888;
	while((sum=arraySum(rarities)) > targetSum){
		rarities.sort(compareNumbers); //slow to do this in a loop, but it only has to do it about 270 times in an array about size 300.
		rarities[rarities.length-1]--; //whichever is the most common, remove 1 reef from it.
	}
	rarities.sort(compareNumbers);
	return rarities;
};

//made by makeRaritiesList then copied here, in case someone wants to edit it manually.
//FIXME shouldnt rarity be 1/numReefs?
var rarities = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51];

var arraySum = array=>{
	let sum = 0;
	for(let i of array) sum += i;
	return sum;
};

//reef index in manyEvolvableOptions, should range 0 to 299, but maybe should be displayed as 1 to 300 (+1).
//OLD... The quantity of reefs returned, in a list, is Math.ceil((i+1)/5),
//so theres 1 of each of the first 5 reefs, 2 of each of the second 5 reefs, 3 of each of the third 5 reefs,
//and so on up to around 60 of each of the 60th 5 reefs, totalling a little more than 8888 reefs,
//and caller should drop those past total 8888.
//OR FIXME TODO... make an array of 300 numbers that sum to exactly 8888. Do that in rarities = [... Doing that in makeRaritiesList().
var makeReefSpecies = reefIndex=>{
}

var copyMapAndPutInDefaultsIfAbsent = map=>{
	let ret = copyMap(map);
	putInDefaults(ret); //in case its missing some things, which werent included in older versions of the reef builder.
	return ret;
};

/*use optionsMapToCardanoJson instead...
//Returns an options map/{}. Use optionsMapToCardanoJson func to change it after that.
var optionsToCardanoMap = (sliderAndGroove, colorsReef, bootShape)=>{
	throw 'TODO';
};*/


//returns a string that can be used at poolpm and will only fit in cardano (in theory) if has at most maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt bytes,
//so check its size before using. To make it smaller use isMaxCompress=true. To just test it in poolpm quickly, use isMaxCompress=false,
//but you will need to test some with isMaxCompress=true before deploying to cardano.
//isMaxCompress is chosen by "SLOW MAX COMPRESS WHEN SAVE (FAST AS NFT)" checkbox.
var optionsMapToCardanoJson = map=>{
	return jsonForCardano(prefixHtml, map, nonminifiedJavascript, minifiedJavascriptFromUglifyjs, suffixHtml);
};


var repeatable = (func,optionalSeed)=>{
	let seed = optionalSeed!==undefined ? optionalSeed : 134546734455471n;
	let prevSeed = getColorSeed();
	try{
		setColorSeed(seed); //just a once-random constant from 0 to 2^48-1, so the compression is repeatable. 
		return func();
	}finally{
		setColorSeed(prevSeed); //just a once-random constant from 0 to 2^48-1, so the compression is repeatable. 
	}
};

//Returns a copy of each options, in the same order they occur in the param list, which has a unique colorSeed.
//a list of prototypes like manyEvolvableOptions after you drag in multiple 1-5kB json files at once.
//Excludes those that have no colorSeed (would get it from putInDefaults).
var getUniqueColorReefsFromPrototypes = prototypes=>{
	let findDups = {};
	let ret = [];
	for(let opt of prototypes){
		if(opt.colorSeed){
			if(!findDups[opt.colorSeed]){
				findDups[opt.colorSeed] = true;
				ret.push(copyMap(opt));
			}
		}
	}
	return ret;
};

//like getUniqueColorReefsFromPrototypes except for bootShape, bootShapeY, bootShapeX, and bootShapeScale.
var getUniqueBootShapeReefsFromPrototypes = prototypes=>{
	let findDups = {};
	let ret = [];
	for(let opt of prototypes){
		if(opt.bootShapeY && opt.bootShapeX && opt.bootShapeScale && opt.bootShape){
			let dupKey = opt.bootShapeY+'_'+opt.bootShapeX+'_'+opt.bootShapeScale+'_'+opt.bootShape;
			if(!findDups[dupKey]){
				findDups[dupKey] = true;
				ret.push(copyMap(opt));
			}
		}
	}
	return ret;
};

/*
//returns a list size n.
var chooseN = (list,n)=>{
	throw 'TODO';
};*/

//species index normally ranges 0 to 299 (as of 2022-4-9), but sizes might be redesigned later.
//This is just cumulative sum of number of reef types before it. See rarities list.
var reefIndexToSpeciesIndex = reefIndex=>{
	let sum = 0;
	for(let i=0; i<rarities.length; i++){
		let speciesSize = rarities[i];
		let nextSum = sum+speciesSize;
		if(nextSum > reefIndex) return i;
		sum = nextSum;
	}
	//Whatever theres not room for in the 8888 reefs (a few extras are there in case some are broken) is,
	//for example, species 300, after the first 300 species which are 0 to 299. Displayed species might be that plus 1.
	return rarities.length;
};

var speciesIndexToFirstReefIndex = speciesIndex=>{
	if(speciesIndex == rarities.length) return arraySum(rarities); //the last species is reefs that dont fit in the 8888.
	let sum = 0;
	for(let i=0; i<speciesIndex; i++){
		sum += rarities[i];
	}
	return sum;
};

var speciesIndexToLastReefIndex = speciesIndex=>{
	if(speciesIndex == rarities.length) throw 'TODO';
	return speciesIndexToFirstReefIndex(speciesIndex+1)-1;
};

//the "extra" species that doesnt fit in the for example 8888 reefs, thats only there in case some reefs are broken.
//speciesIndex normally ranges 0 to 300, and the NFT species are normally 0 to 299.
var lastSpecies = speciesIndex=>rarities.length;


var copyOfLast_makingReefs_list = null;

var newPrototypeReef = ()=>{
	let ret = copyMap(savedWrappedOptions[0].options);
	putInDefaults(ret);
	return ret;
};

var makeBootShapeReefFromCode = code=>{
	let ret = newPrototypeReef();
	ret.bootShape = code;
	//ret.bootShapeY = .01;
	//ret.bootShapeX = .01;
	//ret.bootShapeScale = 1;
	//ret.bootShapeScale *= .8; //a little smaller
	
	
	if(!code.includes('growInward')){
		//ret.bootShapeScale *= .6; //smaller
		ret.bootShapeScale *= .46; //smaller, hits circle border less often
		ret.bootShapeScale = between(.25, ret.bootShapeScale, 1.5);
	}
	//else leave it as the border circle aka a=>1 and bootShapeScale is 1, which is in the boot shapes list,
	//manually copied from growInwardFromCircle.json, so many reefs can start that way,
	//BUT WARNING: without "stayInsideBorderCircleForce":5361433391626.719 (or higher, depending on other options)
	//like it is in growInwardFromCircle.json, it may also grow outward from the border circle, which may hit the square border past that circle
	
	
	
	//ret.bootShapeY = .3*randBell();
	//ret.bootShapeX = .3*randBell();
	//ret.bootShapeScale = .4+.8*Math.sqrt(pseudorandomFraction); //normally is 1, but looks strange if bigger than 1. TODO adjust scale?
	return ret;
};

//makes 44 (as of 2022-4-10-2pEST) bootShapes (or however many are in the bootShapes list.
var makeBootShapes = ()=>{
	let list = [];
	repeatable(()=>{
		for(let bootShape of bootShapes) list.push(makeBootShapeReefFromCode(bootShape));
	});
	return list;
};

//optionalSaveFileType can be 'zip' or 'json'. If json, its a list of reefs.
//
//TODO???[[[
//optionalGroupBy can be undefined to put it all in 1 zip (just dont give that param)
//or 'color' to have one zip per color,
//or 'slidersAndGrooves' to have one zip per slidersAndGrooves,
//or 'bootShape' to have one zip per combo of [bootShapeY bootShapeX bootShapeScale bootShape].
//]]]
//
//saves it async, cuz async is all that jszip allows.
var afterDraggingInPrototypesMakeAndDownloadZipFileOfReefsOptions = (optionalHowManyReefs,optionalMakeHowManyStart, optionalMakeHowManyEnd, optionalSaveFileType, optionalGroupBy)=>{
	let saveFileType = optionalSaveFileType || 'json';
	if(optionalGroupBy) throw 'TODO';
	let howManyReefs = optionalHowManyReefs===undefined ? 8888 : optionalHowManyReefs;
	if(howManyReefs != 8888) throw 'Number of total reefs has to be 8888 but is '+howManyReefs;
	if(arraySum(rarities) != howManyReefs) throw arraySum(rarities)+' == arraySum(rarities) != howManyReefs == '+howManyReefs;
	let makeHowManyStart = optionalMakeHowManyStart || 1;
	makeHowManyStart = mx(1,makeHowManyStart);
	let makeHowManyEnd = optionalMakeHowManyEnd || howManyReefs;
	makeHowManyEnd = mn(makeHowManyEnd, howManyReefs);
	let howManyNow = makeHowManyEnd+1-makeHowManyStart;
	
	console.log('Sorting manyEvolvableOptions (size '+manyEvolvableOptions.length+') by optionsComparator, which is the order of the reef species (that around 1-60 will be made of each, depending on rarity calculations. Those earlier in manyEvolvableOptions will be rarer, basically a triangle array of theres 1 of each of the first 5 reefs, 2 of each of the second 5 reefs, 3 of each of the third 5 reefs, and so on until 8888 reefs (rarities were designed to use 300 reef species dragged in).');
	manyEvolvableOptions.sort(optionsComparator);
	console.log('Sorted.');
	
	let prototypes = copyMap(manyEvolvableOptions);
	if(prototypes.length < 2) throw 'You should have a few hundred prototypes, and at least 2 are needed, but you dragged in '+prototypes.length+' (or if thats 0 you didnt drag in any)';
	//TODO look for duplicate sliderAndGroove in the prototypes, but even if there are some, they might still get different colors, or that might overlap too.
	let slidersAndGroovesReefs = prototypes;
	let colorsReefs = getUniqueColorReefsFromPrototypes(prototypes);
	
	
	//let bootShapeReefs = getUniqueBootShapeReefsFromPrototypes(prototypes);
	//TODO? let seed = (174554271169753+179225285996734*speciesIndex*speciesIndex)%Math.pow(2,48);
	let bootShapeReefs = makeBootShapes();
	//for(let breef of bootShapeReefs){
	//}
	//ret.bootShapeY = .3*randBell();
	//ret.bootShapeX = .3*randBell();
	//ret.bootShapeScale = .4+.8*Math.sqrt(pseudorandomFraction); //normally is 1, but looks strange if bigger than 1. TODO adjust scale?
	
	
	//let fractionToChangeBootShapes = .5; //FIXME this isnt used as of 2022-3-28.
	
	
	let nftStuff = {
		slidersAndGroovesReefs: slidersAndGroovesReefs,
		colorsReefs: colorsReefs,
		bootShapeReefs: bootShapeReefs,
	};
	
	//let reefs = makeNOptions(howManyReefs, slidersAndGroovesReefs, colorsReefs, bootShapeReefs, fractionToChangeBootShapes);
	
	let makingReefs = [];
	//for(let i=0; i<howManyReefs; i++){
	while(makingReefs.length < howManyReefs){
		//species overlaps the range of reefs requested, such as genereef3820 to genereef4117,
		//so make the whole species, but only use the parts of it requested.
		//For efficiency, caller should request on the borders of species, so dont have to make the same species again.
		let speciesIndex = reefIndexToSpeciesIndex(makingReefs.length);
		if(speciesIndex == lastSpecies()) break; //dont include the last/extra species.
		
		let speciesFirstReefIndex = speciesIndexToFirstReefIndex(speciesIndex);
		let speciesLastReefIndex = speciesIndexToLastReefIndex(speciesIndex);
		let speciesSize = speciesLastReefIndex+1-speciesFirstReefIndex;
		
	

		//FIXME likely off by 1 here
		if(speciesLastReefIndex < (makeHowManyStart-1) || (makeHowManyEnd-1) < speciesFirstReefIndex){ //skip the species. -1 cuz starts at 0 vs 1
			for(let i=0; i<speciesSize; i++) makingReefs.push(null);
		}else{
			let listOfReefs = makeSpecies(speciesIndex,nftStuff); //[...{},{},{}...]
			if(listOfReefs.length != speciesSize) throw 'Wrong speciesSizs for speciesIndex='+speciesIndex+' observed='+listOfReefs.length+' expected='+speciesSize;
			makingReefs.push(...listOfReefs);
		}
	}
	
	/*let reefs = [];
	for(let i=makeHowManyStart; i<=makeHowManyEnd; i++){ //makeHowManyStart and makeHowManyEnd range 1 to 8888. reefIndex ranges 0 to 8887.
		let reef = makingReefs[i-1]; //range 0 to 8887
		if(!reef) throw 'Didnt make reefIndex='+i+' (+1 for genereef0001 to genereef8888)';
		reefs.push(reef);
	}
	*/
	copyOfLast_makingReefs_list = copyMap(makingReefs); //only used by onClickSE, for if you want to load any of the reefs into the builder.
	let reefs = makingReefs; //just leave the nulls in, and this array size is 8888
	//now have made the requested range of reefs, as options jsons (the 1k to 5k kind).
	
	var alsoSaveHtmlFilesInZip = dom('alsoSaveHtmlFilesInZip').checked;
	
	const filename = 'testReefs_total'+howManyReefs+'_from'+makeHowManyStart+'_to_'+makeHowManyEnd+'.'+saveFileType;
	if(saveFileType == 'zip'){
		let mapToMakeZipFrom = {};
		console.log('Making cardano jsons to put in zip...');
		let now = Now();
		//for(let i=0; i<reefs.length; i++){
		for(let i=makeHowManyStart-1; i<makeHowManyEnd; i++){ //-1 cuz reef numbers start at 1. not for end, cuz its inclusive.
			//sharedLogSuffix = ' makeHowManyStart-1='+(makeHowManyStart-1)+' i='+i+' makeHowManyEnd='+makeHowManyEnd;
			sharedLogSuffix = ' - '+reefIndexToName(makeHowManyStart-1)+' --> '+reefIndexToName(i)+' --> '+reefIndexToName(makeHowManyEnd-1);
			//mapToMakeZipFrom[reefs[i].name+'.options.json'] = JSON.stringify({timeSaved:now,options:reefs[i]});
			mapToMakeZipFrom[reefs[i].name+'.options.json'] = packedOptionsStr({timeSaved:now,options:reefs[i]}); //so {} has same order of keys every time
			let cardanoJson = optionsMapToCardanoJson(reefs[i]);
			let bytesOver = cardanoJson.length-maxCardanoTransactionBytes_beforeBlockchainPersonModifiesIt;
			let cardanoSuffix = bytesOver<=0 ? '.cardanoPROBABLYFITS.json' : '.cardano'+bytesOver+'BYTESTOOBIG.json';
			mapToMakeZipFrom[reefs[i].name+cardanoSuffix] = cardanoJson;
			let htmlFileOfThatReef = htmlNFT; //created by optionsMapToCardanoJson which calls jsonForCardano which calls dataUrlOfGenereef which sets htmlNFT.
			if(alsoSaveHtmlFilesInZip) mapToMakeZipFrom[reefs[i].name+'.html'] = htmlFileOfThatReef;
		}
		console.log('Making zip of '+reefs.length+' reefs');
		mapToZipThen(
			mapToMakeZipFrom,
			zip=>{
				console.log('Saving zip file of '+zip.length+' bytes (browser will download it, suggested filename is '+filename+')');
				saveFile(filename,zip,'application/zip');
			}
		);
	}else if(saveFileType == 'json'){
		let isPart = howManyNow!=reefs.length;
		console.log('Making '+(isPart ? 'part of ' : '')+'json list of total'+reefs.length+' reefs'+(isPart ? ', but only from reef'+makeHowManyStart+' to reef'+makeHowManyEnd : ''));
		let partOfReefs = reefs.slice(makeHowManyStart-1, makeHowManyEnd);
		//let fileContent = JSON.stringify(reefs);
		let fileContent = JSON.stringify(partOfReefs);
		console.log('Saving json file of '+fileContent.length+' bytes (browser will download it, suggested filename is '+filename+')');
		saveFile(filename,fileContent,'application/json');
	}else{
		throw 'Unknown saveFileType='+saveFileType;
	}
};

var onClickButtonToMakeReefZip = ()=>{
	if(manyEvolvableOptions.length < 50){
		alert('Drag in at least 50 (best if a few hundred or more) reef options files (1-5kB each) first');
	}else{
		let saveMultiReefsAsFileType = dom('saveMultiReefsAsFileType_zip_else_json').checked ? 'zip' : 'json';
		alert('Got '+manyEvolvableOptions.length+' prototype reefs. Making '+saveMultiReefsAsFileType+'...');
		
		let makeHowMany = ro(dom('makeHowManyReefs').value);
		let makeHowManyStart = ro(dom('makeHowManyReefs_start').value);
		let makeHowManyEnd = ro(dom('makeHowManyReefs_end').value);
		let makeHowManyNow = makeHowManyEnd+1-makeHowManyStart;
		/*
		if(dom('isCompressOptionsToo').checked){
			alert('since maxcompress is on, which is slow, just making 3 for now, as a test');
			//TODO 8888 in small batches, maybe done on rented VM computers, or maybe find a way to compress faster
			afterDraggingInPrototypesMakeAndDownloadZipFileOfReefsOptions(3,saveMultiReefsAsFileType);
		}else{
			alert('Making 100 for now, as a test');
			afterDraggingInPrototypesMakeAndDownloadZipFileOfReefsOptions(100,saveMultiReefsAsFileType); //TODO 8888
		}*/
		if(dom('isCompressOptionsToo').checked && makeHowManyNow > 3 && !confirm('It could be very slow to make '+makeHowManyNow+' reefs cuz MAX COMPRESS. Continue?')) throw 'user cancelled';
		if(dom('saveMultiReefsAsFileType_zip_else_json').checked && makeHowManyNow > 100 && !confirm('It could be very slow to make '+makeHowManyNow+' reefs in a ZIP file. Continue?')) throw 'user cancelled';
		afterDraggingInPrototypesMakeAndDownloadZipFileOfReefsOptions(makeHowMany,makeHowManyStart,makeHowManyEnd,saveMultiReefsAsFileType);
	}
};




</script>

</head><body style="background-color:black;color:white;user-select:none">
<div id=se2></div>

<nobr><input type=button onclick="restart();" value="restart"></input><input type=button onclick="clearCanvas();" value="clearCanvas"></input><input type=button onclick="let dataurl = canv.dom.toDataURL('image/jpeg',dom('picQuality').value); navigator.clipboard.writeText(dataurl);" value="copy pic dataurl to clipboard"></input>
quality 0 to 1: <input type=number id=picQuality min=0 max=1 value=0 step=.01></input>
<input id=chkBuilder checked type=checkbox onclick="dom('grooveLabelsDiv').style.visibility = dom('labelBuilder').style.visibility = dom('reefBuilder').style.visibility = this.checked ? 'visible' : 'hidden';"><label id=labelBuilder for=chkBuilder>display reef builder (uncheck for emptier screen)</label></nobr><br>

<nobr>
	whichHill<input type=number id=hillIndex step=1 value=0 style="width:65px" oninput="loadHillNums(this.value);"></input>
	centerY<input type=number id=hillCenterY step=.02 value=0 style="width:65px" oninput="hillNumInput();"></input>
	centerX<input type=number id=hillCenterX step=.02 value=0 style="width:65px" oninput="hillNumInput();"></input>
	radius<input type=number id=hillRadius step=.01 value=.03 style="width:65px" oninput="hillNumInput();"></input>
	repel<input type=number id=hillRepelForce step=.1 value=1 style="width:65px" oninput="hillNumInput();"></input>
	accelY<input type=number id=hillAccelY step=.1 value=0 style="width:65px" oninput="hillNumInput();"></input>
	accelX<input type=number id=hillAccelX step=.1 value=0 style="width:65px" oninput="hillNumInput();"></input>
</nobr>

<div id=divabxy style="background-color:black;color:white;width:0px;height:0px">
</div>
<div id=reefBuilder ondragover="event.stopPropagation(); event.preventDefault();" ondragleave="event.stopPropagation(); event.preventDefault();" ondrop="dragEvent=event; onDragFiles(event.dataTransfer.files); event.preventDefault(); event.stopPropagation();">
<table border=0>
	<tr>
		<td valign=top>
			Hold mouse over a slider, checkbox, or buttons on the left,<br>
			or the text to the right of it, for popup to explain it.<br>
			<nobr><input type=checkbox id=chkOnlyPaintSelectedLoop></input><label for=chkOnlyPaintSelectedLoop>only display selected groove (click clearCanvas if other grooves remain)</label></nobr>
			<div id="buttonsDiv"></div>
			<div id="slidersDiv"></div>
			<div id="checkboxesDiv"></div>
			<div id="perimeter"></div>
		</td><td>
			<div id="aDiv">aDiv</div>
		</td><td width=30% valign=top>
			<div id=sizeOfOptionsDiv></div><br>
			This is the only button you need<br>
			to make json for <a href=https://pool.pm/test/metadata>https://pool.pm/test/metadata</a><br>
			<input type=button onclick="saveExampleNFT();" value="Save json for  https://pool.pm/test/metadata"></input><br>
			<input type=checkbox id=isCompressOptionsToo checked></input><label for=isCompressOptionsToo>SLOW MAX COMPRESS WHEN SAVE (FAST AS NFT)<br>takes a minute or so every time, not just the first time.</label><br><br>
			
			Choose max compress or not, then...<br>
			<nobr>Choose to <input type=checkbox id=saveMultiReefsAsFileType_zip_else_json checked></input><label for=saveMultiReefsAsFileType_zip_else_json>save multi reefs as zip</label> else json list, then</nobr><br>
			<nobr><input type=checkbox id=alsoSaveHtmlFilesInZip checked></input><label for=saveMultiReefsAsFileType_zip_else_json>zip also contains html reefs</label></nobr><br>
			To make NFTs, Drag in many reef files (1-5kB jsons) then...<br>

			<input type=button onclick="onClickButtonToMakeReefZip();" value="make many reefs zip file"></input>
			<nobr><input type=number id=makeHowManyReefs value=8888 min=1 max=8888 disabled></input> total reefs to make</nobr><br>
			Since its slow to make 8888 reefs all at once...<br>
			(moving "start at reef number" and "end at reef number" lower, near the rarities numbers)<br>
			<input type=text id=reefNamePrefix value="GeneReef"></input><br>
			
			
			<br>
			<nobr><input type=checkbox id=cacheCompressionInCookies></input><label for=cacheCompressionInCookies>cache compression in cookies</label></nobr><br>
			<input type=button onclick="window.localStorage.clear();" value="clear cookies"></input> (for if compression algorithm changes or it gets too big)<br>
			<br>
			
			
			<nobr>
				<input type=button onclick="savingString = exampleNFT();" value="click this before copy/savehtml (takes a minute or so the first time)"></input><br>
				<input type=button onclick="navigator.clipboard.writeText(savingString);" value="copy json for https://pool.pm/test/metadata to clipboard"></input><br>
				<input type=button onclick="saveHtml(dom('reefName').value+'.html',htmlNFT);" value="save html"></input><br>
			</nobr>
			<input type=button onclick="window.open('https://pool.pm/test/metadata', '_sdfasddf'+randInt(1000000000));" value="open https://pool.pm/test/metadata in new tab"></input><br>
			<label id=compressionProgress></label>
			<input type=button onclick="window.open('https://pool.pm/test/metadata?metadata='+exampleNFT(), '_sdfasddf'+randInt(1000000000));" value="open https://pool.pm/test/metadata?metadata=..." disabled></input><br>
			bootShape editor. Examples: a=>.2 Example: a=>[2+Math.sin(a*5),a*a]. Example: a=>{a*=2/Math.PI; if(a<1) return [a%1-.5,-.5]; if(a<2) return [a%1-.5,.5]; if(a<3) return [-.5,a%1-.5]; return [.5,a%1-.5];} <a href=https://www.wolframalpha.com/>WolframAlpha</a> might help you figure out some boot shapes, but the syntax differs.<br>
			<input type=button value="random bootShape" onclick="let code = randomBootShapeThatPassesTests(10,dom('randomBootShapeIsYXElseRadius').checked); dom('bootShapeEditor').value = code; setBootShapeAndRestart(code);"></input>
				<nobr><input type=checkbox id=randomBootShapeIsYXElseRadius></input><label for=randomBootShapeIsYXElseRadius>randomBootShapeIsYXElseRadius<label></nobr><br>
			<textarea id=bootShapeEditor rows=6 cols=55 placeholder="boot shape editor" oninput="setBootShapeAndRestart(this.value);"></textarea><br>
			<label id=bootShapeEditorErr></label><br>
			<input type=button value="start over editing bootShape" onclick="dom('bootShapeEditor').value = o.bootShape; setBootShapeAndRestart(o.bootShape);"></textarea><br>

			<div id="multiOptionsDiv">multiOptionsDiv</div>
			<label for=doStringReplacements>doStringReplacements when click buttons</label><input type=checkbox id=doStringReplacements checked></input><br>
			
			<input type=button value="evolve next reef from multiple json files dragged in at once" onclick="evolveNextReef();"></input><br>
			
			<nobr><label for=paintBackground>paint hills instead of grooves (FIXME a loop must be selected)</label><input type=checkbox id=paintBackground></input></nobr><br>
			<label for=selectHillWhenClick>select hill/accelVoxel when click</label><input type=checkbox id=selectHillWhenClick></input><br>
			<label for=deleteHillWhenClick>delete hill/accelVoxel when click (overpowers select)</label><input type=checkbox id=deleteHillWhenClick></input><br>
			<input type=button onclick="useAsBoot();" value="use current shape as bootShape" disabled></input>
			<input type=button onclick="delete o.bootShapeYp; delete o.bootShapeXp; delete oo.bootShapeYp; delete oo.bootShapeXp; restart();" value="clear bootshape"disabled></input>
			<input type=button onclick="putHills(o.accelVoxels);" value="repaint hills"></input>
			<input type=button onclick="clearHills();" value="clear hills"></input>
			<br>
			<nobr><label for=dragChangesColorSeed>dragging in json file changes colors</label><input type=checkbox id=dragChangesColorSeed checked></input></nobr><br>
			<nobr><label for=dragChangesCurves>dragging in json file changes most sliders/checkboxes</label><input type=checkbox id=dragChangesCurves checked></input></nobr><br>
			<nobr><label for=dragChangesIsSurface>dragging in json file changes isSurface</label><input type=checkbox id=dragChangesIsSurface checked></input></nobr><br>
			<nobr><label for=dragChangesBootShape>dragging in json file changes boot shape</label><input type=checkbox id=dragChangesBootShape checked></input></nobr><br>
			<nobr><label for=dragChangesGrooves>dragging in json file changes grooves</label><input type=checkbox id=dragChangesGrooves checked></input></nobr><br>
			<nobr><label for=dragChangesHills>dragging in json file changes hills<br>(might need to adjust accelFieldMul<br>if it has no effect or too strong an effect)</label><input type=checkbox id=dragChangesHills checked></input></nobr><br>
			<nobr><label for=dragChangesFuncs>dragging in json file changes funcs<br>(but so far 2022-3 theyre all the same<br>except maybe some old reefs)</label><input type=checkbox id=dragChangesFuncs checked></input></nobr></font><br>
			<nobr><label for=dragChangesDir>dragging in json file changes dir (such as 1 2 3 or 4)</label><input type=checkbox id=dragChangesDir checked></input></nobr></font><br>
			<font color=gray><nobr><label for=dragChangesReefName>dragging in json file changes name</label><input type=checkbox id=dragChangesReefName checked disabled></input></nobr></font><br>
			If you change the code inside this file, it will work in this file like if you drag in json files (for testing and building and displaying reefs, but doesnt fit in cardano cuz this file includes the builder which is too big (unless you used ipfs, it would fit there and the default reef displayed is between "var savedWrappedOptions = [{" and "}]" or just the options:{...} part of that)), but for poolpm/cardano... This file must be updated after every change to the code below the "////aaaa". Copy all of that (from ////aaaa to just before the /script tag) into https://skalman.github.io/UglifyJS-online/ and use the "let uglifyjsOptions =" (the part between { and } right after that) as the uglifyjs options, minify it, and copy to between the " and " of minifiedJavascriptFromUglifyjs = "... Then open the html file and try it. Your changes (to the code below ////aaaa) should work in https://pool.pm/test/metadata (use the buttons above to make that). Check in browser console for error messages, cuz sometimes (for a reason I havent figured out (yet?)) if you make changes like that, it doesnt work in poolpm but it does if you save a html here or use it in this bigger html by drag and drop. It might be related to which parts are %20 %ff etc escaped or some chars not allowed. The whole thing must fit in 16384 (or maybe the limit is a little less?) bytes, as json as all 1 line with no indenting, else it wont fit in a cardano transaction metadata. Some of the buttons above will tell you if its too big or slightly over might still work since we're not sure exactly whats the limit.
			<!-- DOESNT WORK... nobr><input type=checkbox id=dragChangesColorSeed_andRestart checked></input><label for=dragChangesColorSeed_andRestart>restart if change colorSeed</label></nobr><br-->
		</td>
	</tr>
</table>
</div>
<div id="grooveLabelsDiv"></div>
<nobr><input type=number id=makeHowManyReefs_start value=1 min=1 max=8888></input> start at reef number (1 to 8888)</nobr><br>
<nobr><input type=number id=makeHowManyReefs_end value=8888 min=1 max=8888></input> end at reef number</nobr><br>
Click 1 of these 300 species rarities (that should sum to 8888) to set the "start at reef number" and "end at reef number" to that species, then adjust other options and click "make many reefs zip file" button above on right.<br>
<div id=raritiesDiv>
</div>
<div id=se></div>
<br><br><br><br><br><br>


</body></html>
